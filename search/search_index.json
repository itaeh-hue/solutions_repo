{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Deriving basic formulas of the projectile motion Suppose a projectile is launched at an angle \\(\\theta\\) above the horizontal with an initial velocity \\(v_{0}\\) . For this section, assume no air resistance . Horizontal motion ( \\(x\\) -direction) In the absence of air resistance, there is no horizontal force acting on the projectile: \\[ F_{x} = 0 \\] Based on the Second Newton's Law of Motion: \\[ \\vec{F} = m\\vec{a} \\] Therefore, \\[ m a_{x} = 0 \\implies \\frac{d^2x}{dt^2}m=0 \\] Since the projectile does not accelerate on the \\(x\\) -axis, its immediate velocity (the first derivative of path) equals to the initial velocity with which the projectile has been launched in the first place: \\[ \\frac{dx}{dt} = v_{0x} \\] The \\(x\\) -component of the initial velocity is \\[ v_{0x} = v_{0}\\cos(\\theta) \\] Therefore, the equation of motion of the projectile on the \\(x\\) -axis can be described with the following equation: $$ \\boxed{\\frac{dt}{dx} = v_{0}\\cos(\\theta)} $$ Where \\(\\theta\\) is the launch angle of the projectile. To find the \\(x\\) -component of the position of the projectile at time \\(t\\) , we need to solve this equation for \\(x\\) . Solving the above differential equation will give us the following: \\[ x(t) = v_{0}\\cos(\\theta)t + C_{1} \\] To find \\(C_{1}\\) , set the initial condition \\(x(0) = 0\\) (the path at time \\(0\\) is, of course, \\(0\\) ), and therefore \\[ C_{1} = 0 \\] Thus, \\[ \\boxed{x(t) = v_{0}\\cos(\\theta)t} \\] This equation will give us the position of the projectile at the time \\(t\\) . Vertical motion ( \\(y\\) -direction) The only force acting vertically is the force of gravity : \\[ F_{y}=-mg \\] The projectile doesn't experience any other acceleration and moves until it hits the ground due to gravity. Therefore, the \\(y\\) -component of the projectile motion can be described with the following equation: \\[ \\boxed{\\frac{dy}{dt} = v_{0}\\sin(\\theta)-gt} \\] Where \\(v_{0}\\sin(\\theta)\\) is the \\(y\\) -component of the initial velocity of the projectile, and \\(g\\) is the acceleration due to gravity (i.e., \\(\\frac{d^2y}{dt^2} = -g\\) ). This gives us \\[ \\boxed{y(t)=v_{0}\\sin(\\theta)t -\\frac{1}{2}gt^2} \\] When the projectile hits the ground To find when the projectile hits the ground, we set \\(y(t)=0\\) (altitude zero): \\[ 0=v_{0}\\sin(\\theta)t -\\frac{1}{2}gt^2 \\] Rearranging items gives us: \\[ -\\frac{1}{2}gt^2 + v_{0}\\sin(\\theta) = 0 \\] Solving the quadratic equation: \\(D=(v_{0}\\sin(\\theta))^2\\) \\(t_{1} = \\frac{-v_{0}\\sin(\\theta)+v_{0}\\sin(\\theta)}{-1g} = \\frac{0}{-g} =0\\) - when the projectile is launched; \\(t_{2}=\\frac{-v_{0}\\sin(\\theta)-v_{0}\\sin(\\theta)}{-g}=\\frac{2v_{0}\\sin(\\theta)}{g}\\) So that, the total flight time of a projectile launched with the velocity \\(v_{0}\\) at the angle \\(\\theta\\) : \\[ \\boxed{t_{f}=\\frac{2v_{0}\\sin(\\theta)}{g}} \\] The horizontal range The range that the projectile passes, i.e., the horizontal distance traveled when \\(t=t_{f}\\) , can be found by the formula: \\[R=v_{0x}(t_{f})=v_{0}\\cos(\\theta)\\frac{2v_{0}\\sin(\\theta)}{g}=\\frac{2v_{0}^2 \\left( \\frac{1}{2} \\sin(2\\theta)\\right) }{g}=\\frac{v_{0}^2\\sin(2\\theta) }{g}\\] \\[\\boxed{R=\\frac{v_{0}^2\\sin(2\\theta) }{g}}\\] Investigating how angle and the initial velocity influence the range of the projectile motion Varying angles import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile.\"\"\" # Convert angle to radians angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Parameters initial_velocity = 30 # m/s angles = [15, 30, 45, 60, 75] # Selected launch angles (degrees) # Setting up the plot plt.figure(figsize=(10, 6)) # Loop through each angle to plot the trajectory for angle in angles: x, y = projectile_motion(initial_velocity, angle) plt.plot(x, y, label=f'\u03b8 = {angle}\u00b0') # Customize the plot plt.title('Projectile Trajectories for Different Launch Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show() The general form of the range as a function of \\(\\theta\\) . It demonstrates how varying the launch angle affects the distance traveled. Different values of \\(v_0\\) affect the range as well. As a result, we get a family of parabolic curves when graphed. The range \\(R\\) depends on the angle of projection \\(\\theta\\) through the sine function, which reaches its maximum at \\(90^\\circ\\) . However, due to the sinusoidal nature of the \\(\\sin\u2061(2\\theta)\\) , the optimal launch angle for maximum horizontal range is \\(45^\\circ\\) . Varying initial velocity import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile.\"\"\" # Convert angle to radians angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Parameters angle = 45 initial_velocities = [10, 20, 30, 40, 50] # m/s # Setting up the plot plt.figure(figsize=(10, 6)) # Loop velocities each angle to plot the trajectory for initial_velocity in initial_velocities: x, y = projectile_motion(initial_velocity, angle) plt.plot(x, y, label=f'v0 = {initial_velocity}') # Customize the plot plt.title('Projectile Trajectories for Different Launch Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show() Taking altitude into account Given everything discussed above, let's add another parameter into the equation: altitude. Suppose a projectile is launched from a height \\(h_{0}\\) above the ground. The equation of the vertical component of the motion then changes: \\[ y(t)=h_{0}+v_{0}\\sin (\\theta) t - \\frac{1}{2}gt^2 \\] To find the time of flight with this parameter added, we need to solve the above equation at \\(0\\) : \\[ 0=h_{0}+v_{0}\\sin (\\theta) t - \\frac{1}{2}gt^2 \\] Launch time: \\[ t_{1}=\\frac{v_{0}\\sin(\\theta)+\\sqrt{ v_{0}^2\\sin(\\theta)^2 +2gh_{0} }}{g} \\] When the projectile hits the ground: \\[ t_{2}=\\frac{v_{0}\\sin(\\theta)-\\sqrt{ v_{0}^2\\sin(\\theta)^2 +2gh_{0} }}{g} \\] The horizontal range is then: \\[ R=v_{0}t_{2} \\] Demonstration import numpy as np import matplotlib.pyplot as plt def projectile_motion_with_altitude(v0, angle, h0, g=9.81, dt=0.01): \"\"\"Calculate the trajectory of a projectile launched from an altitude.\"\"\" angle_rad = np.radians(angle) # Initial velocities v_x = v0 * np.cos(angle_rad) v_y = v0 * np.sin(angle_rad) # Initialize lists to store positions and time t_values = [0] x_values = [0] y_values = [h0] # Start from initial height x, y = 0, h0 # Initial position at the height h0 t = 0 # Initial time while y >= 0: # Continue until the projectile hits the ground (y < 0) # Update positions x += v_x * dt y += v_y * dt # Update velocities due to gravity v_y -= g * dt # Only vertical component affected by gravity # Record values t += dt t_values.append(t) x_values.append(x) y_values.append(y) return x_values, y_values # Parameters initial_velocity = 30 # m/s angle = 45 # Launch angle (degrees) altitudes = [-5, 0, 10, 20] # Different launch heights (above or below ground level) # Setting up the plot plt.figure(figsize=(10, 6)) # Loop through different altitudes for h0 in altitudes: x_with_altitude, y_with_altitude = projectile_motion_with_altitude(initial_velocity, angle, h0) plt.plot(x_with_altitude, y_with_altitude, label=f'Initial Height: {h0} m') # Customize the plot plt.title('Projectile Trajectories at Varying Initial Altitudes') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(-10, 150) # X-axis limit plt.ylim(0, 60) # Y-axis limit, accommodating negative heights plt.grid() plt.legend() plt.show() Exploring how launch altitude influences the horizontal range Taking into account air resistance Let's face it: the above model is not realistic unless you live on a planed with zero-density air (actually, you have no chances to survive there). This section aims to derive equations that do take air resistance into account. The simplest model considers a drag force proportional to the velocity ( the faster the projectile moves, the stronger the air resistance ), i.e., linear drag . Horizontal motion with air resistance ( \\(x\\) -direction) The total force acting on the projectile on the \\(x\\) -axis, given air resistance, is as follows: \\[ F_{x} = ma_{x} = -bv_{x} \\] where \\(b\\) is the drag coefficient. Given \\(v_{x} = \\frac{dx}{dt}\\) , and \\(a_{x} = \\frac{d^2x}{dt^2}\\) , we derive: \\[ \\begin{cases} F_{x} = m \\frac{d^2x}{dt^2} \\\\ F_{x} = -b \\frac{dx}{dt} \\end{cases} \\implies m \\frac{d^2x}{dt^2} = -b \\frac{dx}{dt} \\] Eliminating mass \\(m\\) from the left gives: \\[ \\boxed{\\frac{d^2x}{dt^2} = -\\frac{b}{m} \\frac{dx}{dt}} \\] To solve this, first separate variables (given that acceleration is the first derivative of velocity): \\[ \\frac{dv_{x}}{dt} = -\\frac{b}{m} v_{x} \\implies \\frac{1}{v_{x}} \\frac{dv_{x}}{dt} = -\\frac{b}{m} \\] Integrating both parts over \\(dt\\) : \\[ \\int{\\frac{1}{v_{x}} \\frac{dv_{x}}{dt} dt} = \\int-\\frac{b}{m} dt \\] Implies: \\[ \\int{\\frac{1}{v_{x}} dv_{x}} = -\\frac{b}{m} \\int dt \\] Integration gives: \\[ \\ln | v_{x} | = -\\frac{b}{m} t + C_{3} \\] Therefore, \\[ v_{x}(t) = v_{0}\\cos(\\theta)e^{-b/m}t \\] Integrating again to get \\(x(t)\\) : \\[ x(t) = \\frac{mv_{0}\\cos(\\theta)}{b}(1-e^{-\\frac{b}{m}t}) + C_{4} \\] If \\(x(0) =0\\) , we find \\(C_{4}=0\\) . Vertical motion with air resistance ( \\(y\\) -direction) The total force acting on the projectile on the \\(x\\) -axis, given air resistance, is as follows: \\[ F_{y} = -mg - bv_{y} \\] where \\(b\\) is the drag coefficient. Given that \\(F_{y} = ma_{y}\\) , \\(a_{y} = \\frac{d^2y}{dy^2}\\) , and \\(v_{y} = \\frac{dy}{dt}\\) : \\[ m \\frac{d^2y}{dy^2} = -mg - b \\frac{dy}{dt} \\] Eliminating mass gives: \\[ \\boxed{\\frac{d^2y}{dy^2} = -g - \\frac{b}{m} \\frac{dy}{dt}} \\] Reorganizing items and substituting \\(v_y\\) , his can be rewritten as \\[ \\frac{dv_{y}}{dt} + \\frac{b}{m}v_{y} = -g \\] This is again a first-order linear differential equation, with solution:b \\[ v_{y}(t) = \\left( v_{0}\\sin(\\theta) + \\frac{mg}{b} \\right)e^{ - \\frac{b}{m}t} - \\frac{mg}{b} \\] Integrating gives: \\[ y(t) = -\\frac{m}{b}\\left( v_{0}\\sin(\\theta) + \\frac{mg}{b}\\right)e^{-\\frac{b}{m}t } + \\frac{mg}{b}t + C_{5} \\] With \\(y(0) =0\\) : set \\(C_{5} = 0\\) . Demonstration import numpy as np import matplotlib.pyplot as plt def projectile_motion_no_drag(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile without air resistance.\"\"\" angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def projectile_motion_with_drag(v0, angle, b, g=9.81, dt=0.01): \"\"\"Calculate the trajectory of a projectile with air resistance.\"\"\" angle_rad = np.radians(angle) # Initial velocities v_x = v0 * np.cos(angle_rad) v_y = v0 * np.sin(angle_rad) # Initialize lists to store positions and time t_values = [0] x_values = [0] y_values = [0] x, y = 0, 0 # Initial position t = 0 # Initial time while y >= 0: # Continue until the projectile hits the ground # Update positions x += v_x * dt y += v_y * dt # Update velocities with drag force v_x -= (b * v_x / np.sqrt(v_x**2 + v_y**2)) * dt # Drag force v_y -= (g + (b * v_y / np.sqrt(v_x**2 + v_y**2))) * dt # Gravitational force + Drag # Record values t += dt t_values.append(t) x_values.append(x) y_values.append(y) return x_values, y_values # Parameters initial_velocity = 30 # m/s drag_coefficient = 0.1 # Drag coefficient angle = 45 # Launch angle (degrees) # Calculate projectile motion trajectories x_no_drag, y_no_drag = projectile_motion_no_drag(initial_velocity, angle) x_with_drag, y_with_drag = projectile_motion_with_drag(initial_velocity, angle, drag_coefficient) # Setting up the plot plt.figure(figsize=(10, 6)) plt.plot(x_no_drag, y_no_drag, label='No Air Resistance', color='blue') drags = [0.5, 1.0, 1.5, 2.0] colors = ['darkred', 'red', 'darkorange', 'orange'] # Loop through drag coefficients and colors simultaneously for drag, c in zip(drags, colors): x_with_drag, y_with_drag = projectile_motion_with_drag(initial_velocity, angle, drag) plt.plot(x_with_drag, y_with_drag, label=f'Air Resistance: {drag}', color=c, linestyle='--') # Customize the plot plt.title('Projectile Trajectories: With Varying Air Resistance vs Without Air Resistance') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-basic-formulas-of-the-projectile-motion","text":"Suppose a projectile is launched at an angle \\(\\theta\\) above the horizontal with an initial velocity \\(v_{0}\\) . For this section, assume no air resistance .","title":"Deriving basic formulas of the projectile motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion-x-direction","text":"In the absence of air resistance, there is no horizontal force acting on the projectile: \\[ F_{x} = 0 \\] Based on the Second Newton's Law of Motion: \\[ \\vec{F} = m\\vec{a} \\] Therefore, \\[ m a_{x} = 0 \\implies \\frac{d^2x}{dt^2}m=0 \\] Since the projectile does not accelerate on the \\(x\\) -axis, its immediate velocity (the first derivative of path) equals to the initial velocity with which the projectile has been launched in the first place: \\[ \\frac{dx}{dt} = v_{0x} \\] The \\(x\\) -component of the initial velocity is \\[ v_{0x} = v_{0}\\cos(\\theta) \\] Therefore, the equation of motion of the projectile on the \\(x\\) -axis can be described with the following equation: $$ \\boxed{\\frac{dt}{dx} = v_{0}\\cos(\\theta)} $$ Where \\(\\theta\\) is the launch angle of the projectile. To find the \\(x\\) -component of the position of the projectile at time \\(t\\) , we need to solve this equation for \\(x\\) . Solving the above differential equation will give us the following: \\[ x(t) = v_{0}\\cos(\\theta)t + C_{1} \\] To find \\(C_{1}\\) , set the initial condition \\(x(0) = 0\\) (the path at time \\(0\\) is, of course, \\(0\\) ), and therefore \\[ C_{1} = 0 \\] Thus, \\[ \\boxed{x(t) = v_{0}\\cos(\\theta)t} \\] This equation will give us the position of the projectile at the time \\(t\\) .","title":"Horizontal motion (\\(x\\)-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion-y-direction","text":"The only force acting vertically is the force of gravity : \\[ F_{y}=-mg \\] The projectile doesn't experience any other acceleration and moves until it hits the ground due to gravity. Therefore, the \\(y\\) -component of the projectile motion can be described with the following equation: \\[ \\boxed{\\frac{dy}{dt} = v_{0}\\sin(\\theta)-gt} \\] Where \\(v_{0}\\sin(\\theta)\\) is the \\(y\\) -component of the initial velocity of the projectile, and \\(g\\) is the acceleration due to gravity (i.e., \\(\\frac{d^2y}{dt^2} = -g\\) ). This gives us \\[ \\boxed{y(t)=v_{0}\\sin(\\theta)t -\\frac{1}{2}gt^2} \\]","title":"Vertical motion (\\(y\\)-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#when-the-projectile-hits-the-ground","text":"To find when the projectile hits the ground, we set \\(y(t)=0\\) (altitude zero): \\[ 0=v_{0}\\sin(\\theta)t -\\frac{1}{2}gt^2 \\] Rearranging items gives us: \\[ -\\frac{1}{2}gt^2 + v_{0}\\sin(\\theta) = 0 \\] Solving the quadratic equation: \\(D=(v_{0}\\sin(\\theta))^2\\) \\(t_{1} = \\frac{-v_{0}\\sin(\\theta)+v_{0}\\sin(\\theta)}{-1g} = \\frac{0}{-g} =0\\) - when the projectile is launched; \\(t_{2}=\\frac{-v_{0}\\sin(\\theta)-v_{0}\\sin(\\theta)}{-g}=\\frac{2v_{0}\\sin(\\theta)}{g}\\) So that, the total flight time of a projectile launched with the velocity \\(v_{0}\\) at the angle \\(\\theta\\) : \\[ \\boxed{t_{f}=\\frac{2v_{0}\\sin(\\theta)}{g}} \\]","title":"When the projectile hits the ground"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#the-horizontal-range","text":"The range that the projectile passes, i.e., the horizontal distance traveled when \\(t=t_{f}\\) , can be found by the formula: \\[R=v_{0x}(t_{f})=v_{0}\\cos(\\theta)\\frac{2v_{0}\\sin(\\theta)}{g}=\\frac{2v_{0}^2 \\left( \\frac{1}{2} \\sin(2\\theta)\\right) }{g}=\\frac{v_{0}^2\\sin(2\\theta) }{g}\\] \\[\\boxed{R=\\frac{v_{0}^2\\sin(2\\theta) }{g}}\\]","title":"The horizontal range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-how-angle-and-the-initial-velocity-influence-the-range-of-the-projectile-motion","text":"","title":"Investigating how angle and the initial velocity influence the range of the projectile motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#varying-angles","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile.\"\"\" # Convert angle to radians angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Parameters initial_velocity = 30 # m/s angles = [15, 30, 45, 60, 75] # Selected launch angles (degrees) # Setting up the plot plt.figure(figsize=(10, 6)) # Loop through each angle to plot the trajectory for angle in angles: x, y = projectile_motion(initial_velocity, angle) plt.plot(x, y, label=f'\u03b8 = {angle}\u00b0') # Customize the plot plt.title('Projectile Trajectories for Different Launch Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show() The general form of the range as a function of \\(\\theta\\) . It demonstrates how varying the launch angle affects the distance traveled. Different values of \\(v_0\\) affect the range as well. As a result, we get a family of parabolic curves when graphed. The range \\(R\\) depends on the angle of projection \\(\\theta\\) through the sine function, which reaches its maximum at \\(90^\\circ\\) . However, due to the sinusoidal nature of the \\(\\sin\u2061(2\\theta)\\) , the optimal launch angle for maximum horizontal range is \\(45^\\circ\\) .","title":"Varying angles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#varying-initial-velocity","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile.\"\"\" # Convert angle to radians angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Parameters angle = 45 initial_velocities = [10, 20, 30, 40, 50] # m/s # Setting up the plot plt.figure(figsize=(10, 6)) # Loop velocities each angle to plot the trajectory for initial_velocity in initial_velocities: x, y = projectile_motion(initial_velocity, angle) plt.plot(x, y, label=f'v0 = {initial_velocity}') # Customize the plot plt.title('Projectile Trajectories for Different Launch Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show()","title":"Varying initial velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#taking-altitude-into-account","text":"Given everything discussed above, let's add another parameter into the equation: altitude. Suppose a projectile is launched from a height \\(h_{0}\\) above the ground. The equation of the vertical component of the motion then changes: \\[ y(t)=h_{0}+v_{0}\\sin (\\theta) t - \\frac{1}{2}gt^2 \\] To find the time of flight with this parameter added, we need to solve the above equation at \\(0\\) : \\[ 0=h_{0}+v_{0}\\sin (\\theta) t - \\frac{1}{2}gt^2 \\] Launch time: \\[ t_{1}=\\frac{v_{0}\\sin(\\theta)+\\sqrt{ v_{0}^2\\sin(\\theta)^2 +2gh_{0} }}{g} \\] When the projectile hits the ground: \\[ t_{2}=\\frac{v_{0}\\sin(\\theta)-\\sqrt{ v_{0}^2\\sin(\\theta)^2 +2gh_{0} }}{g} \\] The horizontal range is then: \\[ R=v_{0}t_{2} \\]","title":"Taking altitude into account"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#demonstration","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion_with_altitude(v0, angle, h0, g=9.81, dt=0.01): \"\"\"Calculate the trajectory of a projectile launched from an altitude.\"\"\" angle_rad = np.radians(angle) # Initial velocities v_x = v0 * np.cos(angle_rad) v_y = v0 * np.sin(angle_rad) # Initialize lists to store positions and time t_values = [0] x_values = [0] y_values = [h0] # Start from initial height x, y = 0, h0 # Initial position at the height h0 t = 0 # Initial time while y >= 0: # Continue until the projectile hits the ground (y < 0) # Update positions x += v_x * dt y += v_y * dt # Update velocities due to gravity v_y -= g * dt # Only vertical component affected by gravity # Record values t += dt t_values.append(t) x_values.append(x) y_values.append(y) return x_values, y_values # Parameters initial_velocity = 30 # m/s angle = 45 # Launch angle (degrees) altitudes = [-5, 0, 10, 20] # Different launch heights (above or below ground level) # Setting up the plot plt.figure(figsize=(10, 6)) # Loop through different altitudes for h0 in altitudes: x_with_altitude, y_with_altitude = projectile_motion_with_altitude(initial_velocity, angle, h0) plt.plot(x_with_altitude, y_with_altitude, label=f'Initial Height: {h0} m') # Customize the plot plt.title('Projectile Trajectories at Varying Initial Altitudes') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(-10, 150) # X-axis limit plt.ylim(0, 60) # Y-axis limit, accommodating negative heights plt.grid() plt.legend() plt.show()","title":"Demonstration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#exploring-how-launch-altitude-influences-the-horizontal-range","text":"","title":"Exploring how launch altitude influences the horizontal range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#taking-into-account-air-resistance","text":"Let's face it: the above model is not realistic unless you live on a planed with zero-density air (actually, you have no chances to survive there). This section aims to derive equations that do take air resistance into account. The simplest model considers a drag force proportional to the velocity ( the faster the projectile moves, the stronger the air resistance ), i.e., linear drag .","title":"Taking into account air resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion-with-air-resistance-x-direction","text":"The total force acting on the projectile on the \\(x\\) -axis, given air resistance, is as follows: \\[ F_{x} = ma_{x} = -bv_{x} \\] where \\(b\\) is the drag coefficient. Given \\(v_{x} = \\frac{dx}{dt}\\) , and \\(a_{x} = \\frac{d^2x}{dt^2}\\) , we derive: \\[ \\begin{cases} F_{x} = m \\frac{d^2x}{dt^2} \\\\ F_{x} = -b \\frac{dx}{dt} \\end{cases} \\implies m \\frac{d^2x}{dt^2} = -b \\frac{dx}{dt} \\] Eliminating mass \\(m\\) from the left gives: \\[ \\boxed{\\frac{d^2x}{dt^2} = -\\frac{b}{m} \\frac{dx}{dt}} \\] To solve this, first separate variables (given that acceleration is the first derivative of velocity): \\[ \\frac{dv_{x}}{dt} = -\\frac{b}{m} v_{x} \\implies \\frac{1}{v_{x}} \\frac{dv_{x}}{dt} = -\\frac{b}{m} \\] Integrating both parts over \\(dt\\) : \\[ \\int{\\frac{1}{v_{x}} \\frac{dv_{x}}{dt} dt} = \\int-\\frac{b}{m} dt \\] Implies: \\[ \\int{\\frac{1}{v_{x}} dv_{x}} = -\\frac{b}{m} \\int dt \\] Integration gives: \\[ \\ln | v_{x} | = -\\frac{b}{m} t + C_{3} \\] Therefore, \\[ v_{x}(t) = v_{0}\\cos(\\theta)e^{-b/m}t \\] Integrating again to get \\(x(t)\\) : \\[ x(t) = \\frac{mv_{0}\\cos(\\theta)}{b}(1-e^{-\\frac{b}{m}t}) + C_{4} \\] If \\(x(0) =0\\) , we find \\(C_{4}=0\\) .","title":"Horizontal motion with air resistance (\\(x\\)-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion-with-air-resistance-y-direction","text":"The total force acting on the projectile on the \\(x\\) -axis, given air resistance, is as follows: \\[ F_{y} = -mg - bv_{y} \\] where \\(b\\) is the drag coefficient. Given that \\(F_{y} = ma_{y}\\) , \\(a_{y} = \\frac{d^2y}{dy^2}\\) , and \\(v_{y} = \\frac{dy}{dt}\\) : \\[ m \\frac{d^2y}{dy^2} = -mg - b \\frac{dy}{dt} \\] Eliminating mass gives: \\[ \\boxed{\\frac{d^2y}{dy^2} = -g - \\frac{b}{m} \\frac{dy}{dt}} \\] Reorganizing items and substituting \\(v_y\\) , his can be rewritten as \\[ \\frac{dv_{y}}{dt} + \\frac{b}{m}v_{y} = -g \\] This is again a first-order linear differential equation, with solution:b \\[ v_{y}(t) = \\left( v_{0}\\sin(\\theta) + \\frac{mg}{b} \\right)e^{ - \\frac{b}{m}t} - \\frac{mg}{b} \\] Integrating gives: \\[ y(t) = -\\frac{m}{b}\\left( v_{0}\\sin(\\theta) + \\frac{mg}{b}\\right)e^{-\\frac{b}{m}t } + \\frac{mg}{b}t + C_{5} \\] With \\(y(0) =0\\) : set \\(C_{5} = 0\\) .","title":"Vertical motion with air resistance (\\(y\\)-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#demonstration_1","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion_no_drag(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile without air resistance.\"\"\" angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def projectile_motion_with_drag(v0, angle, b, g=9.81, dt=0.01): \"\"\"Calculate the trajectory of a projectile with air resistance.\"\"\" angle_rad = np.radians(angle) # Initial velocities v_x = v0 * np.cos(angle_rad) v_y = v0 * np.sin(angle_rad) # Initialize lists to store positions and time t_values = [0] x_values = [0] y_values = [0] x, y = 0, 0 # Initial position t = 0 # Initial time while y >= 0: # Continue until the projectile hits the ground # Update positions x += v_x * dt y += v_y * dt # Update velocities with drag force v_x -= (b * v_x / np.sqrt(v_x**2 + v_y**2)) * dt # Drag force v_y -= (g + (b * v_y / np.sqrt(v_x**2 + v_y**2))) * dt # Gravitational force + Drag # Record values t += dt t_values.append(t) x_values.append(x) y_values.append(y) return x_values, y_values # Parameters initial_velocity = 30 # m/s drag_coefficient = 0.1 # Drag coefficient angle = 45 # Launch angle (degrees) # Calculate projectile motion trajectories x_no_drag, y_no_drag = projectile_motion_no_drag(initial_velocity, angle) x_with_drag, y_with_drag = projectile_motion_with_drag(initial_velocity, angle, drag_coefficient) # Setting up the plot plt.figure(figsize=(10, 6)) plt.plot(x_no_drag, y_no_drag, label='No Air Resistance', color='blue') drags = [0.5, 1.0, 1.5, 2.0] colors = ['darkred', 'red', 'darkorange', 'orange'] # Loop through drag coefficients and colors simultaneously for drag, c in zip(drags, colors): x_with_drag, y_with_drag = projectile_motion_with_drag(initial_velocity, angle, drag) plt.plot(x_with_drag, y_with_drag, label=f'Air Resistance: {drag}', color=c, linestyle='--') # Customize the plot plt.title('Projectile Trajectories: With Varying Air Resistance vs Without Air Resistance') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show()","title":"Demonstration"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Pendulum motion: small angles The motion of a forced damped pendulum is described by the following second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L}\\sin \\theta = A \\cos(wt) \\] This is a second-order differential equation governing the angular displacement \\(\\theta\\) of a pendulum with damping and driven forces. Here: Notation Description \\(\\theta\\) Angular displacement from the vertical ( equilibrium ) position; measured in radians. \\(\\frac{d^2\\theta}{dt^2}\\) Angular acceleration of the pendulum. \\(b\\) Damping coefficient (which accounts for friction or air resistance). \\(\\frac{d\\theta}{dt}\\) Angular velocity of the pendulum (the rate of change of the angle \\(\\theta\\) ) \\(g\\) Acceleration due to gravity. \\(L\\) The length of the pendulum. \\(A\\cos(\\omega t)\\) Represents the external driving force; \\(A\\) is the amplitude, and \\(\\omega\\) is the angular frequency of the external forcing. For small angles ( \\(\\theta\\) approaching to \\(0\\) or \\(\\theta \\approx 0\\) ), we can use the approximation \\(\\sin(\\theta) \\approx \\theta\\) . With this, the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L}\\sin \\theta = A \\cos(wt) \\implies \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(wt) \\] Solving differential equation of a damped pendulum for small-angle approximations To solve the equation, we first consider the homogeneous part (setting the driving force to zero): \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] This is a standard form for a damped harmonic oscillator. To solve this linear differential equation, we assume a solution of the form: \\[ \\theta(t) = e^{rt} \\] Here, \\(r\\) is the constant we want to determine. The first derivative of our assumed solution is \\(\\frac{d\\theta}{dt} = re^{rt}\\) . The second is \\(\\frac{d^2\\theta}{dt^2} = r^2e^{rt}\\) . Substituting, gives \\[ r^2e^{rt} + b(re^{rt}) + \\frac{g}{L}(e^{rt}) = 0 \\] Factoring out \\(e^{rt}\\) : \\[ e^{rt}(r^2 + br + \\frac{g}{L}) = 0 \\] The term \\(e^{rt}\\) does not contribute any solutions since it is always positive for real values of \\(r\\) . Therefore, we obtain our characteristic equation from the remaining polynomial: \\[ r^2+br+\\frac{g}{L} =0 \\] To find \\(r\\) , we need to solve the above equation: \\[ r = \\frac{-b\\pm \\sqrt{ b^2 -4\\frac{g}{L} }}{2} \\] Where \\(D= b^2 -4\\frac{g}{L}\\) . Roots and behavior: Underdamped Condition: \\(D > 0 \\implies b^2 \\gt 4 \\frac{g}{L}\\) Result: Two distinct real roots, leading to oscillatory motion with gradually decreasing amplitude (oscillations). Physically, this means the pendulum swings back and forth across the vertical position, with the amplitude decreasing over time due to damping. The oscillations gradually lose energy (due to friction or air resistance), resulting in a motion that resembles a sine wave, but one that progressively decays. This is the pendulum we usually think about, i.e., a swinging pendulum that slowly stops swinging as it loses energy. Critically damped Condition: \\(D = 0 \\implies b^2 = 4 \\frac{g}{L}\\) Result: Two identical real roots, leading to the system returning to equilibrium as quickly as possible without oscillating. In this case, the pendulum will move towards its lowest point but won't overshoot or undergo any oscillation. It smoothly comes to rest at the vertical position. Take a door as an example: its damping mechanism shuts the door quickly without bouncing back. Overdamped Condition: \\(D < 0 \\implies b^2 < 4 \\frac{g}{L}\\) Result: Two complex conjugate roots, leading to a non-oscillatory return toward equilibrium. The system takes longer to return than in the critically damped case. Here, the pendulum slowly returns to its resting position without any oscillations, typically taking a longer time to settle compared to the critically damped case. For example, a pendulum that is heavily damped (like a long jump rope acting as a pendulum) that gently settles down without swinging back and forth. No damping Below there is a diagram comparing three cases: underdamped pendulum motion, motion with no damping, and critically damped motion: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # 1. Underdamped case parameters (b > 0, b^2 < 4g/L) b_underdamped = 1.0 # Damping Coefficient (low but positive) omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * np.cos(omega_d_underdamped * t) # 2. No Damping case parameters (b = 0) b_no_damping = 0.0 # No Damping omega_no_damping = np.sqrt(g / L) theta_no_damping = np.cos(omega_no_damping * t) # Simple harmonic motion # 3. Critically Damped case parameters (b^2 = 4g/L) b_critical = 2.0 * np.sqrt(g / L) # Adjusted for critical damping theta_critical = (1 + b_critical*t) * np.exp(-b_critical / 2 * t) # Critically damped response # Create plots plt.figure(figsize=(12, 10)) # Underdamped Motion Plot plt.subplot(3, 2, 1) plt.plot(t, theta_underdamped, label='Underdamped', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Underdamped Phase Diagram plt.subplot(3, 2, 2) plt.plot(theta_underdamped[:-1], np.diff(theta_underdamped) / np.diff(t), color='blue') plt.title('Underdamped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # No Damping Motion Plot plt.subplot(3, 2, 3) plt.plot(t, theta_no_damping, label='No Damping', color='green') plt.title('Pendulum Motion with No Damping') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # No Damping Phase Diagram plt.subplot(3, 2, 4) plt.plot(theta_no_damping[:-1], np.diff(theta_no_damping) / np.diff(t), color='green') plt.title('No Damping Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Critically Damped Motion Plot plt.subplot(3, 2, 5) plt.plot(t, theta_critical, label='Critically Damped', color='orange') plt.title('Critically Damped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Critically Damped Phase Diagram plt.subplot(3, 2, 6) plt.plot(theta_critical[:-1], np.diff(theta_critical) / np.diff(t), color='orange') plt.title('Critically Damped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Adjust layout plt.tight_layout() plt.show() Underdamped, Critically Damped, and Overdamped The next diagram compares three cases: underdamped, critically damped, and overdamped motion: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # Underdamped case parameters (b^2 > 4g/L) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * np.cos(omega_d_underdamped * t) # Critically damped case parameters (b^2 = 4g/L) b_critically_damped = 2 * np.sqrt(g / L) theta_critically_damped = np.exp(-b_critically_damped / 2 * t) * (1 + (b_critically_damped / 2) * t) # Overdamped case parameters (b^2 < 4g/L) b_overdamped = 3.0 # Choose a value greater than 2*sqrt(g/L) omega_0_overdamped = np.sqrt((b_overdamped / 2) ** 2 - g / L) theta_overdamped = np.exp(-b_overdamped / 2 * t) * (np.cosh(omega_0_overdamped * t) - (b_overdamped / (2 * omega_0_overdamped)) * np.sinh(omega_0_overdamped * t)) # Calculate angular velocities for the phase diagrams omega_underdamped = -b_underdamped / 2 * theta_underdamped - (g / L) * np.sin(theta_underdamped) omega_critically_damped = np.diff(theta_critically_damped) / np.diff(t) # Numerical derivative omega_critically_damped = np.append(omega_critically_damped, omega_critically_damped[-1]) # Append last value for length compatibility omega_overdamped = -b_overdamped / 2 * theta_overdamped + omega_0_overdamped * np.cosh(omega_0_overdamped * t) # Plotting plt.figure(figsize=(12, 12)) # Underdamped plt.subplot(3, 2, 1) plt.plot(t, theta_underdamped, label='Underdamped', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Underdamped Phase Diagram plt.subplot(3, 2, 2) plt.plot(theta_underdamped[:-1], omega_underdamped[:-1], color='blue') plt.title('Underdamped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Critically Damped plt.subplot(3, 2, 3) plt.plot(t, theta_critically_damped, label='Critically Damped', color='orange') plt.title('Critically Damped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Critically Damped Phase Diagram plt.subplot(3, 2, 4) plt.plot(theta_critically_damped[:-1], omega_critically_damped[:-1], color='orange') plt.title('Critically Damped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Overdamped plt.subplot(3, 2, 5) plt.plot(t, theta_overdamped, label='Overdamped', color='green') plt.title('Overdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Overdamped Phase Diagram plt.subplot(3, 2, 6) plt.plot(theta_overdamped[:-1], omega_overdamped[:-1], color='green') plt.title('Overdamped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Adjust layout plt.tight_layout() plt.show() Exploring initial conditions of an underdamped pendulum You can also use this website to see demonstrations. These are not mine, but I think the resource is useful. Changing damping coefficient import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # Plotting plt.figure(figsize=(12, 8)) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='Underdamped: b = 1', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() b_underdamped = 2.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) plt.subplot(3, 1, 2) plt.plot(t, theta_underdamped, label='Underdamped: b = 2', color='violet') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() b_underdamped = 3.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_underdamped, label='Underdamped: b = 3', color='red') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show() We see that, as we increase the damping coefficient, underdamped motion approaches to critically damped. Here is another thing. If we continue to increase the damping coefficient, at some point, the graph will disappear (overdamped). The red line below shows the maximum damping I could obtain by increasing the damping coefficient before the graph disappears: Changing pendulum length import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) # Time array t = np.linspace(0, 10, 500) # Plotting plt.figure(figsize=(12, 8)) L = 1.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='L = 1', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() L = 2.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) plt.subplot(3, 1, 2) plt.plot(t, theta_underdamped, label='L = 2', color='violet') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() L = 3.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_underdamped, label='L = 3', color='red') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show() Investigating forced pendulum import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) A_resonance = 1.0 # amplitude of the driving force for resonance A_chaotic = 0.5 # reduced amplitude for chaotic case b = 0.1 # damping coefficient # Natural frequency omega_0 = np.sqrt(g / L) # Time values t = np.linspace(0, 30, 1000) # Time from 0 to 30 seconds # Differential equations for the driven pendulum def model(y, t, A, b, omega): theta, omega = y dtheta_dt = omega domega_dt = -b * omega - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Case 1: Resonance omega_resonance = omega_0 # Driving frequency at resonance initial_conditions = [0.1, 0] # Starting angle and angular velocity solution_resonance = odeint(model, initial_conditions, t, args=(A_resonance, b, omega_resonance)) theta_resonance = solution_resonance[:, 0] omega_resonance_vals = solution_resonance[:, 1] # Case 2: Chaotic Motion omega_chaotic = 1.5 * omega_0 # Non-harmonic driving frequency initial_conditions = [0.1, 0] # Same starting angle and velocity for comparison solution_chaotic = odeint(model, initial_conditions, t, args=(A_chaotic, b, omega_chaotic)) theta_chaotic = solution_chaotic[:, 0] omega_chaotic_vals = solution_chaotic[:, 1] # Plotting fig, ax = plt.subplots(2, 2, figsize=(12, 8)) # Resonance plot ax[0, 0].plot(t, theta_resonance, color='blue') ax[0, 0].set_title('Resonance Case') ax[0, 0].set_xlabel('Time (s)') ax[0, 0].set_ylabel('Angular Displacement (radians)') ax[0, 0].grid() # Chaos plot ax[0, 1].plot(t, theta_chaotic, color='red') ax[0, 1].set_title('Chaotic Case') ax[0, 1].set_xlabel('Time (s)') ax[0, 1].set_ylabel('Angular Displacement (radians)') ax[0, 1].grid() # Phase Diagrams # Resonance Phase Diagram ax[1, 0].plot(theta_resonance[:-1], omega_resonance_vals[:-1], color='blue') ax[1, 0].set_title('Resonance Phase Diagram') ax[1, 0].set_xlabel('Angular Position (radians)') ax[1, 0].set_ylabel('Angular Velocity (rad/s)') ax[1, 0].grid() # Chaos Phase Diagram ax[1, 1].plot(theta_chaotic[:-1], omega_chaotic_vals[:-1], color='red') ax[1, 1].set_title('Chaotic Phase Diagram') ax[1, 1].set_xlabel('Angular Position (radians)') ax[1, 1].set_ylabel('Angular Velocity (rad/s)') ax[1, 1].grid() plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#pendulum-motion-small-angles","text":"The motion of a forced damped pendulum is described by the following second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L}\\sin \\theta = A \\cos(wt) \\] This is a second-order differential equation governing the angular displacement \\(\\theta\\) of a pendulum with damping and driven forces. Here: Notation Description \\(\\theta\\) Angular displacement from the vertical ( equilibrium ) position; measured in radians. \\(\\frac{d^2\\theta}{dt^2}\\) Angular acceleration of the pendulum. \\(b\\) Damping coefficient (which accounts for friction or air resistance). \\(\\frac{d\\theta}{dt}\\) Angular velocity of the pendulum (the rate of change of the angle \\(\\theta\\) ) \\(g\\) Acceleration due to gravity. \\(L\\) The length of the pendulum. \\(A\\cos(\\omega t)\\) Represents the external driving force; \\(A\\) is the amplitude, and \\(\\omega\\) is the angular frequency of the external forcing. For small angles ( \\(\\theta\\) approaching to \\(0\\) or \\(\\theta \\approx 0\\) ), we can use the approximation \\(\\sin(\\theta) \\approx \\theta\\) . With this, the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L}\\sin \\theta = A \\cos(wt) \\implies \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(wt) \\]","title":"Pendulum motion: small angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solving-differential-equation-of-a-damped-pendulum-for-small-angle-approximations","text":"To solve the equation, we first consider the homogeneous part (setting the driving force to zero): \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] This is a standard form for a damped harmonic oscillator. To solve this linear differential equation, we assume a solution of the form: \\[ \\theta(t) = e^{rt} \\] Here, \\(r\\) is the constant we want to determine. The first derivative of our assumed solution is \\(\\frac{d\\theta}{dt} = re^{rt}\\) . The second is \\(\\frac{d^2\\theta}{dt^2} = r^2e^{rt}\\) . Substituting, gives \\[ r^2e^{rt} + b(re^{rt}) + \\frac{g}{L}(e^{rt}) = 0 \\] Factoring out \\(e^{rt}\\) : \\[ e^{rt}(r^2 + br + \\frac{g}{L}) = 0 \\] The term \\(e^{rt}\\) does not contribute any solutions since it is always positive for real values of \\(r\\) . Therefore, we obtain our characteristic equation from the remaining polynomial: \\[ r^2+br+\\frac{g}{L} =0 \\] To find \\(r\\) , we need to solve the above equation: \\[ r = \\frac{-b\\pm \\sqrt{ b^2 -4\\frac{g}{L} }}{2} \\] Where \\(D= b^2 -4\\frac{g}{L}\\) . Roots and behavior: Underdamped Condition: \\(D > 0 \\implies b^2 \\gt 4 \\frac{g}{L}\\) Result: Two distinct real roots, leading to oscillatory motion with gradually decreasing amplitude (oscillations). Physically, this means the pendulum swings back and forth across the vertical position, with the amplitude decreasing over time due to damping. The oscillations gradually lose energy (due to friction or air resistance), resulting in a motion that resembles a sine wave, but one that progressively decays. This is the pendulum we usually think about, i.e., a swinging pendulum that slowly stops swinging as it loses energy. Critically damped Condition: \\(D = 0 \\implies b^2 = 4 \\frac{g}{L}\\) Result: Two identical real roots, leading to the system returning to equilibrium as quickly as possible without oscillating. In this case, the pendulum will move towards its lowest point but won't overshoot or undergo any oscillation. It smoothly comes to rest at the vertical position. Take a door as an example: its damping mechanism shuts the door quickly without bouncing back. Overdamped Condition: \\(D < 0 \\implies b^2 < 4 \\frac{g}{L}\\) Result: Two complex conjugate roots, leading to a non-oscillatory return toward equilibrium. The system takes longer to return than in the critically damped case. Here, the pendulum slowly returns to its resting position without any oscillations, typically taking a longer time to settle compared to the critically damped case. For example, a pendulum that is heavily damped (like a long jump rope acting as a pendulum) that gently settles down without swinging back and forth.","title":"Solving differential equation of a damped pendulum for small-angle approximations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#no-damping","text":"Below there is a diagram comparing three cases: underdamped pendulum motion, motion with no damping, and critically damped motion: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # 1. Underdamped case parameters (b > 0, b^2 < 4g/L) b_underdamped = 1.0 # Damping Coefficient (low but positive) omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * np.cos(omega_d_underdamped * t) # 2. No Damping case parameters (b = 0) b_no_damping = 0.0 # No Damping omega_no_damping = np.sqrt(g / L) theta_no_damping = np.cos(omega_no_damping * t) # Simple harmonic motion # 3. Critically Damped case parameters (b^2 = 4g/L) b_critical = 2.0 * np.sqrt(g / L) # Adjusted for critical damping theta_critical = (1 + b_critical*t) * np.exp(-b_critical / 2 * t) # Critically damped response # Create plots plt.figure(figsize=(12, 10)) # Underdamped Motion Plot plt.subplot(3, 2, 1) plt.plot(t, theta_underdamped, label='Underdamped', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Underdamped Phase Diagram plt.subplot(3, 2, 2) plt.plot(theta_underdamped[:-1], np.diff(theta_underdamped) / np.diff(t), color='blue') plt.title('Underdamped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # No Damping Motion Plot plt.subplot(3, 2, 3) plt.plot(t, theta_no_damping, label='No Damping', color='green') plt.title('Pendulum Motion with No Damping') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # No Damping Phase Diagram plt.subplot(3, 2, 4) plt.plot(theta_no_damping[:-1], np.diff(theta_no_damping) / np.diff(t), color='green') plt.title('No Damping Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Critically Damped Motion Plot plt.subplot(3, 2, 5) plt.plot(t, theta_critical, label='Critically Damped', color='orange') plt.title('Critically Damped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Critically Damped Phase Diagram plt.subplot(3, 2, 6) plt.plot(theta_critical[:-1], np.diff(theta_critical) / np.diff(t), color='orange') plt.title('Critically Damped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Adjust layout plt.tight_layout() plt.show()","title":"No damping"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#underdamped-critically-damped-and-overdamped","text":"The next diagram compares three cases: underdamped, critically damped, and overdamped motion: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # Underdamped case parameters (b^2 > 4g/L) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * np.cos(omega_d_underdamped * t) # Critically damped case parameters (b^2 = 4g/L) b_critically_damped = 2 * np.sqrt(g / L) theta_critically_damped = np.exp(-b_critically_damped / 2 * t) * (1 + (b_critically_damped / 2) * t) # Overdamped case parameters (b^2 < 4g/L) b_overdamped = 3.0 # Choose a value greater than 2*sqrt(g/L) omega_0_overdamped = np.sqrt((b_overdamped / 2) ** 2 - g / L) theta_overdamped = np.exp(-b_overdamped / 2 * t) * (np.cosh(omega_0_overdamped * t) - (b_overdamped / (2 * omega_0_overdamped)) * np.sinh(omega_0_overdamped * t)) # Calculate angular velocities for the phase diagrams omega_underdamped = -b_underdamped / 2 * theta_underdamped - (g / L) * np.sin(theta_underdamped) omega_critically_damped = np.diff(theta_critically_damped) / np.diff(t) # Numerical derivative omega_critically_damped = np.append(omega_critically_damped, omega_critically_damped[-1]) # Append last value for length compatibility omega_overdamped = -b_overdamped / 2 * theta_overdamped + omega_0_overdamped * np.cosh(omega_0_overdamped * t) # Plotting plt.figure(figsize=(12, 12)) # Underdamped plt.subplot(3, 2, 1) plt.plot(t, theta_underdamped, label='Underdamped', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Underdamped Phase Diagram plt.subplot(3, 2, 2) plt.plot(theta_underdamped[:-1], omega_underdamped[:-1], color='blue') plt.title('Underdamped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Critically Damped plt.subplot(3, 2, 3) plt.plot(t, theta_critically_damped, label='Critically Damped', color='orange') plt.title('Critically Damped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Critically Damped Phase Diagram plt.subplot(3, 2, 4) plt.plot(theta_critically_damped[:-1], omega_critically_damped[:-1], color='orange') plt.title('Critically Damped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Overdamped plt.subplot(3, 2, 5) plt.plot(t, theta_overdamped, label='Overdamped', color='green') plt.title('Overdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Overdamped Phase Diagram plt.subplot(3, 2, 6) plt.plot(theta_overdamped[:-1], omega_overdamped[:-1], color='green') plt.title('Overdamped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Adjust layout plt.tight_layout() plt.show()","title":"Underdamped, Critically Damped, and Overdamped"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#exploring-initial-conditions-of-an-underdamped-pendulum","text":"You can also use this website to see demonstrations. These are not mine, but I think the resource is useful.","title":"Exploring initial conditions of an underdamped pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#changing-damping-coefficient","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # Plotting plt.figure(figsize=(12, 8)) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='Underdamped: b = 1', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() b_underdamped = 2.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) plt.subplot(3, 1, 2) plt.plot(t, theta_underdamped, label='Underdamped: b = 2', color='violet') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() b_underdamped = 3.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_underdamped, label='Underdamped: b = 3', color='red') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show() We see that, as we increase the damping coefficient, underdamped motion approaches to critically damped. Here is another thing. If we continue to increase the damping coefficient, at some point, the graph will disappear (overdamped). The red line below shows the maximum damping I could obtain by increasing the damping coefficient before the graph disappears:","title":"Changing damping coefficient"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#changing-pendulum-length","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) # Time array t = np.linspace(0, 10, 500) # Plotting plt.figure(figsize=(12, 8)) L = 1.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='L = 1', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() L = 2.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) plt.subplot(3, 1, 2) plt.plot(t, theta_underdamped, label='L = 2', color='violet') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() L = 3.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_underdamped, label='L = 3', color='red') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show()","title":"Changing pendulum length"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-forced-pendulum","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) A_resonance = 1.0 # amplitude of the driving force for resonance A_chaotic = 0.5 # reduced amplitude for chaotic case b = 0.1 # damping coefficient # Natural frequency omega_0 = np.sqrt(g / L) # Time values t = np.linspace(0, 30, 1000) # Time from 0 to 30 seconds # Differential equations for the driven pendulum def model(y, t, A, b, omega): theta, omega = y dtheta_dt = omega domega_dt = -b * omega - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Case 1: Resonance omega_resonance = omega_0 # Driving frequency at resonance initial_conditions = [0.1, 0] # Starting angle and angular velocity solution_resonance = odeint(model, initial_conditions, t, args=(A_resonance, b, omega_resonance)) theta_resonance = solution_resonance[:, 0] omega_resonance_vals = solution_resonance[:, 1] # Case 2: Chaotic Motion omega_chaotic = 1.5 * omega_0 # Non-harmonic driving frequency initial_conditions = [0.1, 0] # Same starting angle and velocity for comparison solution_chaotic = odeint(model, initial_conditions, t, args=(A_chaotic, b, omega_chaotic)) theta_chaotic = solution_chaotic[:, 0] omega_chaotic_vals = solution_chaotic[:, 1] # Plotting fig, ax = plt.subplots(2, 2, figsize=(12, 8)) # Resonance plot ax[0, 0].plot(t, theta_resonance, color='blue') ax[0, 0].set_title('Resonance Case') ax[0, 0].set_xlabel('Time (s)') ax[0, 0].set_ylabel('Angular Displacement (radians)') ax[0, 0].grid() # Chaos plot ax[0, 1].plot(t, theta_chaotic, color='red') ax[0, 1].set_title('Chaotic Case') ax[0, 1].set_xlabel('Time (s)') ax[0, 1].set_ylabel('Angular Displacement (radians)') ax[0, 1].grid() # Phase Diagrams # Resonance Phase Diagram ax[1, 0].plot(theta_resonance[:-1], omega_resonance_vals[:-1], color='blue') ax[1, 0].set_title('Resonance Phase Diagram') ax[1, 0].set_xlabel('Angular Position (radians)') ax[1, 0].set_ylabel('Angular Velocity (rad/s)') ax[1, 0].grid() # Chaos Phase Diagram ax[1, 1].plot(theta_chaotic[:-1], omega_chaotic_vals[:-1], color='red') ax[1, 1].set_title('Chaotic Phase Diagram') ax[1, 1].set_xlabel('Angular Position (radians)') ax[1, 1].set_ylabel('Angular Velocity (rad/s)') ax[1, 1].grid() plt.tight_layout() plt.show()","title":"Investigating forced pendulum"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius Kepler's Third Law The Kepler's Third Law states that the square of a planet's orbital period is proportional to the cube of the length of the semi-major axis of its orbit . Sounds convoluted. Let's recall some basic concepts from astrodynamics: The orbital period is the amount of time it takes an astronomical object (say, a planet) to complete an orbit (curved trajectory) around another object. Recall that the Kepler's First Law states that the orbit of a planet is an ellipse. So, the semi-major axis of an orbit is then the semi-major axis of the ellipse that this orbit represents. In numerical form, the Kepler's Third Law can be written as follows: \\[ \\boxed{T^2 = \\frac{4\\pi^2}{GM}r^3} \\] Let's derive this formula. Derivation Alright, let's start with the Newton's law of universal gravitation first. It takes the following form: \\[ F = G \\frac{mM}{r^2} \\] where: Notion Description \\(F\\) The force between two masses, \\(m\\) and \\(M\\) \\(G\\) The Newtonian constant of gravitation \\(m\\) The first mass \\(M\\) The second mass \\(r\\) The distance between the centers of the masses Derivation of the Newton's Law of gravitation can be found here . Thanks to the Kepler's first law, we know that the motion of one planet (this is how we will abbreviate \"astronomical object\") relative to its Sun is an ellipse. For now, we will start with circular motion; first, we will write the centripetal force - the force that makes a mass follow a curved mass - with the following formula: \\[ F_{c} = \\frac{mv^2}{r} \\] For circular motion, the gravitational force provides the centripetal force, so we can set these two expressions equal: \\[ \\frac{GMm}{r^2}=\\frac{mv^2}{r} \\implies \\frac{GM}{r}={v^2} \\] The orbital speed \\(v\\) can be related to the orbital period \\(T\\) (the time it takes to complete one full orbit) through the circumference of the orbit. The circumference \\(C\\) of a circular orbit is given by: \\[ C = 2\\pi r \\] The speed can be expressed in terms of period \\(T\\) : \\[ v = \\frac{C}{T} = \\frac{2\\pi r}{T} \\] So, returning back to \\(\\frac{GM}{r}={v^2}\\) and substituting, we get \\[ \\frac{GM}{r}={\\left( \\frac{2\\pi r}{T} \\right)^2} \\implies \\frac{GM}{r}={ \\frac{4\\pi^2 r^2}{T^2}} \\] Multiplying both sides by \\(r\\) : \\[ GM = \\frac{{4\\pi^2 r^3}}{T^2} \\] Finally, rearranging gives us the Kepler's Third Law: \\[ \\boxed{T^2 = \\frac{4\\pi^2}{GM}r^3} \\] This shows that the square of the orbital period \\(T^2\\) is proportional to the cube of the orbital radius \\(r^3\\) : \\[ T^2 \u221d r^3 \\] This formula applies not only for circular motion, but also for elliptic. In this case, \\(r\\) is the semi-major axis of the ellipse . Implications of Kepler's Third Law for Astronomy Calculating planetary masses Kepler's Third Law can be used to determine the mass of a celestial body if the orbital period and distance of its orbiting bodies are known. \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\implies M= \\frac{4\\pi^2r^3}{GT^2} \\] This is particularly valuable in binary star systems, where two stars orbit a common center of mass. By analyzing their orbital periods and distances, astronomers can calculate their masses, enhancing our understanding of stellar evolution and the fundamental properties of stars. Determining distances Kepler's Third Law can also be used to determine the relative distances of celestial bodies. For example, by knowing the orbital period of a planet and applying the law, astronomers can infer its distance from the Sun in units of the semi-major axis (in astronomical units, where 1 AU is the average distance from the Earth to the Sun). Understanding orbital dynamics The relationship encapsulated in Kepler's Third Law provides insights into the stability and behavior of orbits. It predicts how changing a planet's distance from the star affects its orbital period; for example, if a planet were to migrate inward, its orbital period would decrease, affecting climatic and environmental conditions on that planet. Real-World Examples The Moon's orbit around Earth The Moon orbits Earth with an average distance of about \\(384,400\\) km and a period of approximately \\(27.3\\) days. Using Kepler's Third Law, we can check the consistency of these values: Given data: Data Value Period \\(T\\) \\(\\approx 27.3\\) days \\(\\approx 2,359,200\\) seconds Radius \\(r\\) \\(\\approx 384,400\\) km Calculations: Data Value \\(T^2\\) \\(\\approx 5.57\\times10^{12}s^2\\) \\(r^3\\) \\(\\approx 5.67\\times10^{25}m^3\\) Using \\(G\\approx6.674 \\times 10^{-11}m^3kg^{-1}s^{-2}\\) , calculating the expected mass of Earth: \\[ M= \\frac{4\\pi^2r^3}{GT^2} \\approx \\frac{4\\pi^2\\cdot5.67\\times10^{25}}{6.674\\times 10^{-11}\\cdot 5.57 \\times 10^{12}} \\approx 5.97 \\times 10^{24}kg \\] This mass aligns closely with the known mass of Earth, demonstrating the reliability of Kepler's Third Law. Computational mode import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 mass_sun = 1.989e+30 # Mass of the Sun in kilograms mass_earth = 5.972e+24 # Mass of the Earth in kilograms mass_moon = 7.348e+22 # Mass of the Moon in kilograms # Orbital parameters distance_earth = 1.496e+11 # Distance from Sun to Earth in meters (1 AU) distance_moon = 3.844e+8 # Distance from Earth to Moon in meters T_earth = np.sqrt((4 * np.pi**2 * distance_earth**3) / (G * mass_sun)) # Orbital period of Earth T_moon = np.sqrt((4 * np.pi**2 * distance_moon**3) / (G * mass_earth)) # Orbital period of Moon # Simulation parameters num_frames = 180 # Number of frames for animation time = np.linspace(0, T_earth, num_frames) # Position calculations earth_x = distance_earth * np.cos(2 * np.pi * time / T_earth) earth_y = distance_earth * np.sin(2 * np.pi * time / T_earth) moon_x = earth_x + distance_moon * np.cos(2 * np.pi * time / T_moon) moon_y = earth_y + distance_moon * np.sin(2 * np.pi * time / T_moon) # Create figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-1.6e11, 1.6e11) ax.set_ylim(-1.6e11, 1.6e11) ax.set_aspect('equal') ax.set_title(\"Simulation of Circular Orbits\") ax.set_xlabel(\"Distance (m)\") ax.set_ylabel(\"Distance (m)\") # Initialize the Sun, Earth, and Moon sun, = ax.plot(0, 0, 'yo', markersize=12) # Sun in yellow earth, = ax.plot([], [], 'bo', markersize=6) # Earth in blue moon, = ax.plot([], [], 'gray', markersize=4) # Moon in gray # Animation update function def update(frame): # Update Earth position earth.set_data(earth_x[frame], earth_y[frame]) # Update Moon position moon.set_data(moon_x[frame], moon_y[frame]) return earth, moon # Create animation ani = animation.FuncAnimation(fig, update, frames=num_frames, interval=50, blit=True) # To save the animation as a .gif, Uncomment the next line # ani.save('circular_orbits.gif', writer='imagemagick', fps=20) plt.show() Plot T^3 vs r^3 import matplotlib.pyplot as plt import numpy as np # Data for Mercury, Venus, Earth, Mars planets = ['Mercury', 'Venus', 'Earth', 'Mars'] T = np.array([0.241, 0.615, 1.000, 1.881]) # Orbital period in years r = np.array([0.387, 0.723, 1.000, 1.524]) # Semi-major axis in AU T2 = T**2 r3 = r**3 plt.figure(figsize=(7, 5)) plt.scatter(r3, T2, color='royalblue') # Annotate each planet for i, planet in enumerate(planets): plt.annotate(planet, (r3[i], T2[i]), textcoords=\"offset points\", xytext=(5,5), ha='left') # Plot y=x line for reference (since T^2 = r^3 in AU and years) x = np.linspace(0, 4, 100) plt.plot(x, x, 'k--', label=r'$T^2 = r^3$') plt.xlabel(r'$r^3$ (AU$^3$)') plt.ylabel(r'$T^2$ (yr$^2$)') plt.title(r'Kepler\\'s Third Law: $T^2$ vs $r^3$ for Inner Planets') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law","text":"The Kepler's Third Law states that the square of a planet's orbital period is proportional to the cube of the length of the semi-major axis of its orbit . Sounds convoluted. Let's recall some basic concepts from astrodynamics: The orbital period is the amount of time it takes an astronomical object (say, a planet) to complete an orbit (curved trajectory) around another object. Recall that the Kepler's First Law states that the orbit of a planet is an ellipse. So, the semi-major axis of an orbit is then the semi-major axis of the ellipse that this orbit represents. In numerical form, the Kepler's Third Law can be written as follows: \\[ \\boxed{T^2 = \\frac{4\\pi^2}{GM}r^3} \\] Let's derive this formula.","title":"Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"Alright, let's start with the Newton's law of universal gravitation first. It takes the following form: \\[ F = G \\frac{mM}{r^2} \\] where: Notion Description \\(F\\) The force between two masses, \\(m\\) and \\(M\\) \\(G\\) The Newtonian constant of gravitation \\(m\\) The first mass \\(M\\) The second mass \\(r\\) The distance between the centers of the masses Derivation of the Newton's Law of gravitation can be found here . Thanks to the Kepler's first law, we know that the motion of one planet (this is how we will abbreviate \"astronomical object\") relative to its Sun is an ellipse. For now, we will start with circular motion; first, we will write the centripetal force - the force that makes a mass follow a curved mass - with the following formula: \\[ F_{c} = \\frac{mv^2}{r} \\] For circular motion, the gravitational force provides the centripetal force, so we can set these two expressions equal: \\[ \\frac{GMm}{r^2}=\\frac{mv^2}{r} \\implies \\frac{GM}{r}={v^2} \\] The orbital speed \\(v\\) can be related to the orbital period \\(T\\) (the time it takes to complete one full orbit) through the circumference of the orbit. The circumference \\(C\\) of a circular orbit is given by: \\[ C = 2\\pi r \\] The speed can be expressed in terms of period \\(T\\) : \\[ v = \\frac{C}{T} = \\frac{2\\pi r}{T} \\] So, returning back to \\(\\frac{GM}{r}={v^2}\\) and substituting, we get \\[ \\frac{GM}{r}={\\left( \\frac{2\\pi r}{T} \\right)^2} \\implies \\frac{GM}{r}={ \\frac{4\\pi^2 r^2}{T^2}} \\] Multiplying both sides by \\(r\\) : \\[ GM = \\frac{{4\\pi^2 r^3}}{T^2} \\] Finally, rearranging gives us the Kepler's Third Law: \\[ \\boxed{T^2 = \\frac{4\\pi^2}{GM}r^3} \\] This shows that the square of the orbital period \\(T^2\\) is proportional to the cube of the orbital radius \\(r^3\\) : \\[ T^2 \u221d r^3 \\] This formula applies not only for circular motion, but also for elliptic. In this case, \\(r\\) is the semi-major axis of the ellipse .","title":"Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-of-keplers-third-law-for-astronomy","text":"","title":"Implications of Kepler's Third Law for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-planetary-masses","text":"Kepler's Third Law can be used to determine the mass of a celestial body if the orbital period and distance of its orbiting bodies are known. \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\implies M= \\frac{4\\pi^2r^3}{GT^2} \\] This is particularly valuable in binary star systems, where two stars orbit a common center of mass. By analyzing their orbital periods and distances, astronomers can calculate their masses, enhancing our understanding of stellar evolution and the fundamental properties of stars.","title":"Calculating planetary masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#determining-distances","text":"Kepler's Third Law can also be used to determine the relative distances of celestial bodies. For example, by knowing the orbital period of a planet and applying the law, astronomers can infer its distance from the Sun in units of the semi-major axis (in astronomical units, where 1 AU is the average distance from the Earth to the Sun).","title":"Determining distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#understanding-orbital-dynamics","text":"The relationship encapsulated in Kepler's Third Law provides insights into the stability and behavior of orbits. It predicts how changing a planet's distance from the star affects its orbital period; for example, if a planet were to migrate inward, its orbital period would decrease, affecting climatic and environmental conditions on that planet.","title":"Understanding orbital dynamics"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-moons-orbit-around-earth","text":"The Moon orbits Earth with an average distance of about \\(384,400\\) km and a period of approximately \\(27.3\\) days. Using Kepler's Third Law, we can check the consistency of these values: Given data: Data Value Period \\(T\\) \\(\\approx 27.3\\) days \\(\\approx 2,359,200\\) seconds Radius \\(r\\) \\(\\approx 384,400\\) km Calculations: Data Value \\(T^2\\) \\(\\approx 5.57\\times10^{12}s^2\\) \\(r^3\\) \\(\\approx 5.67\\times10^{25}m^3\\) Using \\(G\\approx6.674 \\times 10^{-11}m^3kg^{-1}s^{-2}\\) , calculating the expected mass of Earth: \\[ M= \\frac{4\\pi^2r^3}{GT^2} \\approx \\frac{4\\pi^2\\cdot5.67\\times10^{25}}{6.674\\times 10^{-11}\\cdot 5.57 \\times 10^{12}} \\approx 5.97 \\times 10^{24}kg \\] This mass aligns closely with the known mass of Earth, demonstrating the reliability of Kepler's Third Law.","title":"The Moon's orbit around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-mode","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 mass_sun = 1.989e+30 # Mass of the Sun in kilograms mass_earth = 5.972e+24 # Mass of the Earth in kilograms mass_moon = 7.348e+22 # Mass of the Moon in kilograms # Orbital parameters distance_earth = 1.496e+11 # Distance from Sun to Earth in meters (1 AU) distance_moon = 3.844e+8 # Distance from Earth to Moon in meters T_earth = np.sqrt((4 * np.pi**2 * distance_earth**3) / (G * mass_sun)) # Orbital period of Earth T_moon = np.sqrt((4 * np.pi**2 * distance_moon**3) / (G * mass_earth)) # Orbital period of Moon # Simulation parameters num_frames = 180 # Number of frames for animation time = np.linspace(0, T_earth, num_frames) # Position calculations earth_x = distance_earth * np.cos(2 * np.pi * time / T_earth) earth_y = distance_earth * np.sin(2 * np.pi * time / T_earth) moon_x = earth_x + distance_moon * np.cos(2 * np.pi * time / T_moon) moon_y = earth_y + distance_moon * np.sin(2 * np.pi * time / T_moon) # Create figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-1.6e11, 1.6e11) ax.set_ylim(-1.6e11, 1.6e11) ax.set_aspect('equal') ax.set_title(\"Simulation of Circular Orbits\") ax.set_xlabel(\"Distance (m)\") ax.set_ylabel(\"Distance (m)\") # Initialize the Sun, Earth, and Moon sun, = ax.plot(0, 0, 'yo', markersize=12) # Sun in yellow earth, = ax.plot([], [], 'bo', markersize=6) # Earth in blue moon, = ax.plot([], [], 'gray', markersize=4) # Moon in gray # Animation update function def update(frame): # Update Earth position earth.set_data(earth_x[frame], earth_y[frame]) # Update Moon position moon.set_data(moon_x[frame], moon_y[frame]) return earth, moon # Create animation ani = animation.FuncAnimation(fig, update, frames=num_frames, interval=50, blit=True) # To save the animation as a .gif, Uncomment the next line # ani.save('circular_orbits.gif', writer='imagemagick', fps=20) plt.show()","title":"Computational mode"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-t3-vs-r3","text":"import matplotlib.pyplot as plt import numpy as np # Data for Mercury, Venus, Earth, Mars planets = ['Mercury', 'Venus', 'Earth', 'Mars'] T = np.array([0.241, 0.615, 1.000, 1.881]) # Orbital period in years r = np.array([0.387, 0.723, 1.000, 1.524]) # Semi-major axis in AU T2 = T**2 r3 = r**3 plt.figure(figsize=(7, 5)) plt.scatter(r3, T2, color='royalblue') # Annotate each planet for i, planet in enumerate(planets): plt.annotate(planet, (r3[i], T2[i]), textcoords=\"offset points\", xytext=(5,5), ha='left') # Plot y=x line for reference (since T^2 = r^3 in AU and years) x = np.linspace(0, 4, 100) plt.plot(x, x, 'k--', label=r'$T^2 = r^3$') plt.xlabel(r'$r^3$ (AU$^3$)') plt.ylabel(r'$T^2$ (yr$^2$)') plt.title(r'Kepler\\'s Third Law: $T^2$ vs $r^3$ for Inner Planets') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Plot T^3 vs r^3"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Definition of Cosmic velocities First Cosmic Velocity (Orbital Velocity) The First Cosmic Velocity , also known as the Orbital Velocity , is the minimum velocity required for an object to maintain a stable orbit around a celestial body without falling back to the surface. An object with orbital velocity moves in a circular path under the influence of gravity. The formula for the Orbital Velocity \\(v_{1}\\) at a height \\(h\\) above the center of a body with mass \\(M\\) and radius \\(R\\) is given by: \\[ v_{1} = \\sqrt{ \\frac{GM}{R+h} } \\] And, for an object on the surface \\(h = 0\\) : \\[ v_{1} = \\sqrt{ \\frac{GM}{R} } \\] In this case, the mass of the moving body is negligible compared to the mass of the celestial body. Second Cosmic Velocity (Escape Velocity) The Second Cosmic Velocity , also known as the Escape Velocity , is the minimum velocity required for an object to break free from a celestial body's gravitational influence and enter space. The formula for the Escape Velocity \\(v_{2}\\) is given by: \\[ v_{2} = \\sqrt{ \\frac{2GM}{R} } \\] Third Cosmic Velocity The Third Cosmic Velocity is the speed required to leave the gravitational influence of a star, such as the Sun. This may also require additional energy to overcome the gravitational pull of other celestial bodies, such as planets. For the third cosmic velocity \\(v_{3}\\) , it's calculated to escape the gravitational pull of the galaxy as well, and can be quite complex as it often depends on the system's dynamics. Generally, it can be expressed in relation to the escape velocity from the solar body's gravitational influence plus the additional velocity needed to overcome the stars in the galaxy. This velocity can be derived by combining the escape velocity from a planet with the necessary velocity to escape the Sun's gravity assuming you are already in orbit around that planet. The formula is: \\[ v_3 = v_2 + v_{\\text{orbital, Sun}} \\] The orbital velocity of the Sum is given by: \\[ v_{\\text{orbital, Sun}} = \\sqrt{\\frac{GM_{Sun}}{D^2}} \\] Where \\(M_{Sun}\\) is the mass of the Sun, and \\(D\\) is the distance from the Sun. Mathematical Derivation and Parameters Deriving the First Cosmic Velocity The gravitational force acting on an object is given by: $$ F = \\frac{GMm}{R^2} $$ The centripetal force required to keep an object moving in a circular path is: $$ F = \\frac{mv^2}{R} $$ Setting these two forces equal provides us the basis for our derivation of the first cosmic velocity: \\[ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\] Canceling \\(m\\) and rearranging gives: \\[ v_1^2 = \\frac{GM}{R} \\implies v_1 = \\sqrt{\\frac{GM}{R}} \\] Deriving the Second Cosmic Velocity For the second cosmic velocity, we can derive it from the conservation of energy. The total mechanical energy must be zero for an escape: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\implies v_2 = \\sqrt{\\frac{2GM}{R}} \\] Parameters Gravitational Constant \\(G\\) \\(G\\approx6.674 \\times 10^{-11}m^3kg^{-1}s^{-2}\\) ; Mass \\(M\\) The mass of the celestial body. The higher the mass of a celestial body, the more energy it requires for an object to resist its gravitational field. Radius \\(R\\) : The radius of the celestial body. The smaller the radius of a celestial body, the less energy it requires for an object to resist its gravitational field. The key parameters that affect cosmic velocities are the mass and radius of the celestial body. Calculating Cosmic Velocities for Different Celestial Bodies Let\u2019s calculate these velocities for Earth, Mars, and Jupiter. Parameter Earth Mars Jupiter Mass \\(M\\) \\(5.972 \\times 10^{24}kg\\) \\(6.4171\u00d710^{23}kg\\) \\(1.898\u00d710^{27}kg\\) Radius \\(R\\) \\(6.371\u00d710^6m\\) \\(3.3895\u00d710^6m\\) \\(6.9911\u00d710^7m\\) Orbital Velocity \\(v_{1}\\) \\(7909.6808\\) m/s \\(3554.7122\\) m/s \\(42567.5063\\) m/s Escape Velocity \\(v_{2}\\) \\(11185.9779\\) m/s \\(5027.1222\\) m/s \\(60199.5447\\) m/s import math def cosmic_velocities(mass, radius): G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 orbital = math.sqrt(G * mass / radius) escape = math.sqrt(2 * G * mass / radius) return [orbital, escape] # Define planet data: name, mass (in kg), radius (in meters) planets = [ {\"name\": \"Earth\", \"mass\": 5.972e24, \"radius\": 6.371e6}, {\"name\": \"Mars\", \"mass\": 6.4171e23, \"radius\": 3.3895e6}, {\"name\": \"Jupiter\", \"mass\": 1.898e27, \"radius\": 6.9911e7}, {\"name\": \"Venus\", \"mass\": 4.8675e24, \"radius\": 6.0518e6}, {\"name\": \"Mercury\", \"mass\": 3.3011e23, \"radius\": 2.4397e6} ] for planet in planets: velocities = cosmic_velocities(planet['mass'], planet['radius']) v_orbital = velocities[0] v_escape = velocities[1] print(f'{planet['name']}:') print(f'Orbital velocity: {v_orbital:.4f} m/s') print(f'Escape velocity: {v_escape:.4f} m/s') print() Earth: Orbital velocity: 7909.6808 m/s Escape velocity: 11185.9779 m/s Mars: Orbital velocity: 3554.7122 m/s Escape velocity: 5027.1222 m/s Jupiter: Orbital velocity: 42567.5063 m/s Escape velocity: 60199.5447 m/s Venus: Orbital velocity: 7326.7869 m/s Escape velocity: 10361.6414 m/s Mercury: Orbital velocity: 3005.1350 m/s Escape velocity: 4249.9027 m/s Earth Orbital Velocity: \\[ v_1 = \\sqrt{\\frac{(6.674 \\times 10^{-11})(5.972 \\times 10^{24})}{6.371 \\times 10^6}} \\approx 7909.6808 \\text{ m/s} \\] Escape Velocity: $$ v_2 = \\sqrt{\\frac{2 \\times (6.674 \\times 10^{-11})(5.972 \\times 10^{24})}{6.371 \\times 10^6}} \\approx 11185.9779 \\text{ m/s} $$ Mars Orbital Velocity: \\[ v_1 = \\sqrt{\\frac{(6.674 \\times 10^{-11})(6.4171 \\times 10^{23})}{3.3895 \\times 10^6}} \\approx 3554.7122 \\text{ m/s} \\] Escape Velocity: \\[ v_2 = \\sqrt{\\frac{2 \\times (6.674 \\times 10^{-11})(6.4171 \\times 10^{23})}{3.3895 \\times 10^6}} \\approx 5027.1222 \\text{ m/s} \\] Jupiter Orbital Velocity: \\[ v_1 = \\sqrt{\\frac{(6.674 \\times 10^{-11})(1.898 \\times 10^{27})}{6.9911 \\times 10^7}} \\approx 42567.5063 \\text{ m/s} \\] Escape Velocity: \\[ v_2 = \\sqrt{\\frac{2 \\times (6.674 \\times 10^{-11})(1.898 \\times 10^{27})}{6.9911 \\times 10^7}} \\approx 60199.5447 \\text{ m/s} \\] Importance in Space Exploration Launching Satellites : The first cosmic velocity (orbital velocity) is fundamental in placing satellites into stable orbits. Understanding it allows engineers to calculate the necessary thrust and trajectory to achieve the desired orbit. Missions to Other Planets : The second cosmic velocity is critical for missions that need to escape Earth's gravity and travel to other celestial bodies. A spacecraft must achieve this velocity to leave Earth and enter interplanetary space. Interstellar Travel : The third cosmic velocity gives insight into escaping a solar system's gravitational pull, which is essential for potential interstellar travel. Exploring technologies like nuclear propulsion or solar sails may eventually allow us to reach these speeds. Dependency graph Dependency graph: import numpy as np import matplotlib.pyplot as plt import pandas as pd # Constants G = 6.67430e-11 # Gravitational constant M_sun = 1.989e30 # Mass of the Sun (needed for orbital calculations) # Planet data planets = pd.DataFrame({ 'name': ['Earth', 'Mars', 'Jupiter'], 'radius': [6.371e6, 3.389e6, 6.9911e7], 'mass': [5.972e24, 6.417e23, 1.898e27] }) # Create orbital velocity vs. radius graph orbital_velocities = [] for radius in planets['radius']: orbital_velocities.append(np.sqrt(G * M_sun / radius)) planets['orbital_velocity'] = orbital_velocities # Create escape velocity vs. radius graph escape_velocities_radius = [] for radius in planets['radius']: escape_velocities_radius.append(np.sqrt(2 * G * M_sun / radius)) planets['escape_velocity_radius'] = escape_velocities_radius # Create orbital velocity vs. mass graph orbital_velocities_mass=[] for mass in planets['mass']: orbital_velocities_mass.append(np.sqrt(G*M_sun/planets['radius'].iloc[planets['mass'].values == mass].values)) planets['orbital_velocity_mass'] = orbital_velocities_mass # Create escape velocity vs. mass graph escape_velocities_mass = [] for mass in planets['mass']: escape_velocities_mass.append(np.sqrt(2 * G * mass / planets['radius'].iloc[planets['mass'].values == mass].values)) planets['escape_velocity_mass'] = escape_velocities_mass # Plotting fig, axes = plt.subplots(2, 2, figsize=(12, 8)) fig.suptitle('Orbital and Escape Velocities vs. Planet Properties') axes[0, 0].plot(planets['radius'], planets['orbital_velocity'], marker='o') axes[0, 0].set_xlabel('Planet Radius (m)') axes[0, 0].set_ylabel('Orbital Velocity (m/s)') axes[0, 0].set_title('Orbital Velocity vs. Planet Radius') axes[0, 0].set_xscale('log') axes[0, 0].set_yscale('log') axes[0, 0].grid(True) for i, row in planets.iterrows(): axes[0, 0].annotate(row['name'], (row['radius'], row['orbital_velocity'])) axes[0,0].set_xticks(planets['radius'].values) axes[0, 1].plot(planets['mass'], planets['orbital_velocity_mass'], marker='o') axes[0, 1].set_xlabel('Planet Mass (kg)') axes[0, 1].set_ylabel('Orbital Velocity (m/s)') axes[0, 1].set_title('Orbital Velocity vs. Planet Mass') axes[0, 1].set_xscale('log') axes[0, 1].set_yscale('log') axes[0, 1].grid(True) for i, row in planets.iterrows(): axes[0, 1].annotate(row['name'], (row['mass'], row['orbital_velocity_mass'])) axes[1, 0].plot(planets['radius'], planets['escape_velocity_radius'], marker='o') axes[1, 0].set_xlabel('Planet Radius (m)') axes[1, 0].set_ylabel('Escape Velocity (m/s)') axes[1, 0].set_title('Escape Velocity vs. Planet Radius') axes[1, 0].set_xscale('log') axes[1, 0].set_yscale('log') axes[1, 0].grid(True) for i, row in planets.iterrows(): axes[1, 0].annotate(row['name'], (row['radius'], row['escape_velocity_radius'])) axes[1, 1].plot(planets['mass'], planets['escape_velocity_mass'], marker='o') axes[1, 1].set_xlabel('Planet Mass (kg)') axes[1, 1].set_ylabel('Escape Velocity (m/s)') axes[1, 1].set_title('Escape Velocity vs. Planet Mass') axes[1, 1].set_xscale('log') axes[1, 1].set_yscale('log') axes[1, 1].grid(True) for i, row in planets.iterrows(): axes[1, 1].annotate(row['name'], (row['mass'], row['escape_velocity_mass'])) plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definition-of-cosmic-velocities","text":"","title":"Definition of Cosmic velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"The First Cosmic Velocity , also known as the Orbital Velocity , is the minimum velocity required for an object to maintain a stable orbit around a celestial body without falling back to the surface. An object with orbital velocity moves in a circular path under the influence of gravity. The formula for the Orbital Velocity \\(v_{1}\\) at a height \\(h\\) above the center of a body with mass \\(M\\) and radius \\(R\\) is given by: \\[ v_{1} = \\sqrt{ \\frac{GM}{R+h} } \\] And, for an object on the surface \\(h = 0\\) : \\[ v_{1} = \\sqrt{ \\frac{GM}{R} } \\] In this case, the mass of the moving body is negligible compared to the mass of the celestial body.","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The Second Cosmic Velocity , also known as the Escape Velocity , is the minimum velocity required for an object to break free from a celestial body's gravitational influence and enter space. The formula for the Escape Velocity \\(v_{2}\\) is given by: \\[ v_{2} = \\sqrt{ \\frac{2GM}{R} } \\]","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"The Third Cosmic Velocity is the speed required to leave the gravitational influence of a star, such as the Sun. This may also require additional energy to overcome the gravitational pull of other celestial bodies, such as planets. For the third cosmic velocity \\(v_{3}\\) , it's calculated to escape the gravitational pull of the galaxy as well, and can be quite complex as it often depends on the system's dynamics. Generally, it can be expressed in relation to the escape velocity from the solar body's gravitational influence plus the additional velocity needed to overcome the stars in the galaxy. This velocity can be derived by combining the escape velocity from a planet with the necessary velocity to escape the Sun's gravity assuming you are already in orbit around that planet. The formula is: \\[ v_3 = v_2 + v_{\\text{orbital, Sun}} \\] The orbital velocity of the Sum is given by: \\[ v_{\\text{orbital, Sun}} = \\sqrt{\\frac{GM_{Sun}}{D^2}} \\] Where \\(M_{Sun}\\) is the mass of the Sun, and \\(D\\) is the distance from the Sun.","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivation-and-parameters","text":"","title":"Mathematical Derivation and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deriving-the-first-cosmic-velocity","text":"The gravitational force acting on an object is given by: $$ F = \\frac{GMm}{R^2} $$ The centripetal force required to keep an object moving in a circular path is: $$ F = \\frac{mv^2}{R} $$ Setting these two forces equal provides us the basis for our derivation of the first cosmic velocity: \\[ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\] Canceling \\(m\\) and rearranging gives: \\[ v_1^2 = \\frac{GM}{R} \\implies v_1 = \\sqrt{\\frac{GM}{R}} \\]","title":"Deriving the First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deriving-the-second-cosmic-velocity","text":"For the second cosmic velocity, we can derive it from the conservation of energy. The total mechanical energy must be zero for an escape: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\implies v_2 = \\sqrt{\\frac{2GM}{R}} \\]","title":"Deriving the Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters","text":"Gravitational Constant \\(G\\) \\(G\\approx6.674 \\times 10^{-11}m^3kg^{-1}s^{-2}\\) ; Mass \\(M\\) The mass of the celestial body. The higher the mass of a celestial body, the more energy it requires for an object to resist its gravitational field. Radius \\(R\\) : The radius of the celestial body. The smaller the radius of a celestial body, the less energy it requires for an object to resist its gravitational field. The key parameters that affect cosmic velocities are the mass and radius of the celestial body.","title":"Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculating-cosmic-velocities-for-different-celestial-bodies","text":"Let\u2019s calculate these velocities for Earth, Mars, and Jupiter. Parameter Earth Mars Jupiter Mass \\(M\\) \\(5.972 \\times 10^{24}kg\\) \\(6.4171\u00d710^{23}kg\\) \\(1.898\u00d710^{27}kg\\) Radius \\(R\\) \\(6.371\u00d710^6m\\) \\(3.3895\u00d710^6m\\) \\(6.9911\u00d710^7m\\) Orbital Velocity \\(v_{1}\\) \\(7909.6808\\) m/s \\(3554.7122\\) m/s \\(42567.5063\\) m/s Escape Velocity \\(v_{2}\\) \\(11185.9779\\) m/s \\(5027.1222\\) m/s \\(60199.5447\\) m/s import math def cosmic_velocities(mass, radius): G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 orbital = math.sqrt(G * mass / radius) escape = math.sqrt(2 * G * mass / radius) return [orbital, escape] # Define planet data: name, mass (in kg), radius (in meters) planets = [ {\"name\": \"Earth\", \"mass\": 5.972e24, \"radius\": 6.371e6}, {\"name\": \"Mars\", \"mass\": 6.4171e23, \"radius\": 3.3895e6}, {\"name\": \"Jupiter\", \"mass\": 1.898e27, \"radius\": 6.9911e7}, {\"name\": \"Venus\", \"mass\": 4.8675e24, \"radius\": 6.0518e6}, {\"name\": \"Mercury\", \"mass\": 3.3011e23, \"radius\": 2.4397e6} ] for planet in planets: velocities = cosmic_velocities(planet['mass'], planet['radius']) v_orbital = velocities[0] v_escape = velocities[1] print(f'{planet['name']}:') print(f'Orbital velocity: {v_orbital:.4f} m/s') print(f'Escape velocity: {v_escape:.4f} m/s') print() Earth: Orbital velocity: 7909.6808 m/s Escape velocity: 11185.9779 m/s Mars: Orbital velocity: 3554.7122 m/s Escape velocity: 5027.1222 m/s Jupiter: Orbital velocity: 42567.5063 m/s Escape velocity: 60199.5447 m/s Venus: Orbital velocity: 7326.7869 m/s Escape velocity: 10361.6414 m/s Mercury: Orbital velocity: 3005.1350 m/s Escape velocity: 4249.9027 m/s","title":"Calculating Cosmic Velocities for Different Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth","text":"Orbital Velocity: \\[ v_1 = \\sqrt{\\frac{(6.674 \\times 10^{-11})(5.972 \\times 10^{24})}{6.371 \\times 10^6}} \\approx 7909.6808 \\text{ m/s} \\] Escape Velocity: $$ v_2 = \\sqrt{\\frac{2 \\times (6.674 \\times 10^{-11})(5.972 \\times 10^{24})}{6.371 \\times 10^6}} \\approx 11185.9779 \\text{ m/s} $$","title":"Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars","text":"Orbital Velocity: \\[ v_1 = \\sqrt{\\frac{(6.674 \\times 10^{-11})(6.4171 \\times 10^{23})}{3.3895 \\times 10^6}} \\approx 3554.7122 \\text{ m/s} \\] Escape Velocity: \\[ v_2 = \\sqrt{\\frac{2 \\times (6.674 \\times 10^{-11})(6.4171 \\times 10^{23})}{3.3895 \\times 10^6}} \\approx 5027.1222 \\text{ m/s} \\]","title":"Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiter","text":"Orbital Velocity: \\[ v_1 = \\sqrt{\\frac{(6.674 \\times 10^{-11})(1.898 \\times 10^{27})}{6.9911 \\times 10^7}} \\approx 42567.5063 \\text{ m/s} \\] Escape Velocity: \\[ v_2 = \\sqrt{\\frac{2 \\times (6.674 \\times 10^{-11})(1.898 \\times 10^{27})}{6.9911 \\times 10^7}} \\approx 60199.5447 \\text{ m/s} \\]","title":"Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"Launching Satellites : The first cosmic velocity (orbital velocity) is fundamental in placing satellites into stable orbits. Understanding it allows engineers to calculate the necessary thrust and trajectory to achieve the desired orbit. Missions to Other Planets : The second cosmic velocity is critical for missions that need to escape Earth's gravity and travel to other celestial bodies. A spacecraft must achieve this velocity to leave Earth and enter interplanetary space. Interstellar Travel : The third cosmic velocity gives insight into escaping a solar system's gravitational pull, which is essential for potential interstellar travel. Exploring technologies like nuclear propulsion or solar sails may eventually allow us to reach these speeds.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#dependency-graph","text":"Dependency graph: import numpy as np import matplotlib.pyplot as plt import pandas as pd # Constants G = 6.67430e-11 # Gravitational constant M_sun = 1.989e30 # Mass of the Sun (needed for orbital calculations) # Planet data planets = pd.DataFrame({ 'name': ['Earth', 'Mars', 'Jupiter'], 'radius': [6.371e6, 3.389e6, 6.9911e7], 'mass': [5.972e24, 6.417e23, 1.898e27] }) # Create orbital velocity vs. radius graph orbital_velocities = [] for radius in planets['radius']: orbital_velocities.append(np.sqrt(G * M_sun / radius)) planets['orbital_velocity'] = orbital_velocities # Create escape velocity vs. radius graph escape_velocities_radius = [] for radius in planets['radius']: escape_velocities_radius.append(np.sqrt(2 * G * M_sun / radius)) planets['escape_velocity_radius'] = escape_velocities_radius # Create orbital velocity vs. mass graph orbital_velocities_mass=[] for mass in planets['mass']: orbital_velocities_mass.append(np.sqrt(G*M_sun/planets['radius'].iloc[planets['mass'].values == mass].values)) planets['orbital_velocity_mass'] = orbital_velocities_mass # Create escape velocity vs. mass graph escape_velocities_mass = [] for mass in planets['mass']: escape_velocities_mass.append(np.sqrt(2 * G * mass / planets['radius'].iloc[planets['mass'].values == mass].values)) planets['escape_velocity_mass'] = escape_velocities_mass # Plotting fig, axes = plt.subplots(2, 2, figsize=(12, 8)) fig.suptitle('Orbital and Escape Velocities vs. Planet Properties') axes[0, 0].plot(planets['radius'], planets['orbital_velocity'], marker='o') axes[0, 0].set_xlabel('Planet Radius (m)') axes[0, 0].set_ylabel('Orbital Velocity (m/s)') axes[0, 0].set_title('Orbital Velocity vs. Planet Radius') axes[0, 0].set_xscale('log') axes[0, 0].set_yscale('log') axes[0, 0].grid(True) for i, row in planets.iterrows(): axes[0, 0].annotate(row['name'], (row['radius'], row['orbital_velocity'])) axes[0,0].set_xticks(planets['radius'].values) axes[0, 1].plot(planets['mass'], planets['orbital_velocity_mass'], marker='o') axes[0, 1].set_xlabel('Planet Mass (kg)') axes[0, 1].set_ylabel('Orbital Velocity (m/s)') axes[0, 1].set_title('Orbital Velocity vs. Planet Mass') axes[0, 1].set_xscale('log') axes[0, 1].set_yscale('log') axes[0, 1].grid(True) for i, row in planets.iterrows(): axes[0, 1].annotate(row['name'], (row['mass'], row['orbital_velocity_mass'])) axes[1, 0].plot(planets['radius'], planets['escape_velocity_radius'], marker='o') axes[1, 0].set_xlabel('Planet Radius (m)') axes[1, 0].set_ylabel('Escape Velocity (m/s)') axes[1, 0].set_title('Escape Velocity vs. Planet Radius') axes[1, 0].set_xscale('log') axes[1, 0].set_yscale('log') axes[1, 0].grid(True) for i, row in planets.iterrows(): axes[1, 0].annotate(row['name'], (row['radius'], row['escape_velocity_radius'])) axes[1, 1].plot(planets['mass'], planets['escape_velocity_mass'], marker='o') axes[1, 1].set_xlabel('Planet Mass (kg)') axes[1, 1].set_ylabel('Escape Velocity (m/s)') axes[1, 1].set_title('Escape Velocity vs. Planet Mass') axes[1, 1].set_xscale('log') axes[1, 1].set_yscale('log') axes[1, 1].grid(True) for i, row in planets.iterrows(): axes[1, 1].annotate(row['name'], (row['mass'], row['escape_velocity_mass'])) plt.tight_layout() plt.show()","title":"Dependency graph"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Analyzing the possible trajectories of a payload released near Earth requires a careful consideration of the initial conditions and the forces acting on it. A simple \"parabolic\" trajectory, often taught in introductory physics, is a simplified approximation. The real trajectory can be elliptical, hyperbolic, or even a complex combination depending on the payload's initial velocity vector relative to the Earth. Step 1: Defining the Physical Context The motion of a payload released from a moving rocket near Earth is governed by gravity and the initial velocity imparted by the rocket. The possible trajectories follow conic sections: Elliptical (bound orbit) Parabolic (escape trajectory) Hyperbolic (unbound trajectory) The trajectory classification depends on the specific energy of the payload: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: \\(v\\) is the velocity magnitude, \\(\u03bc=GM\\) is Earth's standard gravitational parameter ( \\(G\\) is the gravitational constant, \\(M\\) is Earth's mass), \\(r\\) is the initial radial distance from Earth's center. The conditions for trajectory classification: Bound Elliptical Orbit : \\(\\varepsilon < 0\\) Parabolic Escape : \\(\\varepsilon = 0\\) Hyperbolic Escape : \\(\u03b5>0\\) Energy Condition Eccentricity Trajectory \\(\u03b5<0\\) \\(0\u2264e<1\\) Elliptical \\(\u03b5=0\\) \\(e=1\\) Parabolic \\(\u03b5>0\\) \\(e>1\\) Hyperbolic Step 2: Equations of Motion Newton's Law of Gravitation governs the payload\u2019s acceleration: \\[ \\mathbf{a} = -\\frac{\\mu}{r^2} \\hat{r} \\] where \\(\\hat{r}\\) is the unit vector pointing radially outward. The velocity components in a general two-dimensional orbital plane are: \\[ \\frac{dv_r}{dt} = \\frac{h^2}{r^3} - \\frac{\\mu}{r^2} \\] \\[ \\frac{dv_\\theta}{dt} = -\\frac{v_r v_\\theta}{r} \\] where: \\(h=rv_{\\theta}\\) is the specific angular momentum, \\(v_r\\) and \\(v_\\theta\\) are the radial and tangential velocity components. Step 3: Computing the Trajectory Numerically For numerical simulations, we use orbital integration based on the discretized equations: Define initial conditions: \\[ r_0,\\quad v_r0,\\quad v_\\theta0 \\] Time-step integration using numerical methods (e.g., Runge-Kutta): \\[ r_{n+1} = r_n + v_{rn} \\Delta t \\] \\[ v_{rn+1} = v_{rn} + \\left(\\frac{h_n^2}{r_n^3} - \\frac{\\mu}{r_n^2} \\right) \\Delta t \\] \\[ v_{\\theta n+1} = v_{\\theta n} - \\frac{v_{rn} v_{\\theta n}}{r_n} \\Delta t \\] Step 4: Applications and Implications Orbital Insertion : If the payload is released with the right speed and direction, it can be placed in a stable orbit. Reentry Scenarios : If the speed is low and the altitude is not high enough, it will fall back to Earth due to drag. Escape Trajectory : If \\(v \\geq v_{\\text{escape}}\\) , the payload will enter an unbound trajectory, escaping Earth\u2019s gravitational influence. Escape velocity is given by: \\[ v_{\\text{escape}} = \\sqrt{\\frac{2\\mu}{r}} \\] For a release near Low Earth Orbit (~400 km altitude, r \u2248 6778 km) : \\[ v_{\\text{escape}} \\approx 11.2 \\text{ km/s} \\] Computational model import numpy as np import matplotlib.pyplot as plt from matplotlib.patches import Circle # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_earth = 6.371e6 # m mu = G * M # Initial conditions (release point) r0 = R_earth + 400e3 # 400 km altitude theta0 = 0 def compute_trajectory(v0, theta0, max_time=3e4, dt=60): \"\"\"Compute trajectory using polar coordinate equations\"\"\" # Initial state vector [r, theta, vr, vtheta] state = np.array([r0, theta0, v0 * np.sin(theta0), v0 * np.cos(theta0) / r0]) # Storage positions = [] # Time stepping for t in np.arange(0, max_time, dt): r, theta, vr, vtheta = state # Store position (convert to Cartesian) x = r * np.cos(theta) y = r * np.sin(theta) positions.append((x, y)) # Break if collision occurs if r <= R_earth: break # Derivatives drdt = vr dthetadt = vtheta dvrdt = r * vtheta**2 - mu/r**2 dvthetadt = -2 * vr * vtheta / r # Euler integration (for simplicity - use RK4 for real missions) state = state + np.array([drdt, dthetadt, dvrdt, dvthetadt]) * dt return np.array(positions) # Velocity thresholds v_circular = np.sqrt(mu/r0) v_escape = np.sqrt(2*mu/r0) # Compute trajectories elliptical_traj = compute_trajectory(0.9 * v_escape, np.pi/4) parabolic_traj = compute_trajectory(v_escape, np.pi/4) hyperbolic_traj = compute_trajectory(1.1 * v_escape, np.pi/4) # Plotting plt.figure(figsize=(10, 8)) ax = plt.gca() # Earth earth = Circle((0, 0), R_earth, color='#1f77b4', alpha=0.9) ax.add_patch(earth) # Trajectories plt.plot(elliptical_traj[:,0], elliptical_traj[:,1], 'g-', label=f'Elliptical ($v_0 = 0.9v_{{esc}}$ = {0.9*v_escape/1000:.1f} km/s)') plt.plot(parabolic_traj[:,0], parabolic_traj[:,1], 'b--', label=f'Parabolic ($v_0 = v_{{esc}}$ = {v_escape/1000:.1f} km/s)') plt.plot(hyperbolic_traj[:,0], hyperbolic_traj[:,1], 'r:', label=f'Hyperbolic ($v_0 = 1.1v_{{esc}}$ = {1.1*v_escape/1000:.1f} km/s)') # Release point plt.plot(r0 * np.cos(np.pi/4), r0 * np.sin(np.pi/4), 'k*', markersize=15) # Formatting plt.title('Payload Trajectories from 400 km Altitude', pad=20) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.legend(loc='upper right') plt.grid(True) plt.axis('equal') plt.xlim(-10*r0, 10*r0) plt.ylim(-10*r0, 10*r0) plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.patches import Circle # Constants mu = 3.986e14 # Earth's gravitational parameter (m^3/s^2) R_earth = 6371e3 # Earth's radius (m) altitude = 400e3 # Release altitude (m) r0 = R_earth + altitude # Initial distance from Earth's center (m) # Initial conditions: tangential velocities (convert km/s to m/s) velocities_km = [5.5, 6, 7, 7.5, 8, 8.5, 9, 10, 11, 11.5] velocities = [v * 1000 for v in velocities_km] # m/s # Simulation parameters dt = 10 # Time step (s) t_max = 3600 * 2 # Total simulation time (s) (2 hours) def compute_trajectory(v_tangential): # Initial conditions r = r0 theta = 0 v_r = 0 # Pure tangential release v_theta = v_tangential # Storage positions = [] # Numerical integration (Euler method for simplicity) for t in np.arange(0, t_max, dt): # Store current position x = r * np.cos(theta) y = r * np.sin(theta) positions.append((x, y)) # Update angular momentum h = r * v_theta # Update variables r += v_r * dt theta += (v_theta / r) * dt v_r += (h**2 / r**3 - mu / r**2) * dt v_theta += (-v_r * v_theta / r) * dt # Stop if crashed into Earth if r <= R_earth: break return np.array(positions) # Create figure plt.figure(figsize=(12, 12)) ax = plt.gca() # Plot Earth earth = Circle((0, 0), R_earth, color='blue', alpha=0.3) ax.add_patch(earth) # Color map for trajectories cmap = plt.get_cmap('viridis') colors = [cmap(i/len(velocities)) for i in range(len(velocities))] # Compute and plot trajectories for i, v in enumerate(velocities): traj = compute_trajectory(v) plt.plot(traj[:, 0], traj[:, 1], color=colors[i], label=f'{velocities_km[i]} km/s (\u03b5={\"+\" if 0.5*v**2 - mu/r0 >0 else \"-\"})') # Formatting plt.title('Payload Trajectories from 400 km Altitude', pad=20) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left') plt.grid(True) plt.axis('equal') plt.tight_layout() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-1-defining-the-physical-context","text":"The motion of a payload released from a moving rocket near Earth is governed by gravity and the initial velocity imparted by the rocket. The possible trajectories follow conic sections: Elliptical (bound orbit) Parabolic (escape trajectory) Hyperbolic (unbound trajectory) The trajectory classification depends on the specific energy of the payload: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: \\(v\\) is the velocity magnitude, \\(\u03bc=GM\\) is Earth's standard gravitational parameter ( \\(G\\) is the gravitational constant, \\(M\\) is Earth's mass), \\(r\\) is the initial radial distance from Earth's center. The conditions for trajectory classification: Bound Elliptical Orbit : \\(\\varepsilon < 0\\) Parabolic Escape : \\(\\varepsilon = 0\\) Hyperbolic Escape : \\(\u03b5>0\\) Energy Condition Eccentricity Trajectory \\(\u03b5<0\\) \\(0\u2264e<1\\) Elliptical \\(\u03b5=0\\) \\(e=1\\) Parabolic \\(\u03b5>0\\) \\(e>1\\) Hyperbolic","title":"Step 1: Defining the Physical Context"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-2-equations-of-motion","text":"Newton's Law of Gravitation governs the payload\u2019s acceleration: \\[ \\mathbf{a} = -\\frac{\\mu}{r^2} \\hat{r} \\] where \\(\\hat{r}\\) is the unit vector pointing radially outward. The velocity components in a general two-dimensional orbital plane are: \\[ \\frac{dv_r}{dt} = \\frac{h^2}{r^3} - \\frac{\\mu}{r^2} \\] \\[ \\frac{dv_\\theta}{dt} = -\\frac{v_r v_\\theta}{r} \\] where: \\(h=rv_{\\theta}\\) is the specific angular momentum, \\(v_r\\) and \\(v_\\theta\\) are the radial and tangential velocity components.","title":"Step 2: Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-3-computing-the-trajectory-numerically","text":"For numerical simulations, we use orbital integration based on the discretized equations: Define initial conditions: \\[ r_0,\\quad v_r0,\\quad v_\\theta0 \\] Time-step integration using numerical methods (e.g., Runge-Kutta): \\[ r_{n+1} = r_n + v_{rn} \\Delta t \\] \\[ v_{rn+1} = v_{rn} + \\left(\\frac{h_n^2}{r_n^3} - \\frac{\\mu}{r_n^2} \\right) \\Delta t \\] \\[ v_{\\theta n+1} = v_{\\theta n} - \\frac{v_{rn} v_{\\theta n}}{r_n} \\Delta t \\]","title":"Step 3: Computing the Trajectory Numerically"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-4-applications-and-implications","text":"Orbital Insertion : If the payload is released with the right speed and direction, it can be placed in a stable orbit. Reentry Scenarios : If the speed is low and the altitude is not high enough, it will fall back to Earth due to drag. Escape Trajectory : If \\(v \\geq v_{\\text{escape}}\\) , the payload will enter an unbound trajectory, escaping Earth\u2019s gravitational influence. Escape velocity is given by: \\[ v_{\\text{escape}} = \\sqrt{\\frac{2\\mu}{r}} \\] For a release near Low Earth Orbit (~400 km altitude, r \u2248 6778 km) : \\[ v_{\\text{escape}} \\approx 11.2 \\text{ km/s} \\]","title":"Step 4: Applications and Implications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#computational-model","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.patches import Circle # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_earth = 6.371e6 # m mu = G * M # Initial conditions (release point) r0 = R_earth + 400e3 # 400 km altitude theta0 = 0 def compute_trajectory(v0, theta0, max_time=3e4, dt=60): \"\"\"Compute trajectory using polar coordinate equations\"\"\" # Initial state vector [r, theta, vr, vtheta] state = np.array([r0, theta0, v0 * np.sin(theta0), v0 * np.cos(theta0) / r0]) # Storage positions = [] # Time stepping for t in np.arange(0, max_time, dt): r, theta, vr, vtheta = state # Store position (convert to Cartesian) x = r * np.cos(theta) y = r * np.sin(theta) positions.append((x, y)) # Break if collision occurs if r <= R_earth: break # Derivatives drdt = vr dthetadt = vtheta dvrdt = r * vtheta**2 - mu/r**2 dvthetadt = -2 * vr * vtheta / r # Euler integration (for simplicity - use RK4 for real missions) state = state + np.array([drdt, dthetadt, dvrdt, dvthetadt]) * dt return np.array(positions) # Velocity thresholds v_circular = np.sqrt(mu/r0) v_escape = np.sqrt(2*mu/r0) # Compute trajectories elliptical_traj = compute_trajectory(0.9 * v_escape, np.pi/4) parabolic_traj = compute_trajectory(v_escape, np.pi/4) hyperbolic_traj = compute_trajectory(1.1 * v_escape, np.pi/4) # Plotting plt.figure(figsize=(10, 8)) ax = plt.gca() # Earth earth = Circle((0, 0), R_earth, color='#1f77b4', alpha=0.9) ax.add_patch(earth) # Trajectories plt.plot(elliptical_traj[:,0], elliptical_traj[:,1], 'g-', label=f'Elliptical ($v_0 = 0.9v_{{esc}}$ = {0.9*v_escape/1000:.1f} km/s)') plt.plot(parabolic_traj[:,0], parabolic_traj[:,1], 'b--', label=f'Parabolic ($v_0 = v_{{esc}}$ = {v_escape/1000:.1f} km/s)') plt.plot(hyperbolic_traj[:,0], hyperbolic_traj[:,1], 'r:', label=f'Hyperbolic ($v_0 = 1.1v_{{esc}}$ = {1.1*v_escape/1000:.1f} km/s)') # Release point plt.plot(r0 * np.cos(np.pi/4), r0 * np.sin(np.pi/4), 'k*', markersize=15) # Formatting plt.title('Payload Trajectories from 400 km Altitude', pad=20) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.legend(loc='upper right') plt.grid(True) plt.axis('equal') plt.xlim(-10*r0, 10*r0) plt.ylim(-10*r0, 10*r0) plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.patches import Circle # Constants mu = 3.986e14 # Earth's gravitational parameter (m^3/s^2) R_earth = 6371e3 # Earth's radius (m) altitude = 400e3 # Release altitude (m) r0 = R_earth + altitude # Initial distance from Earth's center (m) # Initial conditions: tangential velocities (convert km/s to m/s) velocities_km = [5.5, 6, 7, 7.5, 8, 8.5, 9, 10, 11, 11.5] velocities = [v * 1000 for v in velocities_km] # m/s # Simulation parameters dt = 10 # Time step (s) t_max = 3600 * 2 # Total simulation time (s) (2 hours) def compute_trajectory(v_tangential): # Initial conditions r = r0 theta = 0 v_r = 0 # Pure tangential release v_theta = v_tangential # Storage positions = [] # Numerical integration (Euler method for simplicity) for t in np.arange(0, t_max, dt): # Store current position x = r * np.cos(theta) y = r * np.sin(theta) positions.append((x, y)) # Update angular momentum h = r * v_theta # Update variables r += v_r * dt theta += (v_theta / r) * dt v_r += (h**2 / r**3 - mu / r**2) * dt v_theta += (-v_r * v_theta / r) * dt # Stop if crashed into Earth if r <= R_earth: break return np.array(positions) # Create figure plt.figure(figsize=(12, 12)) ax = plt.gca() # Plot Earth earth = Circle((0, 0), R_earth, color='blue', alpha=0.3) ax.add_patch(earth) # Color map for trajectories cmap = plt.get_cmap('viridis') colors = [cmap(i/len(velocities)) for i in range(len(velocities))] # Compute and plot trajectories for i, v in enumerate(velocities): traj = compute_trajectory(v) plt.plot(traj[:, 0], traj[:, 1], color=colors[i], label=f'{velocities_km[i]} km/s (\u03b5={\"+\" if 0.5*v**2 - mu/r0 >0 else \"-\"})') # Formatting plt.title('Payload Trajectories from 400 km Altitude', pad=20) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left') plt.grid(True) plt.axis('equal') plt.tight_layout() plt.show()","title":"Computational model"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Theory A circular wave from a single point source located at \\((x_0, y_0)\\) on the water surface is described by the displacement function: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos\\left(kr - \\omega t + \\phi\\right) \\] where: \\(\\eta(x, y, t)\\) is the displacement at point \\((x, y)\\) and time \\(t\\) , \\(A\\) is the amplitude, \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega = 2\\pi f\\) is the angular frequency, \\(\\phi\\) is the initial phase. For \\(N\\) sources placed at vertices \\(\\{(x_i, y_i)\\}_{i=1}^N\\) of a regular polygon, the total displacement is given by the superposition principle: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\frac{A}{\\sqrt{r_i}} \\cos\\left(k r_i - \\omega t + \\phi_i\\right) \\] where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) . When multiple sources emit waves, the total displacement at any point is the sum of the individual waves (superposition principle). For steady-state visualization, we often fix a specific time (like \\(t=0\\) ) and sum the wave contributions at that instant. Constructive interference occurs where waves arrive in phase, amplifying displacement; destructive interference occurs where waves are out of phase, reducing or canceling displacement. Methodology Select Polygon: Choose a regular polygon (e.g., equilateral triangle, square, pentagon). Source Placement: Calculate vertices coordinates assuming a circumradius \\(R\\) . Parameters: Set amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , and initial phases \\(\\phi_i=0\\) (coherent sources). Grid: Define a 2D spatial grid \\((x,y)\\) covering the region around the polygon. Compute Displacement: For each point on the grid and fixed time \\(t\\) , compute \\(\\eta_{\\text{sum}}(x,y,t)\\) . Visualization: Plot the resulting interference pattern as a 3D surface showing displacement amplitude using Matplotlib. Interference formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a square As an example, we will take a square at the vertices of which the waves will be emitted. Given \\(N=4\\) sources located at vertices of a square, the total displacement will be: $$ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^4 \\eta_i(x, y, t) $$ Since we're interested in the steady-state interference pattern, we often consider the superimposed wave at a fixed time \\(t=0\\) : \\[ \\eta_{\\text{total}}(x, y) = \\sum_{i=1}^4 \\frac{A}{\\sqrt{r_i}} \\cos\\left(k r_i + \\phi_i\\right) \\] 2D Python visualization Below is the code that visualizes interference of waves formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a square: import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude L = 10.0 # Side length of the square lambda_wave = 2.0 # Wavelength f = 1.0 # Frequency in Hz phi = 0 # Initial phase # Derived parameters k = 2 * np.pi / lambda_wave omega = 2 * np.pi * f # Source positions (vertices of the square) half_L = L / 2 sources = [ (-half_L, -half_L), # bottom-left (half_L, -half_L), # bottom-right (half_L, half_L), # top-right (-half_L, half_L) # top-left ] # Create a grid over the region grid_size = 200 # resolution of the grid x = np.linspace(-L, L, grid_size) y = np.linspace(-L, L, grid_size) X, Y = np.meshgrid(x, y) # Compute the superposed wave at t=0 eta_total = np.zeros_like(X) for (x_i, y_i) in sources: r = np.sqrt((X - x_i)**2 + (Y - y_i)**2) + 1e-6 # add small term to avoid division by zero eta_i = (A / np.sqrt(r)) * np.cos(k * r + phi) eta_total += eta_i # Plotting plt.figure(figsize=(8, 6)) contour = plt.contourf(X, Y, eta_total, levels=100, cmap='viridis') plt.colorbar(contour, label='Wave Displacement') plt.title('Interference Pattern from 4 Water Wave Sources (Square Configuration)') plt.xlabel('x') plt.ylabel('y') # Plot source points for (x_i, y_i) in sources: plt.plot(x_i, y_i, 'ro') # source positions plt.grid(True) plt.axis('equal') plt.show() Here is the 2D graph output: Animated: Link on matplotlib.online : https://share.matplotlib.online/3fd83dc9eb7e4d3abb484fc9faaf9841 3D Python visualization The next script illustrates the same interference as above, but in a 3D graph: import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters A = 1.0 # Amplitude L = 10.0 # Side length of the square lambda_wave = 2.0 # Wavelength f = 1.0 # Frequency in Hz phi = 0 # Initial phase # Derived parameters k = 2 * np.pi / lambda_wave omega = 2 * np.pi * f # Source positions (vertices of the square) half_L = L / 2 sources = [ (-half_L, -half_L), # bottom-left (half_L, -half_L), # bottom-right (half_L, half_L), # top-right (-half_L, half_L) # top-left ] # Create a grid over the region grid_size = 200 x = np.linspace(-L, L, grid_size) y = np.linspace(-L, L, grid_size) X, Y = np.meshgrid(x, y) # Compute the superposed wave at t=0 eta_total = np.zeros_like(X) for (x_i, y_i) in sources: r = np.sqrt((X - x_i)**2 + (Y - y_i)**2) + 1e-6 eta_i = (A / np.sqrt(r)) * np.cos(k * r + phi) eta_total += eta_i # Plotting the 3D surface fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') # Plot the surface surf = ax.plot_surface(X, Y, eta_total, cmap='viridis', linewidth=0, antialiased=False) # Add color bar to indicate amplitude fig.colorbar(surf, shrink=0.5, aspect=10, label='Wave Displacement') # Title and labels ax.set_title('3D Interference Pattern from 4 Water Wave Sources (Square Configuration)') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Displacement') # Plot source points for reference for (x_i, y_i) in sources: ax.scatter(x_i, y_i, 0, color='red', s=50) plt.show() Here is the graph output: Animation: Results and Discussion When multiple wave sources emit waves simultaneously, the resulting wave at any point on the water surface is the sum of the individual waves from each source. This principle, known as superposition , leads to regions of: Constructive interference : where wave crests align, resulting in higher amplitude peaks. Destructive interference : where a crest from one wave aligns with a trough from another, canceling each other out or reducing amplitude. The pattern of these high and low amplitude regions depends on the relative phase and amplitude of the waves arriving at each point. In our setup: Four sources are placed at the vertices of a square. Each source emits circular waves with the same amplitude, wavelength, and frequency. The waves propagate outward in all directions. Key factors: Distance from each source : the phase of each wave at a point depends on the distance \\(r_{i}\\) from source \\(i\\) . Wave phase : determined by \\(kr_i\\) , where \\(k = \\frac{2\\pi}{\\lambda}\\) Interference pattern formation Near the sources: Close to a source, the wave amplitude is large, and the pattern is dominated by the local wavefronts emanating from that source. The wavefronts are roughly circular, and superposition creates concentric interference fringes. At the center of the square: The center point of the square is equidistant from all four sources. Because of symmetry, the waves from each source arrive in phase (assuming initial phases are zero). Result : Constructive interference occurs at the center, producing a bright, high-amplitude region. Along the diagonals and edges: At points along the diagonals, the distances to opposing sources are equal. The waves from these sources tend to arrive in phase, creating regular interference fringes. At points where phase differences are significant (due to differing distances), partial cancellation or reinforcement occurs, producing a pattern of alternating high and low amplitude regions. Far from the sources: As the distance increases, the wavefronts spread out, and interference patterns become more complex. The superposition results in a grid-like pattern of bright spots (constructive interference) and dark regions (destructive interference). Interpretation: The pattern results from the phase differences between waves arriving at each point. When the phase difference is an integer multiple of \\(2\\pi\\) , waves reinforce each other (constructive interference). When the phase difference is an odd multiple of \\(\\pi\\) , waves cancel out (destructive interference).","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#theory","text":"A circular wave from a single point source located at \\((x_0, y_0)\\) on the water surface is described by the displacement function: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos\\left(kr - \\omega t + \\phi\\right) \\] where: \\(\\eta(x, y, t)\\) is the displacement at point \\((x, y)\\) and time \\(t\\) , \\(A\\) is the amplitude, \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega = 2\\pi f\\) is the angular frequency, \\(\\phi\\) is the initial phase. For \\(N\\) sources placed at vertices \\(\\{(x_i, y_i)\\}_{i=1}^N\\) of a regular polygon, the total displacement is given by the superposition principle: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\frac{A}{\\sqrt{r_i}} \\cos\\left(k r_i - \\omega t + \\phi_i\\right) \\] where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) . When multiple sources emit waves, the total displacement at any point is the sum of the individual waves (superposition principle). For steady-state visualization, we often fix a specific time (like \\(t=0\\) ) and sum the wave contributions at that instant. Constructive interference occurs where waves arrive in phase, amplifying displacement; destructive interference occurs where waves are out of phase, reducing or canceling displacement.","title":"Theory"},{"location":"1%20Physics/3%20Waves/Problem_1/#methodology","text":"Select Polygon: Choose a regular polygon (e.g., equilateral triangle, square, pentagon). Source Placement: Calculate vertices coordinates assuming a circumradius \\(R\\) . Parameters: Set amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , and initial phases \\(\\phi_i=0\\) (coherent sources). Grid: Define a 2D spatial grid \\((x,y)\\) covering the region around the polygon. Compute Displacement: For each point on the grid and fixed time \\(t\\) , compute \\(\\eta_{\\text{sum}}(x,y,t)\\) . Visualization: Plot the resulting interference pattern as a 3D surface showing displacement amplitude using Matplotlib.","title":"Methodology"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-formed-on-the-water-surface-due-to-the-superposition-of-waves-emitted-from-point-sources-placed-at-the-vertices-of-a-square","text":"As an example, we will take a square at the vertices of which the waves will be emitted. Given \\(N=4\\) sources located at vertices of a square, the total displacement will be: $$ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^4 \\eta_i(x, y, t) $$ Since we're interested in the steady-state interference pattern, we often consider the superimposed wave at a fixed time \\(t=0\\) : \\[ \\eta_{\\text{total}}(x, y) = \\sum_{i=1}^4 \\frac{A}{\\sqrt{r_i}} \\cos\\left(k r_i + \\phi_i\\right) \\]","title":"Interference formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a square"},{"location":"1%20Physics/3%20Waves/Problem_1/#2d-python-visualization","text":"Below is the code that visualizes interference of waves formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a square: import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude L = 10.0 # Side length of the square lambda_wave = 2.0 # Wavelength f = 1.0 # Frequency in Hz phi = 0 # Initial phase # Derived parameters k = 2 * np.pi / lambda_wave omega = 2 * np.pi * f # Source positions (vertices of the square) half_L = L / 2 sources = [ (-half_L, -half_L), # bottom-left (half_L, -half_L), # bottom-right (half_L, half_L), # top-right (-half_L, half_L) # top-left ] # Create a grid over the region grid_size = 200 # resolution of the grid x = np.linspace(-L, L, grid_size) y = np.linspace(-L, L, grid_size) X, Y = np.meshgrid(x, y) # Compute the superposed wave at t=0 eta_total = np.zeros_like(X) for (x_i, y_i) in sources: r = np.sqrt((X - x_i)**2 + (Y - y_i)**2) + 1e-6 # add small term to avoid division by zero eta_i = (A / np.sqrt(r)) * np.cos(k * r + phi) eta_total += eta_i # Plotting plt.figure(figsize=(8, 6)) contour = plt.contourf(X, Y, eta_total, levels=100, cmap='viridis') plt.colorbar(contour, label='Wave Displacement') plt.title('Interference Pattern from 4 Water Wave Sources (Square Configuration)') plt.xlabel('x') plt.ylabel('y') # Plot source points for (x_i, y_i) in sources: plt.plot(x_i, y_i, 'ro') # source positions plt.grid(True) plt.axis('equal') plt.show() Here is the 2D graph output: Animated: Link on matplotlib.online : https://share.matplotlib.online/3fd83dc9eb7e4d3abb484fc9faaf9841","title":"2D Python visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#3d-python-visualization","text":"The next script illustrates the same interference as above, but in a 3D graph: import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters A = 1.0 # Amplitude L = 10.0 # Side length of the square lambda_wave = 2.0 # Wavelength f = 1.0 # Frequency in Hz phi = 0 # Initial phase # Derived parameters k = 2 * np.pi / lambda_wave omega = 2 * np.pi * f # Source positions (vertices of the square) half_L = L / 2 sources = [ (-half_L, -half_L), # bottom-left (half_L, -half_L), # bottom-right (half_L, half_L), # top-right (-half_L, half_L) # top-left ] # Create a grid over the region grid_size = 200 x = np.linspace(-L, L, grid_size) y = np.linspace(-L, L, grid_size) X, Y = np.meshgrid(x, y) # Compute the superposed wave at t=0 eta_total = np.zeros_like(X) for (x_i, y_i) in sources: r = np.sqrt((X - x_i)**2 + (Y - y_i)**2) + 1e-6 eta_i = (A / np.sqrt(r)) * np.cos(k * r + phi) eta_total += eta_i # Plotting the 3D surface fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') # Plot the surface surf = ax.plot_surface(X, Y, eta_total, cmap='viridis', linewidth=0, antialiased=False) # Add color bar to indicate amplitude fig.colorbar(surf, shrink=0.5, aspect=10, label='Wave Displacement') # Title and labels ax.set_title('3D Interference Pattern from 4 Water Wave Sources (Square Configuration)') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Displacement') # Plot source points for reference for (x_i, y_i) in sources: ax.scatter(x_i, y_i, 0, color='red', s=50) plt.show() Here is the graph output: Animation:","title":"3D Python visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#results-and-discussion","text":"When multiple wave sources emit waves simultaneously, the resulting wave at any point on the water surface is the sum of the individual waves from each source. This principle, known as superposition , leads to regions of: Constructive interference : where wave crests align, resulting in higher amplitude peaks. Destructive interference : where a crest from one wave aligns with a trough from another, canceling each other out or reducing amplitude. The pattern of these high and low amplitude regions depends on the relative phase and amplitude of the waves arriving at each point. In our setup: Four sources are placed at the vertices of a square. Each source emits circular waves with the same amplitude, wavelength, and frequency. The waves propagate outward in all directions. Key factors: Distance from each source : the phase of each wave at a point depends on the distance \\(r_{i}\\) from source \\(i\\) . Wave phase : determined by \\(kr_i\\) , where \\(k = \\frac{2\\pi}{\\lambda}\\)","title":"Results and Discussion"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-pattern-formation","text":"Near the sources: Close to a source, the wave amplitude is large, and the pattern is dominated by the local wavefronts emanating from that source. The wavefronts are roughly circular, and superposition creates concentric interference fringes. At the center of the square: The center point of the square is equidistant from all four sources. Because of symmetry, the waves from each source arrive in phase (assuming initial phases are zero). Result : Constructive interference occurs at the center, producing a bright, high-amplitude region. Along the diagonals and edges: At points along the diagonals, the distances to opposing sources are equal. The waves from these sources tend to arrive in phase, creating regular interference fringes. At points where phase differences are significant (due to differing distances), partial cancellation or reinforcement occurs, producing a pattern of alternating high and low amplitude regions. Far from the sources: As the distance increases, the wavefronts spread out, and interference patterns become more complex. The superposition results in a grid-like pattern of bright spots (constructive interference) and dark regions (destructive interference). Interpretation: The pattern results from the phase differences between waves arriving at each point. When the phase difference is an integer multiple of \\(2\\pi\\) , waves reinforce each other (constructive interference). When the phase difference is an odd multiple of \\(\\pi\\) , waves cancel out (destructive interference).","title":"Interference pattern formation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force The Lorentz force governs the motion of charged particles in electric and magnetic fields and is fundamental in many areas of physics such as plasma physics, particle accelerators, and astrophysics. It is expressed as: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] where - \\(q\\) is the charge of the particle, - \\(\\mathbf{E}\\) is the electric field, - \\(\\mathbf{v}\\) is the particle velocity, - \\(\\mathbf{B}\\) is the magnetic field, - \\(\\times\\) denotes the vector cross product. The electric field \\(\\mathbf{E}\\) exerts a force proportional to the charge and field strength, accelerating or decelerating particles along the field direction. The magnetic field \\(\\mathbf{B}\\) exerts a force perpendicular to both the particle velocity and the magnetic field, causing circular or helical motion without changing particle speed. Combined fields allow complex control of particle motion, including drift phenomena when fields are crossed. The Lorentz force is fundamental in many areas of physics. Here is where it's key: Particle Accelerators: Use magnetic fields to steer and focus beams of charged particles. Mass Spectrometers: Separate ions based on their mass-to-charge ratio by applying electric and magnetic fields. Plasma Confinement Devices (e.g., Tokamaks): Use magnetic fields to contain hot plasma for fusion research. Astrophysics: Charged cosmic rays and plasma interact with magnetic fields in space, influencing their trajectories. The particle's motion follows Newtons's second law: \\[ m \\frac{dv}{dt} = \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] The particle acceleration is expressed as: \\[ a = \\frac{\\mathbf{F}}{m} \\] where \\(m\\) is the particle's mass. We implement a numerical integration (e.g., Euler or Runge-Kutta) to update position and velocity over small time steps. 2D simulation of particle motion import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (Coulombs) m = 1.0 # Mass (kg) # Time parameters dt = 0.01 # Time step t_max = 10 # Total simulation time num_steps = int(t_max / dt) # Initial conditions v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position def simulate_particle(E_field, B_field, r0, v0, q, m, dt, num_steps): \"\"\" Simulate the motion of a charged particle under given electric and magnetic fields. \"\"\" r = np.zeros((num_steps, 3)) v = np.zeros((num_steps, 3)) r[0] = r0 v[0] = v0 for i in range(1, num_steps): # Compute Lorentz force F = q * (E_field + np.cross(v[i-1], B_field)) # Update velocity v[i] = v[i-1] + (F / m) * dt # Update position r[i] = r[i-1] + v[i] * dt return r, v # Example scenarios: # 1. Uniform Magnetic Field (e.g., B along z-axis) B_uniform = np.array([0, 0, 1]) # Tesla E_zero = np.array([0, 0, 0]) # No electric field r_b, v_b = simulate_particle(E_zero, B_uniform, r0, v0, q, m, dt, num_steps) # 2. Electric and Magnetic Fields (e.g., E along x, B along z) E_field = np.array([1, 0, 0]) # V/m B_field = np.array([0, 0, 1]) # Tesla r_em, v_em = simulate_particle(E_field, B_field, r0, v0, q, m, dt, num_steps) # 3. Crossed Electric and Magnetic Fields (perpendicular setup) E_cross = np.array([0, 1, 0]) # V/m B_cross = np.array([0, 0, 1]) # Tesla r_cross, v_cross = simulate_particle(E_cross, B_cross, r0, v0, q, m, dt, num_steps) # 2D Trajectory Plot (x-y plane) plt.figure(figsize=(12, 4)) # Magnetic field only plt.subplot(1, 3, 1) plt.plot(r_b[:,0], r_b[:,1]) plt.title('Magnetic Field Only') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') # E + B fields plt.subplot(1, 3, 2) plt.plot(r_em[:,0], r_em[:,1]) plt.title('E and B Fields') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') # Crossed E and B plt.subplot(1, 3, 3) plt.plot(r_cross[:,0], r_cross[:,1]) plt.title('Crossed E and B') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.tight_layout() plt.show() 3D simulation of particle motion import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (Coulombs) m = 1.0 # Mass (kg) # Time parameters dt = 0.01 # Time step t_max = 10 # Total simulation time num_steps = int(t_max / dt) # Initial conditions v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position def simulate_particle(E_field, B_field, r0, v0, q, m, dt, num_steps): \"\"\" Simulate the motion of a charged particle under given electric and magnetic fields. \"\"\" r = np.zeros((num_steps, 3)) v = np.zeros((num_steps, 3)) r[0] = r0 v[0] = v0 for i in range(1, num_steps): # Compute Lorentz force F = q * (E_field + np.cross(v[i-1], B_field)) # Update velocity v[i] = v[i-1] + (F / m) * dt # Update position r[i] = r[i-1] + v[i] * dt return r, v # Example scenarios: # 1. Uniform Magnetic Field (e.g., B along z-axis) B_uniform = np.array([0, 0, 1]) # Tesla E_zero = np.array([0, 0, 0]) # No electric field r_b, v_b = simulate_particle(E_zero, B_uniform, r0, v0, q, m, dt, num_steps) # 2. Electric and Magnetic Fields (e.g., E along x, B along z) E_field = np.array([1, 0, 0]) # V/m B_field = np.array([0, 0, 1]) # Tesla r_em, v_em = simulate_particle(E_field, B_field, r0, v0, q, m, dt, num_steps) # 3. Crossed Electric and Magnetic Fields (perpendicular setup) E_cross = np.array([0, 1, 0]) # V/m B_cross = np.array([0, 0, 1]) # Tesla r_cross, v_cross = simulate_particle(E_cross, B_cross, r0, v0, q, m, dt, num_steps) fig = plt.figure(figsize=(15, 5)) # Magnetic Field only ax1 = fig.add_subplot(131, projection='3d') ax1.plot(r_b[:,0], r_b[:,1], r_b[:,2]) ax1.set_title('Magnetic Field Only') ax1.set_xlabel('x') ax1.set_ylabel('y') ax1.set_zlabel('z') # E + B Fields ax2 = fig.add_subplot(132, projection='3d') ax2.plot(r_em[:,0], r_em[:,1], r_em[:,2]) ax2.set_title('E and B Fields') ax2.set_xlabel('x') ax2.set_ylabel('y') ax2.set_zlabel('z') # Crossed E and B ax3 = fig.add_subplot(133, projection='3d') ax3.plot(r_cross[:,0], r_cross[:,1], r_cross[:,2]) ax3.set_title('Crossed E and B') ax3.set_xlabel('x') ax3.set_ylabel('y') ax3.set_zlabel('z') plt.tight_layout() plt.show() Parameter variation and physical phenomena Varying field strengths: Increase \\(|\\mathbf{B}|\\) to see tighter circular or helical motion: Increase \\(|E|\\) to see faster drift or acceleration: Varying initial velocity : Change initial speed and direction to see different trajectories (e.g., circular vs. helical): Observations The Larmor radius is the radius of circular motion in a magnetic field. It's expressed as: \\[ r_{L} = \\frac{mv_{\\perp}}{|q|B} \\] where \\(v_{\\perp}\\) is the component of velocity perpendicular to \\(\\mathbf{B}\\) . The drift velocity in crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) fields: \\[ \\mathbf{v}_{d} = \\frac{{\\mathbf{E}\\times \\mathbf{B}}}{B^2} \\] which results in a steady drift of the particle perpendicular to both fields.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"The Lorentz force governs the motion of charged particles in electric and magnetic fields and is fundamental in many areas of physics such as plasma physics, particle accelerators, and astrophysics. It is expressed as: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] where - \\(q\\) is the charge of the particle, - \\(\\mathbf{E}\\) is the electric field, - \\(\\mathbf{v}\\) is the particle velocity, - \\(\\mathbf{B}\\) is the magnetic field, - \\(\\times\\) denotes the vector cross product. The electric field \\(\\mathbf{E}\\) exerts a force proportional to the charge and field strength, accelerating or decelerating particles along the field direction. The magnetic field \\(\\mathbf{B}\\) exerts a force perpendicular to both the particle velocity and the magnetic field, causing circular or helical motion without changing particle speed. Combined fields allow complex control of particle motion, including drift phenomena when fields are crossed. The Lorentz force is fundamental in many areas of physics. Here is where it's key: Particle Accelerators: Use magnetic fields to steer and focus beams of charged particles. Mass Spectrometers: Separate ions based on their mass-to-charge ratio by applying electric and magnetic fields. Plasma Confinement Devices (e.g., Tokamaks): Use magnetic fields to contain hot plasma for fusion research. Astrophysics: Charged cosmic rays and plasma interact with magnetic fields in space, influencing their trajectories. The particle's motion follows Newtons's second law: \\[ m \\frac{dv}{dt} = \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] The particle acceleration is expressed as: \\[ a = \\frac{\\mathbf{F}}{m} \\] where \\(m\\) is the particle's mass. We implement a numerical integration (e.g., Euler or Runge-Kutta) to update position and velocity over small time steps.","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2d-simulation-of-particle-motion","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (Coulombs) m = 1.0 # Mass (kg) # Time parameters dt = 0.01 # Time step t_max = 10 # Total simulation time num_steps = int(t_max / dt) # Initial conditions v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position def simulate_particle(E_field, B_field, r0, v0, q, m, dt, num_steps): \"\"\" Simulate the motion of a charged particle under given electric and magnetic fields. \"\"\" r = np.zeros((num_steps, 3)) v = np.zeros((num_steps, 3)) r[0] = r0 v[0] = v0 for i in range(1, num_steps): # Compute Lorentz force F = q * (E_field + np.cross(v[i-1], B_field)) # Update velocity v[i] = v[i-1] + (F / m) * dt # Update position r[i] = r[i-1] + v[i] * dt return r, v # Example scenarios: # 1. Uniform Magnetic Field (e.g., B along z-axis) B_uniform = np.array([0, 0, 1]) # Tesla E_zero = np.array([0, 0, 0]) # No electric field r_b, v_b = simulate_particle(E_zero, B_uniform, r0, v0, q, m, dt, num_steps) # 2. Electric and Magnetic Fields (e.g., E along x, B along z) E_field = np.array([1, 0, 0]) # V/m B_field = np.array([0, 0, 1]) # Tesla r_em, v_em = simulate_particle(E_field, B_field, r0, v0, q, m, dt, num_steps) # 3. Crossed Electric and Magnetic Fields (perpendicular setup) E_cross = np.array([0, 1, 0]) # V/m B_cross = np.array([0, 0, 1]) # Tesla r_cross, v_cross = simulate_particle(E_cross, B_cross, r0, v0, q, m, dt, num_steps) # 2D Trajectory Plot (x-y plane) plt.figure(figsize=(12, 4)) # Magnetic field only plt.subplot(1, 3, 1) plt.plot(r_b[:,0], r_b[:,1]) plt.title('Magnetic Field Only') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') # E + B fields plt.subplot(1, 3, 2) plt.plot(r_em[:,0], r_em[:,1]) plt.title('E and B Fields') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') # Crossed E and B plt.subplot(1, 3, 3) plt.plot(r_cross[:,0], r_cross[:,1]) plt.title('Crossed E and B') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.tight_layout() plt.show()","title":"2D simulation of particle motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3d-simulation-of-particle-motion","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (Coulombs) m = 1.0 # Mass (kg) # Time parameters dt = 0.01 # Time step t_max = 10 # Total simulation time num_steps = int(t_max / dt) # Initial conditions v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position def simulate_particle(E_field, B_field, r0, v0, q, m, dt, num_steps): \"\"\" Simulate the motion of a charged particle under given electric and magnetic fields. \"\"\" r = np.zeros((num_steps, 3)) v = np.zeros((num_steps, 3)) r[0] = r0 v[0] = v0 for i in range(1, num_steps): # Compute Lorentz force F = q * (E_field + np.cross(v[i-1], B_field)) # Update velocity v[i] = v[i-1] + (F / m) * dt # Update position r[i] = r[i-1] + v[i] * dt return r, v # Example scenarios: # 1. Uniform Magnetic Field (e.g., B along z-axis) B_uniform = np.array([0, 0, 1]) # Tesla E_zero = np.array([0, 0, 0]) # No electric field r_b, v_b = simulate_particle(E_zero, B_uniform, r0, v0, q, m, dt, num_steps) # 2. Electric and Magnetic Fields (e.g., E along x, B along z) E_field = np.array([1, 0, 0]) # V/m B_field = np.array([0, 0, 1]) # Tesla r_em, v_em = simulate_particle(E_field, B_field, r0, v0, q, m, dt, num_steps) # 3. Crossed Electric and Magnetic Fields (perpendicular setup) E_cross = np.array([0, 1, 0]) # V/m B_cross = np.array([0, 0, 1]) # Tesla r_cross, v_cross = simulate_particle(E_cross, B_cross, r0, v0, q, m, dt, num_steps) fig = plt.figure(figsize=(15, 5)) # Magnetic Field only ax1 = fig.add_subplot(131, projection='3d') ax1.plot(r_b[:,0], r_b[:,1], r_b[:,2]) ax1.set_title('Magnetic Field Only') ax1.set_xlabel('x') ax1.set_ylabel('y') ax1.set_zlabel('z') # E + B Fields ax2 = fig.add_subplot(132, projection='3d') ax2.plot(r_em[:,0], r_em[:,1], r_em[:,2]) ax2.set_title('E and B Fields') ax2.set_xlabel('x') ax2.set_ylabel('y') ax2.set_zlabel('z') # Crossed E and B ax3 = fig.add_subplot(133, projection='3d') ax3.plot(r_cross[:,0], r_cross[:,1], r_cross[:,2]) ax3.set_title('Crossed E and B') ax3.set_xlabel('x') ax3.set_ylabel('y') ax3.set_zlabel('z') plt.tight_layout() plt.show()","title":"3D simulation of particle motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-variation-and-physical-phenomena","text":"Varying field strengths: Increase \\(|\\mathbf{B}|\\) to see tighter circular or helical motion: Increase \\(|E|\\) to see faster drift or acceleration: Varying initial velocity : Change initial speed and direction to see different trajectories (e.g., circular vs. helical):","title":"Parameter variation and physical phenomena"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#observations","text":"The Larmor radius is the radius of circular motion in a magnetic field. It's expressed as: \\[ r_{L} = \\frac{mv_{\\perp}}{|q|B} \\] where \\(v_{\\perp}\\) is the component of velocity perpendicular to \\(\\mathbf{B}\\) . The drift velocity in crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) fields: \\[ \\mathbf{v}_{d} = \\frac{{\\mathbf{E}\\times \\mathbf{B}}}{B^2} \\] which results in a steady drift of the particle perpendicular to both fields.","title":"Observations"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent resistance Equivalent resistance is the total resistance measured in a parallel or series circuit, either for the whole circuit or a part of it. Equivalent resistance is defined between two terminals or nodes of the network and represents the total effect of all resistors in the circuit. The formula for equivalent resistance \\(R_{eq}\\) in a parallel combination is expressed as: \\[ \\frac{1}{R_{eq}} = \\frac{1}{R_{1}} + \\frac{1}{R_{2}} + \\dots + \\frac{1}{R_{n}} \\] where \\(R_i\\) indicates the resistance of the \\(i_{th}\\) resistor. The formula for equivalent resistance \\(R_{eq}\\) in a series combination is expressed as: \\[ R_{eq} = R_{1} + R_{2} + \\dots + R_{n} \\] where \\(R_i\\) indicates the resistance of the \\(i_{th}\\) resistor. Approach Overview Graph Representation Nodes represent circuit junctions. Edges represent resistors with resistance values as weights. Simplification Strategy Detect and merge series resistors (resistors connected end-to-end). Detect and combine parallel resistors (resistors connected between the same two nodes). Repeat until the circuit reduces to a single equivalent resistor. Implementation Tools Use the networkx library for graph manipulation. Use depth-first search (DFS) to identify series chains. Use graph analysis to find parallel connections, especially cycles. Theoretical background Circuit as a graph: We will represent the circuit as a unidirected weighted graph \\(G = (V, E)\\) , where vertices \\(V\\) are circuit nodes and edges (links) \\(E\\) are resistors with weights equal to resistance values. Series and parallel reductions: Series: Two edges connected end-to-end with a single intermediate node of degree 2 can be replaced by a single edge with resistance equal to the sum of the two resistors. Parallel: Multiple edges connecting the same pair of nodes can be replaced by a single edge with resistance given by the reciprocal of the sum of reciprocals (conductances). Graph simplification approach: Iteratively detect and reduce series chains and parallel edges until the graph reduces to a single equivalent resistor between the two nodes of interest. For complex circuits, graph spectral methods and matrix formulations involving the Laplacian matrix can be used to compute effective resistance, but iterative simplification is more intuitive and suitable for programming. Algorithm outline Input : Graph \\(G\\) with nodes and weighted edges (resistances), and two nodes \\(s\\) and \\(t\\) between which equivalent resistance is required. Preprocessing: Remove any isolated nodes not connected to \\(s\\) or \\(t\\) . Identify series chains: nodes with degree \\(2\\) not equal to \\(s\\) or \\(t\\) . Identify parallel edges between the same nodes. Iterative Simplification: Replace series chains by single edges with summed resistance. Replace parallel edges by single edges with combined resistance using parallel formula: $$ R_{eq} = \\left( \\sum_{i} \\frac{1}{R_{i}} \\right)^{-1} $$ - Repeat until only one edge remains between \\(s\\) and \\(t\\) . Implementation import networkx as nx import matplotlib.pyplot as plt from copy import deepcopy def plot_graph(G, step): pos = nx.spring_layout(G) labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=500) nx.draw_networkx_edge_labels(G, pos, edge_labels=labels) plt.title(f'Circuit after step {step}') plt.show() def combine_series(G): \"\"\" Find and combine series edges: A series connection is when a node has exactly two neighbors, and is not a terminal node (degree 2), and edges can be combined by summing resistances. \"\"\" G = deepcopy(G) changed = False # List nodes to check for series for node in list(G.nodes()): # Skip if node is terminal (degree != 2) if G.degree(node) != 2: continue neighbors = list(G.neighbors(node)) # Check if node is not a self loop or parallel edges only if len(neighbors) != 2: continue # Check if node is not an endpoint (avoid terminals) # Also ensure no parallel edges between neighbors through this node # Combine the two edges in series # Get resistances on edges (MultiGraph can have multiple edges) edges1 = G.get_edge_data(node, neighbors[0]) edges2 = G.get_edge_data(node, neighbors[1]) # Sum resistances of all parallel edges between node and neighbors r1 = sum(d['resistance'] for d in edges1.values()) r2 = sum(d['resistance'] for d in edges2.values()) # Remove node and its edges G.remove_node(node) # Add new edge between neighbors with resistance = r1 + r2 # If edge already exists, add in parallel (combine parallel) if G.has_edge(neighbors[0], neighbors[1]): # Combine parallel edges existing_edges = G.get_edge_data(neighbors[0], neighbors[1]) existing_r = sum(d['resistance'] for d in existing_edges.values()) # Parallel combination: 1/Req = 1/Rexisting + 1/(r1+r2) Req = 1 / (1 / existing_r + 1 / (r1 + r2)) # Remove old edges and add one with Req G.remove_edges_from([(neighbors[0], neighbors[1], k) for k in existing_edges.keys()]) G.add_edge(neighbors[0], neighbors[1], resistance=Req) else: G.add_edge(neighbors[0], neighbors[1], resistance=r1 + r2) changed = True break # Restart after modification return G, changed def combine_parallel(G): \"\"\" Combine parallel edges between the same two nodes: 1/Req = sum(1/Ri) \"\"\" G = deepcopy(G) changed = False for u, v in list(G.edges()): edges = G.get_edge_data(u, v) if len(edges) > 1: # Combine all parallel resistors resistances = [d['resistance'] for d in edges.values()] Req = 1 / sum(1 / r for r in resistances) # Remove all parallel edges G.remove_edges_from([(u, v, k) for k in edges.keys()]) # Add single edge with Req G.add_edge(u, v, resistance=Req) changed = True break # Restart after modification return G, changed def reduce_circuit(G): \"\"\" Reduce the circuit graph step by step: 1. Combine series edges 2. Combine parallel edges Repeat until no changes. \"\"\" step = 0 intermediate_graphs = [] current_graph = deepcopy(G) intermediate_graphs.append((step, deepcopy(current_graph))) while True: step += 1 # Combine series current_graph, changed_series = combine_series(current_graph) if changed_series: intermediate_graphs.append((step, deepcopy(current_graph))) continue # Combine parallel current_graph, changed_parallel = combine_parallel(current_graph) if changed_parallel: intermediate_graphs.append((step, deepcopy(current_graph))) continue # If no changes, stop break return current_graph, intermediate_graphs # Example circuit construction G = nx.MultiGraph() # Add edges with resistance attribute G.add_edge('A', 'B', resistance=5) G.add_edge('B', 'C', resistance=20) G.add_edge('B', 'C', resistance=100) G.add_edge('C', 'D', resistance=2) G.add_edge('B', 'E', resistance=9) G.add_edge('E', 'C', resistance=3) # Reduce circuit and get intermediate graphs final_graph, intermediates = reduce_circuit(G) # Print and plot intermediate graphs for step, g in intermediates: print(f\"Step {step}:\") for u, v, data in g.edges(data=True): print(f\" {u}-{v} : {data['resistance']:.4f} \u03a9\") plot_graph(g, step) # Final equivalent resistance edges = list(final_graph.edges(data=True)) if len(edges) == 1: u, v, data = edges[0] print(f\"Equivalent resistance between {u} and {v} is {data['resistance']:.4f} \u03a9\") else: print(\"Circuit could not be fully reduced to a single resistor.\") Output: Step 0: A-B : 5.0000 \u03a9 B-C : 20.0000 \u03a9 B-C : 100.0000 \u03a9 B-E : 9.0000 \u03a9 C-D : 2.0000 \u03a9 C-E : 3.0000 \u03a9 Step 1: A-B : 5.0000 \u03a9 B-C : 10.9091 \u03a9 C-D : 2.0000 \u03a9 Step 2: A-C : 15.9091 \u03a9 C-D : 2.0000 \u03a9 Step 3: A-D : 17.9091 \u03a9","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance","text":"Equivalent resistance is the total resistance measured in a parallel or series circuit, either for the whole circuit or a part of it. Equivalent resistance is defined between two terminals or nodes of the network and represents the total effect of all resistors in the circuit. The formula for equivalent resistance \\(R_{eq}\\) in a parallel combination is expressed as: \\[ \\frac{1}{R_{eq}} = \\frac{1}{R_{1}} + \\frac{1}{R_{2}} + \\dots + \\frac{1}{R_{n}} \\] where \\(R_i\\) indicates the resistance of the \\(i_{th}\\) resistor. The formula for equivalent resistance \\(R_{eq}\\) in a series combination is expressed as: \\[ R_{eq} = R_{1} + R_{2} + \\dots + R_{n} \\] where \\(R_i\\) indicates the resistance of the \\(i_{th}\\) resistor.","title":"Equivalent resistance"},{"location":"1%20Physics/5%20Circuits/Problem_1/#approach-overview","text":"Graph Representation Nodes represent circuit junctions. Edges represent resistors with resistance values as weights. Simplification Strategy Detect and merge series resistors (resistors connected end-to-end). Detect and combine parallel resistors (resistors connected between the same two nodes). Repeat until the circuit reduces to a single equivalent resistor. Implementation Tools Use the networkx library for graph manipulation. Use depth-first search (DFS) to identify series chains. Use graph analysis to find parallel connections, especially cycles.","title":"Approach Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#theoretical-background","text":"Circuit as a graph: We will represent the circuit as a unidirected weighted graph \\(G = (V, E)\\) , where vertices \\(V\\) are circuit nodes and edges (links) \\(E\\) are resistors with weights equal to resistance values. Series and parallel reductions: Series: Two edges connected end-to-end with a single intermediate node of degree 2 can be replaced by a single edge with resistance equal to the sum of the two resistors. Parallel: Multiple edges connecting the same pair of nodes can be replaced by a single edge with resistance given by the reciprocal of the sum of reciprocals (conductances). Graph simplification approach: Iteratively detect and reduce series chains and parallel edges until the graph reduces to a single equivalent resistor between the two nodes of interest. For complex circuits, graph spectral methods and matrix formulations involving the Laplacian matrix can be used to compute effective resistance, but iterative simplification is more intuitive and suitable for programming.","title":"Theoretical background"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-outline","text":"Input : Graph \\(G\\) with nodes and weighted edges (resistances), and two nodes \\(s\\) and \\(t\\) between which equivalent resistance is required. Preprocessing: Remove any isolated nodes not connected to \\(s\\) or \\(t\\) . Identify series chains: nodes with degree \\(2\\) not equal to \\(s\\) or \\(t\\) . Identify parallel edges between the same nodes. Iterative Simplification: Replace series chains by single edges with summed resistance. Replace parallel edges by single edges with combined resistance using parallel formula: $$ R_{eq} = \\left( \\sum_{i} \\frac{1}{R_{i}} \\right)^{-1} $$ - Repeat until only one edge remains between \\(s\\) and \\(t\\) .","title":"Algorithm outline"},{"location":"1%20Physics/5%20Circuits/Problem_1/#implementation","text":"import networkx as nx import matplotlib.pyplot as plt from copy import deepcopy def plot_graph(G, step): pos = nx.spring_layout(G) labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=500) nx.draw_networkx_edge_labels(G, pos, edge_labels=labels) plt.title(f'Circuit after step {step}') plt.show() def combine_series(G): \"\"\" Find and combine series edges: A series connection is when a node has exactly two neighbors, and is not a terminal node (degree 2), and edges can be combined by summing resistances. \"\"\" G = deepcopy(G) changed = False # List nodes to check for series for node in list(G.nodes()): # Skip if node is terminal (degree != 2) if G.degree(node) != 2: continue neighbors = list(G.neighbors(node)) # Check if node is not a self loop or parallel edges only if len(neighbors) != 2: continue # Check if node is not an endpoint (avoid terminals) # Also ensure no parallel edges between neighbors through this node # Combine the two edges in series # Get resistances on edges (MultiGraph can have multiple edges) edges1 = G.get_edge_data(node, neighbors[0]) edges2 = G.get_edge_data(node, neighbors[1]) # Sum resistances of all parallel edges between node and neighbors r1 = sum(d['resistance'] for d in edges1.values()) r2 = sum(d['resistance'] for d in edges2.values()) # Remove node and its edges G.remove_node(node) # Add new edge between neighbors with resistance = r1 + r2 # If edge already exists, add in parallel (combine parallel) if G.has_edge(neighbors[0], neighbors[1]): # Combine parallel edges existing_edges = G.get_edge_data(neighbors[0], neighbors[1]) existing_r = sum(d['resistance'] for d in existing_edges.values()) # Parallel combination: 1/Req = 1/Rexisting + 1/(r1+r2) Req = 1 / (1 / existing_r + 1 / (r1 + r2)) # Remove old edges and add one with Req G.remove_edges_from([(neighbors[0], neighbors[1], k) for k in existing_edges.keys()]) G.add_edge(neighbors[0], neighbors[1], resistance=Req) else: G.add_edge(neighbors[0], neighbors[1], resistance=r1 + r2) changed = True break # Restart after modification return G, changed def combine_parallel(G): \"\"\" Combine parallel edges between the same two nodes: 1/Req = sum(1/Ri) \"\"\" G = deepcopy(G) changed = False for u, v in list(G.edges()): edges = G.get_edge_data(u, v) if len(edges) > 1: # Combine all parallel resistors resistances = [d['resistance'] for d in edges.values()] Req = 1 / sum(1 / r for r in resistances) # Remove all parallel edges G.remove_edges_from([(u, v, k) for k in edges.keys()]) # Add single edge with Req G.add_edge(u, v, resistance=Req) changed = True break # Restart after modification return G, changed def reduce_circuit(G): \"\"\" Reduce the circuit graph step by step: 1. Combine series edges 2. Combine parallel edges Repeat until no changes. \"\"\" step = 0 intermediate_graphs = [] current_graph = deepcopy(G) intermediate_graphs.append((step, deepcopy(current_graph))) while True: step += 1 # Combine series current_graph, changed_series = combine_series(current_graph) if changed_series: intermediate_graphs.append((step, deepcopy(current_graph))) continue # Combine parallel current_graph, changed_parallel = combine_parallel(current_graph) if changed_parallel: intermediate_graphs.append((step, deepcopy(current_graph))) continue # If no changes, stop break return current_graph, intermediate_graphs # Example circuit construction G = nx.MultiGraph() # Add edges with resistance attribute G.add_edge('A', 'B', resistance=5) G.add_edge('B', 'C', resistance=20) G.add_edge('B', 'C', resistance=100) G.add_edge('C', 'D', resistance=2) G.add_edge('B', 'E', resistance=9) G.add_edge('E', 'C', resistance=3) # Reduce circuit and get intermediate graphs final_graph, intermediates = reduce_circuit(G) # Print and plot intermediate graphs for step, g in intermediates: print(f\"Step {step}:\") for u, v, data in g.edges(data=True): print(f\" {u}-{v} : {data['resistance']:.4f} \u03a9\") plot_graph(g, step) # Final equivalent resistance edges = list(final_graph.edges(data=True)) if len(edges) == 1: u, v, data = edges[0] print(f\"Equivalent resistance between {u} and {v} is {data['resistance']:.4f} \u03a9\") else: print(\"Circuit could not be fully reduced to a single resistor.\") Output: Step 0: A-B : 5.0000 \u03a9 B-C : 20.0000 \u03a9 B-C : 100.0000 \u03a9 B-E : 9.0000 \u03a9 C-D : 2.0000 \u03a9 C-E : 3.0000 \u03a9 Step 1: A-B : 5.0000 \u03a9 B-C : 10.9091 \u03a9 C-D : 2.0000 \u03a9 Step 2: A-C : 15.9091 \u03a9 C-D : 2.0000 \u03a9 Step 3: A-D : 17.9091 \u03a9","title":"Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 The Central Limit Theorem (CLT) is a fundamental concept in probability and statistics. It states that the distribution of the sample mean approaches a normal distribution as the sample size increases , regardless of the original population's distribution, provided the population has a finite variance. The Central Limit Theorem (CLT) is fundamental in probability and statistics, asserting that the sampling distribution of the sample mean tends toward a normal distribution as the sample size increases, regardless of the original distribution . Simulations are powerful tools to visualize and understand this phenomenon intuitively. To illustrate the CLT, we'll consider three types: Uniform distribution Exponential distribution Binomial distribution But first, formulas Let \\(X_1, X_2, \\ldots, X_n\\) \u200b be independent and identically distributed random variables with: Mean \\(\\mu = E[X_i]\\) Variance \\(\\sigma^2 = \\operatorname{Var}(X_i)\\) The sample mean is defined as: \\[ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] As \\(n\\to \\infty\\) , the distribution of the standardized sample mean approaches a standard normal distribution: $$ Z = \\frac{\\bar{X}_n - \\mu}{\\sigma / \\sqrt{n}} \\xrightarrow{d} N(0,1) $$ - The mean of the sampling distribution of the sample mean is \\(\\mu\\) . - The standard deviation (standard error) of the sampling distribution is: \\[ \\text{Standard Error} = \\frac{\\sigma}{\\sqrt{n}} \\] Visualization import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Generate populations population_size = 10000 uniform_population = np.random.uniform(0, 1, population_size) exponential_population = np.random.exponential(1, population_size) binomial_population = np.random.binomial(10, 0.5, population_size) def sample_means(population, sample_size, num_samples): means = [] for _ in range(num_samples): sample = np.random.choice(population, size=sample_size, replace=False) means.append(np.mean(sample)) return means sample_sizes = [5, 10, 30, 50] num_samples = 1000 sns.set(style='whitegrid') for dist_name, population in zip(['Uniform', 'Exponential', 'Binomial'], [uniform_population, exponential_population, binomial_population]): plt.figure(figsize=(12, 8)) for i, size in enumerate(sample_sizes): means = sample_means(population, size, num_samples) plt.subplot(2, 2, i+1) sns.histplot(means, kde=True, bins=30) plt.title(f'{dist_name} Distribution\\nSample size = {size}') plt.xlabel('Sample Mean') plt.ylabel('Frequency') plt.tight_layout() plt.show() For small \\(n\\) , the distribution of \\(\\bar{X}_n\\) reflects the original population's shape. As \\(n\\) increases, the distribution of \\(\\bar{X}_n\\) \u200b becomes increasingly normal, regardless of the population's original distribution. The histograms and density curves shown in the plots illustrate the distribution of the sample means obtained from repeatedly sampling the population distributions with different sample sizes. Specifically: For small sample sizes (e.g., 5, 10): The distribution of sample means tends to mirror the shape of the original population distribution. For example, if the population is skewed (like the exponential distribution), the sample mean distribution will be similarly skewed. As the sample size increases (e.g., 30, 50): The distribution of the sample means becomes increasingly more symmetric and bell-shaped , approaching a normal distribution . This visualizes the essence of the Central Limit Theorem (CLT), which states that regardless of the original distribution's shape, the sampling distribution of the mean tends toward normality as the sample size grows. Key observations: The spread (variance) of the sampling distribution decreases with larger sample sizes, indicating more precise estimates of the population mean. The convergence to a normal distribution occurs more rapidly for distributions with smaller variance or less skewness.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"The Central Limit Theorem (CLT) is a fundamental concept in probability and statistics. It states that the distribution of the sample mean approaches a normal distribution as the sample size increases , regardless of the original population's distribution, provided the population has a finite variance. The Central Limit Theorem (CLT) is fundamental in probability and statistics, asserting that the sampling distribution of the sample mean tends toward a normal distribution as the sample size increases, regardless of the original distribution . Simulations are powerful tools to visualize and understand this phenomenon intuitively. To illustrate the CLT, we'll consider three types: Uniform distribution Exponential distribution Binomial distribution","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#but-first-formulas","text":"Let \\(X_1, X_2, \\ldots, X_n\\) \u200b be independent and identically distributed random variables with: Mean \\(\\mu = E[X_i]\\) Variance \\(\\sigma^2 = \\operatorname{Var}(X_i)\\) The sample mean is defined as: \\[ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] As \\(n\\to \\infty\\) , the distribution of the standardized sample mean approaches a standard normal distribution: $$ Z = \\frac{\\bar{X}_n - \\mu}{\\sigma / \\sqrt{n}} \\xrightarrow{d} N(0,1) $$ - The mean of the sampling distribution of the sample mean is \\(\\mu\\) . - The standard deviation (standard error) of the sampling distribution is: \\[ \\text{Standard Error} = \\frac{\\sigma}{\\sqrt{n}} \\]","title":"But first, formulas"},{"location":"1%20Physics/6%20Statistics/Problem_1/#visualization","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Generate populations population_size = 10000 uniform_population = np.random.uniform(0, 1, population_size) exponential_population = np.random.exponential(1, population_size) binomial_population = np.random.binomial(10, 0.5, population_size) def sample_means(population, sample_size, num_samples): means = [] for _ in range(num_samples): sample = np.random.choice(population, size=sample_size, replace=False) means.append(np.mean(sample)) return means sample_sizes = [5, 10, 30, 50] num_samples = 1000 sns.set(style='whitegrid') for dist_name, population in zip(['Uniform', 'Exponential', 'Binomial'], [uniform_population, exponential_population, binomial_population]): plt.figure(figsize=(12, 8)) for i, size in enumerate(sample_sizes): means = sample_means(population, size, num_samples) plt.subplot(2, 2, i+1) sns.histplot(means, kde=True, bins=30) plt.title(f'{dist_name} Distribution\\nSample size = {size}') plt.xlabel('Sample Mean') plt.ylabel('Frequency') plt.tight_layout() plt.show() For small \\(n\\) , the distribution of \\(\\bar{X}_n\\) reflects the original population's shape. As \\(n\\) increases, the distribution of \\(\\bar{X}_n\\) \u200b becomes increasingly normal, regardless of the population's original distribution. The histograms and density curves shown in the plots illustrate the distribution of the sample means obtained from repeatedly sampling the population distributions with different sample sizes. Specifically: For small sample sizes (e.g., 5, 10): The distribution of sample means tends to mirror the shape of the original population distribution. For example, if the population is skewed (like the exponential distribution), the sample mean distribution will be similarly skewed. As the sample size increases (e.g., 30, 50): The distribution of the sample means becomes increasingly more symmetric and bell-shaped , approaching a normal distribution . This visualizes the essence of the Central Limit Theorem (CLT), which states that regardless of the original distribution's shape, the sampling distribution of the mean tends toward normality as the sample size grows. Key observations: The spread (variance) of the sampling distribution decreases with larger sample sizes, indicating more precise estimates of the population mean. The convergence to a normal distribution occurs more rapidly for distributions with smaller variance or less skewness.","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Part 1 The Monte Carlo method estimates \u03c0 by leveraging the ratio of points falling inside a circle to the total number of points randomly generated within a square that bounds the circle. For a unit circle (radius = 1) centered at the origin, the area is \\(\u03c0\u00b7r^2 = \u03c0\\) . The area of the bounding square (with sides of length 2, from -1 to 1) is 4. If we randomly generate points uniformly within the square, the probability that a point falls inside the circle is the ratio of the circle's area to the square's area: \\[ P=\\frac{\\text{Area of square}}{\\text{Area of circle}}=\\frac{4}{\u03c0} \\] If \\(N_{in}\\) is the number of points inside the circle and \\(N_{total}\\) is the total number of points, then \\[ \\frac{N_{in}}{N_{total}} \\approx \\frac{\\pi}{4} \\implies \\pi \\approx 4 \\cdot \\frac{N_{in}}{N_{total}} \\] Let's visualize this: Link to matplotlib.online import numpy as np import matplotlib.pyplot as plt # Parameters N = 10000 # Number of points # Generate random points in [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) # Check which points are inside the unit circle inside = x**2 + y**2 <= 1 N_in = np.sum(inside) # Estimate pi pi_estimate = 4 * N_in / N print(f\"Estimated \u03c0: {pi_estimate}\") plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2) plt.gca().add_patch(circle) plt.xlim([-1, 1]) plt.ylim([-1, 1]) plt.gca().set_aspect('equal') plt.legend() plt.title('Monte Carlo Estimation of \u03c0') plt.show() Estimated \u03c0: 3.1716 As the number of points increases, the estimate of \\(\u03c0\\) converges to the true value. The error decreases as \\(\\frac{1}{\\sqrt{ N }}\\) , characteristic of Monte Carlo methods. The method is simple but converges slowly compared to some deterministic algorithms. Part 2 Buffon\u2019s Needle is a classic probability problem for estimating \\(\u03c0\\) : Parallel lines are drawn on a plane, spaced a distance \\(d\\) apart. A needle of length \\(l \\leq d\\) is dropped randomly onto the plane. The probability \\(P\\) that the needle crossed the line is: \\[ P = \\frac{2l}{\\pi d} \\] If the needle is dropped \\(N\\) times and crossed a line \\(N_{c}\\) times, then: \\[ \\pi \\approx \\frac{2lN}{dN_{c}} \\] A great visualization can also be found here . Let's visualize this ourselves: import numpy as np import matplotlib.pyplot as plt # Set parameters d = 1.0 # Distance between parallel lines l = 0.8 # Length of the needle (less than or equal to d) N = 5000 # Number of needle drops # Seed for reproducibility np.random.seed(42) # Generate random positions of the needle centers (x, y) # Since the lines are horizontal and spaced by d, y positions are uniformly distributed within [0, d] x_centers = np.random.uniform(0, 10*d, N) # x can be anywhere, but for visualization, limit to some range y_centers = np.random.uniform(0, d, N) # Generate random orientations: angles between 0 and pi angles = np.random.uniform(0, np.pi, N) # Calculate the endpoints of each needle # Half-length components dx = (l / 2) * np.cos(angles) dy = (l / 2) * np.sin(angles) # Needle endpoints x_start = x_centers - dx x_end = x_centers + dx y_start = y_centers - dy y_end = y_centers + dy # Check if each needle crosses a line # Since lines are at y = 0, d, 2d, etc., check if the needle crosses any line # For each needle, check if the lines y=0 and y=d are crossed crossings = [] for y1, y2 in zip(y_start, y_end): # The line crosses the needle if the segment between y1 and y2 crosses y=0 or y=d crosses = ((y1 < 0 and y2 > 0) or (y1 > 0 and y2 < 0) or (y1 < d and y2 > d) or (y1 > d and y2 < d)) crossings.append(crosses) crossings = np.array(crossings) N_cross = np.sum(crossings) # Estimate pi # From the probability P = 2l / (pi * d), rearranged as pi \u2248 2lN / (d Nc) pi_estimate = (2 * l * N) / (d * N_cross) if N_cross > 0 else np.nan # --- Visualization --- fig, ax = plt.subplots(figsize=(10, 6)) # Plot the parallel lines for line_idx in range(int(np.max(y_end) // d) + 2): y_line = line_idx * d ax.plot([-1, 11 * d], [y_line, y_line], 'k-', linewidth=1) # Plot needles # Needles that crossed the lines in red, others in blue ax.plot([x_start[crossings], x_end[crossings]], [y_start[crossings], y_end[crossings]], 'r-', linewidth=0.8, label='Crossed line' if line_idx == 0 else \"\") ax.plot([x_start[~crossings], x_end[~crossings]], [y_start[~crossings], y_end[~crossings]], 'b-', linewidth=0.8, label='Did not cross' if line_idx == 0 else \"\") # Setting plot limits ax.set_xlim(-d, 11 * d) ax.set_ylim(-0.5, max(y_end) + 0.5) ax.set_title(f\"Buffon's Needle Simulation: Approximate Pi = {pi_estimate:.4f}\") ax.set_xlabel(\"X position\") ax.set_ylabel(\"Y position\") ax.legend() plt.show() \\(N=5000\\) : Increasing N improves the approximation. \\(N=100\\) : \\(N=500\\) : \\(N=1000\\) : We can adjust l and d to see how the estimate varies: Same as above, but \\(d=2.0\\) , and \\(l=1.5\\) : The visualization helps understand the random placement and crossing behavior.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1","text":"The Monte Carlo method estimates \u03c0 by leveraging the ratio of points falling inside a circle to the total number of points randomly generated within a square that bounds the circle. For a unit circle (radius = 1) centered at the origin, the area is \\(\u03c0\u00b7r^2 = \u03c0\\) . The area of the bounding square (with sides of length 2, from -1 to 1) is 4. If we randomly generate points uniformly within the square, the probability that a point falls inside the circle is the ratio of the circle's area to the square's area: \\[ P=\\frac{\\text{Area of square}}{\\text{Area of circle}}=\\frac{4}{\u03c0} \\] If \\(N_{in}\\) is the number of points inside the circle and \\(N_{total}\\) is the total number of points, then \\[ \\frac{N_{in}}{N_{total}} \\approx \\frac{\\pi}{4} \\implies \\pi \\approx 4 \\cdot \\frac{N_{in}}{N_{total}} \\] Let's visualize this: Link to matplotlib.online import numpy as np import matplotlib.pyplot as plt # Parameters N = 10000 # Number of points # Generate random points in [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) # Check which points are inside the unit circle inside = x**2 + y**2 <= 1 N_in = np.sum(inside) # Estimate pi pi_estimate = 4 * N_in / N print(f\"Estimated \u03c0: {pi_estimate}\") plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2) plt.gca().add_patch(circle) plt.xlim([-1, 1]) plt.ylim([-1, 1]) plt.gca().set_aspect('equal') plt.legend() plt.title('Monte Carlo Estimation of \u03c0') plt.show() Estimated \u03c0: 3.1716 As the number of points increases, the estimate of \\(\u03c0\\) converges to the true value. The error decreases as \\(\\frac{1}{\\sqrt{ N }}\\) , characteristic of Monte Carlo methods. The method is simple but converges slowly compared to some deterministic algorithms.","title":"Part 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2","text":"Buffon\u2019s Needle is a classic probability problem for estimating \\(\u03c0\\) : Parallel lines are drawn on a plane, spaced a distance \\(d\\) apart. A needle of length \\(l \\leq d\\) is dropped randomly onto the plane. The probability \\(P\\) that the needle crossed the line is: \\[ P = \\frac{2l}{\\pi d} \\] If the needle is dropped \\(N\\) times and crossed a line \\(N_{c}\\) times, then: \\[ \\pi \\approx \\frac{2lN}{dN_{c}} \\] A great visualization can also be found here . Let's visualize this ourselves: import numpy as np import matplotlib.pyplot as plt # Set parameters d = 1.0 # Distance between parallel lines l = 0.8 # Length of the needle (less than or equal to d) N = 5000 # Number of needle drops # Seed for reproducibility np.random.seed(42) # Generate random positions of the needle centers (x, y) # Since the lines are horizontal and spaced by d, y positions are uniformly distributed within [0, d] x_centers = np.random.uniform(0, 10*d, N) # x can be anywhere, but for visualization, limit to some range y_centers = np.random.uniform(0, d, N) # Generate random orientations: angles between 0 and pi angles = np.random.uniform(0, np.pi, N) # Calculate the endpoints of each needle # Half-length components dx = (l / 2) * np.cos(angles) dy = (l / 2) * np.sin(angles) # Needle endpoints x_start = x_centers - dx x_end = x_centers + dx y_start = y_centers - dy y_end = y_centers + dy # Check if each needle crosses a line # Since lines are at y = 0, d, 2d, etc., check if the needle crosses any line # For each needle, check if the lines y=0 and y=d are crossed crossings = [] for y1, y2 in zip(y_start, y_end): # The line crosses the needle if the segment between y1 and y2 crosses y=0 or y=d crosses = ((y1 < 0 and y2 > 0) or (y1 > 0 and y2 < 0) or (y1 < d and y2 > d) or (y1 > d and y2 < d)) crossings.append(crosses) crossings = np.array(crossings) N_cross = np.sum(crossings) # Estimate pi # From the probability P = 2l / (pi * d), rearranged as pi \u2248 2lN / (d Nc) pi_estimate = (2 * l * N) / (d * N_cross) if N_cross > 0 else np.nan # --- Visualization --- fig, ax = plt.subplots(figsize=(10, 6)) # Plot the parallel lines for line_idx in range(int(np.max(y_end) // d) + 2): y_line = line_idx * d ax.plot([-1, 11 * d], [y_line, y_line], 'k-', linewidth=1) # Plot needles # Needles that crossed the lines in red, others in blue ax.plot([x_start[crossings], x_end[crossings]], [y_start[crossings], y_end[crossings]], 'r-', linewidth=0.8, label='Crossed line' if line_idx == 0 else \"\") ax.plot([x_start[~crossings], x_end[~crossings]], [y_start[~crossings], y_end[~crossings]], 'b-', linewidth=0.8, label='Did not cross' if line_idx == 0 else \"\") # Setting plot limits ax.set_xlim(-d, 11 * d) ax.set_ylim(-0.5, max(y_end) + 0.5) ax.set_title(f\"Buffon's Needle Simulation: Approximate Pi = {pi_estimate:.4f}\") ax.set_xlabel(\"X position\") ax.set_ylabel(\"Y position\") ax.legend() plt.show() \\(N=5000\\) : Increasing N improves the approximation. \\(N=100\\) : \\(N=500\\) : \\(N=1000\\) : We can adjust l and d to see how the estimate varies: Same as above, but \\(d=2.0\\) , and \\(l=1.5\\) : The visualization helps understand the random placement and crossing behavior.","title":"Part 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Data Length of the pendulum, \\(L = 40\\, \\text{cm} = 0.40\\, \\text{m}\\) Ruler resolution: 10 mm per cm = 1 mm = 0.1 cm Measurements of \\(T_{10}\\) (time for 10 oscillations): Trial \\(T_{10}\\) (s) 1 13.11 2 13.11 3 12.90 4 12.60 5 12.99 6 12.44 7 12.53 8 13.02 9 12.77 10 12.64 Procedure Materials String (~1-1.5 meters) Small weight (coins, key, etc.) Stopwatch (or smartphone timer) Ruler or measuring tape Setup Attach the weight to the string and fix to a support. Measure the length \\(L\\) from the support to the center of the weight: \\(L = 40\\, \\text{cm}\\) Ruler resolution: 10 mm per cm \u2192 uncertainty in length: $$ \\Delta L = \\frac{\\text{Ruler resolution}}{2} = \\frac{0.1\\, \\text{cm}}{2} = 0.05\\, \\text{cm} = 0.0005\\, \\text{m} $$ Data Collection Displace the pendulum slightly (<15\u00b0) and release. Measure \\(T_{10}\\) (time for 10 oscillations) 10 times. Compute the mean \\(\\overline{T}_{10}\\) and standard deviation \\(\\sigma_T\\) . Uncertainty in mean: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} \\] where \\(n=10\\) . Calculations 1. Compute the average period \\(T\\) and its uncertainty: \\[ T = \\frac{\\overline{T}_{10}}{10} $$ $$ \\Delta T = \\frac{\\Delta T_{10}}{10} \\] Given data, first calculate \\(\\overline{T}_{10}\\) : \\[ \\overline{T}_{10} = \\frac{13.11 + 13.11 + 12.90 + 12.60 + 12.99 + 12.44 + 12.53 + 13.02 + 12.77 + 12.64}{10} = \\frac{125.01}{10} = 12.501\\, \\text{s} \\] Calculate standard deviation \\(\\sigma_T\\) : \\[ \\sigma_T = \\sqrt{\\frac{\\sum (T_{i} - \\overline{T})^2}{n-1}} \\] Compute each deviation: \\(T_i\\) \\(T_i - \\overline{T}\\) \\((T_i - \\overline{T})^2\\) 13.11 0.609 0.371 13.11 0.609 0.371 12.90 0.399 0.159 12.60 0.099 0.010 12.99 0.489 0.239 12.44 -0.061 0.004 12.53 0.029 0.001 13.02 0.519 0.269 12.77 0.269 0.072 12.64 0.139 0.019 Sum of squared deviations: \\[ \\text{Sum} = 0.371 + 0.371 + 0.159 + 0.010 + 0.239 + 0.004 + 0.001 + 0.269 + 0.072 + 0.019 = 1.524 \\] Standard deviation: \\[ \\sigma_T = \\sqrt{\\frac{1.524}{9}} = \\sqrt{0.169} \\approx 0.411\\, \\text{s} \\] Uncertainty in mean: \\[ \\Delta T_{10} = \\frac{0.411}{\\sqrt{10}} \\approx 0.130\\, \\text{s} \\] Now, compute \\(T\\) and \\(\\Delta T\\) : \\[ T = \\frac{12.501}{10} = 1.250\\, \\text{s} \\] \\[ \\Delta T = \\frac{0.130}{10} = 0.013\\, \\text{s} \\] 2. Calculate the acceleration due to gravity \\(g\\) : \\[ g = \\frac{4 \\pi^2 L}{T^2} \\] Plugging in values: \\[ g = \\frac{4 \\pi^2 \\times 0.40}{(1.250)^2} = \\frac{4 \\times 9.8696 \\times 0.40}{1.5625} \\approx \\frac{15.791}{1.5625} \\approx 10.12\\, \\text{m/s}^2 \\] 3. Propagate uncertainties: Uncertainty in \\(g\\) : \\[ \\Delta g = g \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\frac{\\Delta T}{T}\\right)^2} \\] Calculate each component: \\[ \\frac{\\Delta L}{L} = \\frac{0.0005}{0.40} = 0.00125 \\] \\[ 2 \\frac{\\Delta T}{T} = 2 \\times \\frac{0.013}{1.250} = 2 \\times 0.0104 = 0.0208 \\] Therefore: \\[ \\Delta g = 10.12 \\times \\sqrt{(0.00125)^2 + (0.0208)^2} \\approx 10.12 \\times \\sqrt{1.56 \\times 10^{-6} + 4.33 \\times 10^{-4}} \\approx 10.12 \\times 0.0208 \\approx 0.21\\, \\text{m/s}^2 \\] Final Results: \\[ \\boxed{ \\begin{aligned} T &= 1.250 \\pm 0.013\\, \\text{s} \\\\ g &= 10.12 \\pm 0.21\\, \\text{m/s}^2 \\end{aligned} } \\] Analysis The measured value of \\(g\\) (~10.12 m/s\u00b2) is slightly higher than the standard value (9.81 m/s\u00b2), which could be due to local variations, experimental uncertainties, or small errors in measurement. The resolution of the ruler introduces a small uncertainty in the length measurement, but it has a minimal effect compared to timing uncertainties. Timing variability contributes more significantly to the uncertainty in \\(g\\) , emphasizing the importance of precise timing methods. Assumptions such as small oscillation angles (<15\u00b0) and neglecting air resistance are implicit in the simple pendulum model. Remarks Ensure to include all your raw data, calculations, and discussion points in your project report. You can further improve accuracy by increasing the number of trials or using more precise timing tools.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data","text":"Length of the pendulum, \\(L = 40\\, \\text{cm} = 0.40\\, \\text{m}\\) Ruler resolution: 10 mm per cm = 1 mm = 0.1 cm","title":"Data"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measurements-of-t_10-time-for-10-oscillations","text":"Trial \\(T_{10}\\) (s) 1 13.11 2 13.11 3 12.90 4 12.60 5 12.99 6 12.44 7 12.53 8 13.02 9 12.77 10 12.64","title":"Measurements of \\(T_{10}\\) (time for 10 oscillations):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"String (~1-1.5 meters) Small weight (coins, key, etc.) Stopwatch (or smartphone timer) Ruler or measuring tape","title":"Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#setup","text":"Attach the weight to the string and fix to a support. Measure the length \\(L\\) from the support to the center of the weight: \\(L = 40\\, \\text{cm}\\) Ruler resolution: 10 mm per cm \u2192 uncertainty in length: $$ \\Delta L = \\frac{\\text{Ruler resolution}}{2} = \\frac{0.1\\, \\text{cm}}{2} = 0.05\\, \\text{cm} = 0.0005\\, \\text{m} $$","title":"Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-collection","text":"Displace the pendulum slightly (<15\u00b0) and release. Measure \\(T_{10}\\) (time for 10 oscillations) 10 times. Compute the mean \\(\\overline{T}_{10}\\) and standard deviation \\(\\sigma_T\\) . Uncertainty in mean: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} \\] where \\(n=10\\) .","title":"Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-compute-the-average-period-t-and-its-uncertainty","text":"\\[ T = \\frac{\\overline{T}_{10}}{10} $$ $$ \\Delta T = \\frac{\\Delta T_{10}}{10} \\] Given data, first calculate \\(\\overline{T}_{10}\\) : \\[ \\overline{T}_{10} = \\frac{13.11 + 13.11 + 12.90 + 12.60 + 12.99 + 12.44 + 12.53 + 13.02 + 12.77 + 12.64}{10} = \\frac{125.01}{10} = 12.501\\, \\text{s} \\] Calculate standard deviation \\(\\sigma_T\\) : \\[ \\sigma_T = \\sqrt{\\frac{\\sum (T_{i} - \\overline{T})^2}{n-1}} \\] Compute each deviation: \\(T_i\\) \\(T_i - \\overline{T}\\) \\((T_i - \\overline{T})^2\\) 13.11 0.609 0.371 13.11 0.609 0.371 12.90 0.399 0.159 12.60 0.099 0.010 12.99 0.489 0.239 12.44 -0.061 0.004 12.53 0.029 0.001 13.02 0.519 0.269 12.77 0.269 0.072 12.64 0.139 0.019 Sum of squared deviations: \\[ \\text{Sum} = 0.371 + 0.371 + 0.159 + 0.010 + 0.239 + 0.004 + 0.001 + 0.269 + 0.072 + 0.019 = 1.524 \\] Standard deviation: \\[ \\sigma_T = \\sqrt{\\frac{1.524}{9}} = \\sqrt{0.169} \\approx 0.411\\, \\text{s} \\] Uncertainty in mean: \\[ \\Delta T_{10} = \\frac{0.411}{\\sqrt{10}} \\approx 0.130\\, \\text{s} \\] Now, compute \\(T\\) and \\(\\Delta T\\) : \\[ T = \\frac{12.501}{10} = 1.250\\, \\text{s} \\] \\[ \\Delta T = \\frac{0.130}{10} = 0.013\\, \\text{s} \\]","title":"1. Compute the average period \\(T\\) and its uncertainty:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-calculate-the-acceleration-due-to-gravity-g","text":"\\[ g = \\frac{4 \\pi^2 L}{T^2} \\] Plugging in values: \\[ g = \\frac{4 \\pi^2 \\times 0.40}{(1.250)^2} = \\frac{4 \\times 9.8696 \\times 0.40}{1.5625} \\approx \\frac{15.791}{1.5625} \\approx 10.12\\, \\text{m/s}^2 \\]","title":"2. Calculate the acceleration due to gravity \\(g\\):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-propagate-uncertainties","text":"Uncertainty in \\(g\\) : \\[ \\Delta g = g \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\frac{\\Delta T}{T}\\right)^2} \\] Calculate each component: \\[ \\frac{\\Delta L}{L} = \\frac{0.0005}{0.40} = 0.00125 \\] \\[ 2 \\frac{\\Delta T}{T} = 2 \\times \\frac{0.013}{1.250} = 2 \\times 0.0104 = 0.0208 \\] Therefore: \\[ \\Delta g = 10.12 \\times \\sqrt{(0.00125)^2 + (0.0208)^2} \\approx 10.12 \\times \\sqrt{1.56 \\times 10^{-6} + 4.33 \\times 10^{-4}} \\approx 10.12 \\times 0.0208 \\approx 0.21\\, \\text{m/s}^2 \\]","title":"3. Propagate uncertainties:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-results","text":"\\[ \\boxed{ \\begin{aligned} T &= 1.250 \\pm 0.013\\, \\text{s} \\\\ g &= 10.12 \\pm 0.21\\, \\text{m/s}^2 \\end{aligned} } \\]","title":"Final Results:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"The measured value of \\(g\\) (~10.12 m/s\u00b2) is slightly higher than the standard value (9.81 m/s\u00b2), which could be due to local variations, experimental uncertainties, or small errors in measurement. The resolution of the ruler introduces a small uncertainty in the length measurement, but it has a minimal effect compared to timing uncertainties. Timing variability contributes more significantly to the uncertainty in \\(g\\) , emphasizing the importance of precise timing methods. Assumptions such as small oscillation angles (<15\u00b0) and neglecting air resistance are implicit in the simple pendulum model.","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#remarks","text":"Ensure to include all your raw data, calculations, and discussion points in your project report. You can further improve accuracy by increasing the number of trials or using more precise timing tools.","title":"Remarks"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}