{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Deriving basic formulas of the projectile motion Suppose a projectile is launched at an angle \\(\\theta\\) above the horizontal with an initial velocity \\(v_{0}\\) . For this section, assume no air resistance . Horizontal motion ( \\(x\\) -direction) In the absence of air resistance, there is no horizontal force acting on the projectile: \\[ F_{x} = 0 \\] Based on the Second Newton's Law of Motion: \\[ \\vec{F} = m\\vec{a} \\] Therefore, \\[ m a_{x} = 0 \\implies \\frac{d^2x}{dt^2}m=0 \\] Since the projectile does not accelerate on the \\(x\\) -axis, its immediate velocity (the first derivative of path) equals to the initial velocity with which the projectile has been launched in the first place: \\[ \\frac{dx}{dt} = v_{0x} \\] The \\(x\\) -component of the initial velocity is \\[ v_{0x} = v_{0}\\cos(\\theta) \\] Therefore, the equation of motion of the projectile on the \\(x\\) -axis can be described with the following equation: $$ \\boxed{\\frac{dt}{dx} = v_{0}\\cos(\\theta)} $$ Where \\(\\theta\\) is the launch angle of the projectile. To find the \\(x\\) -component of the position of the projectile at time \\(t\\) , we need to solve this equation for \\(x\\) . Solving the above differential equation will give us the following: \\[ x(t) = v_{0}\\cos(\\theta)t + C_{1} \\] To find \\(C_{1}\\) , set the initial condition \\(x(0) = 0\\) (the path at time \\(0\\) is, of course, \\(0\\) ), and therefore \\[ C_{1} = 0 \\] Thus, \\[ \\boxed{x(t) = v_{0}\\cos(\\theta)t} \\] This equation will give us the position of the projectile at the time \\(t\\) . Vertical motion ( \\(y\\) -direction) The only force acting vertically is the force of gravity : \\[ F_{y}=-mg \\] The projectile doesn't experience any other acceleration and moves until it hits the ground due to gravity. Therefore, the \\(y\\) -component of the projectile motion can be described with the following equation: \\[ \\boxed{\\frac{dy}{dt} = v_{0}\\sin(\\theta)-gt} \\] Where \\(v_{0}\\sin(\\theta)\\) is the \\(y\\) -component of the initial velocity of the projectile, and \\(g\\) is the acceleration due to gravity (i.e., \\(\\frac{d^2y}{dt^2} = -g\\) ). This gives us \\[ \\boxed{y(t)=v_{0}\\sin(\\theta)t -\\frac{1}{2}gt^2} \\] When the projectile hits the ground To find when the projectile hits the ground, we set \\(y(t)=0\\) (altitude zero): \\[ 0=v_{0}\\sin(\\theta)t -\\frac{1}{2}gt^2 \\] Rearranging items gives us: \\[ -\\frac{1}{2}gt^2 + v_{0}\\sin(\\theta) = 0 \\] Solving the quadratic equation: \\(D=(v_{0}\\sin(\\theta))^2\\) \\(t_{1} = \\frac{-v_{0}\\sin(\\theta)+v_{0}\\sin(\\theta)}{-1g} = \\frac{0}{-g} =0\\) - when the projectile is launched; \\(t_{2}=\\frac{-v_{0}\\sin(\\theta)-v_{0}\\sin(\\theta)}{-g}=\\frac{2v_{0}\\sin(\\theta)}{g}\\) So that, the total flight time of a projectile launched with the velocity \\(v_{0}\\) at the angle \\(\\theta\\) : \\[ \\boxed{t_{f}=\\frac{2v_{0}\\sin(\\theta)}{g}} \\] The horizontal range The range that the projectile passes, i.e., the horizontal distance traveled when \\(t=t_{f}\\) , can be found by the formula: \\[R=v_{0x}(t_{f})=v_{0}\\cos(\\theta)\\frac{2v_{0}\\sin(\\theta)}{g}=\\frac{2v_{0}^2 \\left( \\frac{1}{2} \\sin(2\\theta)\\right) }{g}=\\frac{v_{0}^2\\sin(2\\theta) }{g}\\] \\[\\boxed{R=\\frac{v_{0}^2\\sin(2\\theta) }{g}}\\] Investigating how angle and the initial velocity influence the range of the projectile motion Varying angles import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile.\"\"\" # Convert angle to radians angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Parameters initial_velocity = 30 # m/s angles = [15, 30, 45, 60, 75] # Selected launch angles (degrees) # Setting up the plot plt.figure(figsize=(10, 6)) # Loop through each angle to plot the trajectory for angle in angles: x, y = projectile_motion(initial_velocity, angle) plt.plot(x, y, label=f'\u03b8 = {angle}\u00b0') # Customize the plot plt.title('Projectile Trajectories for Different Launch Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show() The general form of the range as a function of \\(\\theta\\) . It demonstrates how varying the launch angle affects the distance traveled. Different values of \\(v_0\\) affect the range as well. As a result, we get a family of parabolic curves when graphed. The range \\(R\\) depends on the angle of projection \\(\\theta\\) through the sine function, which reaches its maximum at \\(90^\\circ\\) . However, due to the sinusoidal nature of the \\(\\sin\u2061(2\\theta)\\) , the optimal launch angle for maximum horizontal range is \\(45^\\circ\\) . Varying initial velocity import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile.\"\"\" # Convert angle to radians angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Parameters angle = 45 initial_velocities = [10, 20, 30, 40, 50] # m/s # Setting up the plot plt.figure(figsize=(10, 6)) # Loop velocities each angle to plot the trajectory for initial_velocity in initial_velocities: x, y = projectile_motion(initial_velocity, angle) plt.plot(x, y, label=f'v0 = {initial_velocity}') # Customize the plot plt.title('Projectile Trajectories for Different Launch Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show() Taking altitude into account Given everything discussed above, let's add another parameter into the equation: altitude. Suppose a projectile is launched from a height \\(h_{0}\\) above the ground. The equation of the vertical component of the motion then changes: \\[ y(t)=h_{0}+v_{0}\\sin (\\theta) t - \\frac{1}{2}gt^2 \\] To find the time of flight with this parameter added, we need to solve the above equation at \\(0\\) : \\[ 0=h_{0}+v_{0}\\sin (\\theta) t - \\frac{1}{2}gt^2 \\] Launch time: \\[ t_{1}=\\frac{v_{0}\\sin(\\theta)+\\sqrt{ v_{0}^2\\sin(\\theta)^2 +2gh_{0} }}{g} \\] When the projectile hits the ground: \\[ t_{2}=\\frac{v_{0}\\sin(\\theta)-\\sqrt{ v_{0}^2\\sin(\\theta)^2 +2gh_{0} }}{g} \\] The horizontal range is then: \\[ R=v_{0}t_{2} \\] Demonstration import numpy as np import matplotlib.pyplot as plt def projectile_motion_with_altitude(v0, angle, h0, g=9.81, dt=0.01): \"\"\"Calculate the trajectory of a projectile launched from an altitude.\"\"\" angle_rad = np.radians(angle) # Initial velocities v_x = v0 * np.cos(angle_rad) v_y = v0 * np.sin(angle_rad) # Initialize lists to store positions and time t_values = [0] x_values = [0] y_values = [h0] # Start from initial height x, y = 0, h0 # Initial position at the height h0 t = 0 # Initial time while y >= 0: # Continue until the projectile hits the ground (y < 0) # Update positions x += v_x * dt y += v_y * dt # Update velocities due to gravity v_y -= g * dt # Only vertical component affected by gravity # Record values t += dt t_values.append(t) x_values.append(x) y_values.append(y) return x_values, y_values # Parameters initial_velocity = 30 # m/s angle = 45 # Launch angle (degrees) altitudes = [-5, 0, 10, 20] # Different launch heights (above or below ground level) # Setting up the plot plt.figure(figsize=(10, 6)) # Loop through different altitudes for h0 in altitudes: x_with_altitude, y_with_altitude = projectile_motion_with_altitude(initial_velocity, angle, h0) plt.plot(x_with_altitude, y_with_altitude, label=f'Initial Height: {h0} m') # Customize the plot plt.title('Projectile Trajectories at Varying Initial Altitudes') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(-10, 150) # X-axis limit plt.ylim(0, 60) # Y-axis limit, accommodating negative heights plt.grid() plt.legend() plt.show() Exploring how launch altitude influences the horizontal range Taking into account air resistance Let's face it: the above model is not realistic unless you live on a planed with zero-density air (actually, you have no chances to survive there). This section aims to derive equations that do take air resistance into account. The simplest model considers a drag force proportional to the velocity ( the faster the projectile moves, the stronger the air resistance ), i.e., linear drag . Horizontal motion with air resistance ( \\(x\\) -direction) The total force acting on the projectile on the \\(x\\) -axis, given air resistance, is as follows: \\[ F_{x} = ma_{x} = -bv_{x} \\] where \\(b\\) is the drag coefficient. Given \\(v_{x} = \\frac{dx}{dt}\\) , and \\(a_{x} = \\frac{d^2x}{dt^2}\\) , we derive: \\[ \\begin{cases} F_{x} = m \\frac{d^2x}{dt^2} \\\\ F_{x} = -b \\frac{dx}{dt} \\end{cases} \\implies m \\frac{d^2x}{dt^2} = -b \\frac{dx}{dt} \\] Eliminating mass \\(m\\) from the left gives: \\[ \\boxed{\\frac{d^2x}{dt^2} = -\\frac{b}{m} \\frac{dx}{dt}} \\] To solve this, first separate variables (given that acceleration is the first derivative of velocity): \\[ \\frac{dv_{x}}{dt} = -\\frac{b}{m} v_{x} \\implies \\frac{1}{v_{x}} \\frac{dv_{x}}{dt} = -\\frac{b}{m} \\] Integrating both parts over \\(dt\\) : \\[ \\int{\\frac{1}{v_{x}} \\frac{dv_{x}}{dt} dt} = \\int-\\frac{b}{m} dt \\] Implies: \\[ \\int{\\frac{1}{v_{x}} dv_{x}} = -\\frac{b}{m} \\int dt \\] Integration gives: \\[ \\ln | v_{x} | = -\\frac{b}{m} t + C_{3} \\] Therefore, \\[ v_{x}(t) = v_{0}\\cos(\\theta)e^{-b/m}t \\] Integrating again to get \\(x(t)\\) : \\[ x(t) = \\frac{mv_{0}\\cos(\\theta)}{b}(1-e^{-\\frac{b}{m}t}) + C_{4} \\] If \\(x(0) =0\\) , we find \\(C_{4}=0\\) . Vertical motion with air resistance ( \\(y\\) -direction) The total force acting on the projectile on the \\(x\\) -axis, given air resistance, is as follows: \\[ F_{y} = -mg - bv_{y} \\] where \\(b\\) is the drag coefficient. Given that \\(F_{y} = ma_{y}\\) , \\(a_{y} = \\frac{d^2y}{dy^2}\\) , and \\(v_{y} = \\frac{dy}{dt}\\) : \\[ m \\frac{d^2y}{dy^2} = -mg - b \\frac{dy}{dt} \\] Eliminating mass gives: \\[ \\boxed{\\frac{d^2y}{dy^2} = -g - \\frac{b}{m} \\frac{dy}{dt}} \\] Reorganizing items and substituting \\(v_y\\) , his can be rewritten as \\[ \\frac{dv_{y}}{dt} + \\frac{b}{m}v_{y} = -g \\] This is again a first-order linear differential equation, with solution:b \\[ v_{y}(t) = \\left( v_{0}\\sin(\\theta) + \\frac{mg}{b} \\right)e^{ - \\frac{b}{m}t} - \\frac{mg}{b} \\] Integrating gives: \\[ y(t) = -\\frac{m}{b}\\left( v_{0}\\sin(\\theta) + \\frac{mg}{b}\\right)e^{-\\frac{b}{m}t } + \\frac{mg}{b}t + C_{5} \\] With \\(y(0) =0\\) : set \\(C_{5} = 0\\) . Demonstration import numpy as np import matplotlib.pyplot as plt def projectile_motion_no_drag(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile without air resistance.\"\"\" angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def projectile_motion_with_drag(v0, angle, b, g=9.81, dt=0.01): \"\"\"Calculate the trajectory of a projectile with air resistance.\"\"\" angle_rad = np.radians(angle) # Initial velocities v_x = v0 * np.cos(angle_rad) v_y = v0 * np.sin(angle_rad) # Initialize lists to store positions and time t_values = [0] x_values = [0] y_values = [0] x, y = 0, 0 # Initial position t = 0 # Initial time while y >= 0: # Continue until the projectile hits the ground # Update positions x += v_x * dt y += v_y * dt # Update velocities with drag force v_x -= (b * v_x / np.sqrt(v_x**2 + v_y**2)) * dt # Drag force v_y -= (g + (b * v_y / np.sqrt(v_x**2 + v_y**2))) * dt # Gravitational force + Drag # Record values t += dt t_values.append(t) x_values.append(x) y_values.append(y) return x_values, y_values # Parameters initial_velocity = 30 # m/s drag_coefficient = 0.1 # Drag coefficient angle = 45 # Launch angle (degrees) # Calculate projectile motion trajectories x_no_drag, y_no_drag = projectile_motion_no_drag(initial_velocity, angle) x_with_drag, y_with_drag = projectile_motion_with_drag(initial_velocity, angle, drag_coefficient) # Setting up the plot plt.figure(figsize=(10, 6)) plt.plot(x_no_drag, y_no_drag, label='No Air Resistance', color='blue') drags = [0.5, 1.0, 1.5, 2.0] colors = ['darkred', 'red', 'darkorange', 'orange'] # Loop through drag coefficients and colors simultaneously for drag, c in zip(drags, colors): x_with_drag, y_with_drag = projectile_motion_with_drag(initial_velocity, angle, drag) plt.plot(x_with_drag, y_with_drag, label=f'Air Resistance: {drag}', color=c, linestyle='--') # Customize the plot plt.title('Projectile Trajectories: With Varying Air Resistance vs Without Air Resistance') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-basic-formulas-of-the-projectile-motion","text":"Suppose a projectile is launched at an angle \\(\\theta\\) above the horizontal with an initial velocity \\(v_{0}\\) . For this section, assume no air resistance .","title":"Deriving basic formulas of the projectile motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion-x-direction","text":"In the absence of air resistance, there is no horizontal force acting on the projectile: \\[ F_{x} = 0 \\] Based on the Second Newton's Law of Motion: \\[ \\vec{F} = m\\vec{a} \\] Therefore, \\[ m a_{x} = 0 \\implies \\frac{d^2x}{dt^2}m=0 \\] Since the projectile does not accelerate on the \\(x\\) -axis, its immediate velocity (the first derivative of path) equals to the initial velocity with which the projectile has been launched in the first place: \\[ \\frac{dx}{dt} = v_{0x} \\] The \\(x\\) -component of the initial velocity is \\[ v_{0x} = v_{0}\\cos(\\theta) \\] Therefore, the equation of motion of the projectile on the \\(x\\) -axis can be described with the following equation: $$ \\boxed{\\frac{dt}{dx} = v_{0}\\cos(\\theta)} $$ Where \\(\\theta\\) is the launch angle of the projectile. To find the \\(x\\) -component of the position of the projectile at time \\(t\\) , we need to solve this equation for \\(x\\) . Solving the above differential equation will give us the following: \\[ x(t) = v_{0}\\cos(\\theta)t + C_{1} \\] To find \\(C_{1}\\) , set the initial condition \\(x(0) = 0\\) (the path at time \\(0\\) is, of course, \\(0\\) ), and therefore \\[ C_{1} = 0 \\] Thus, \\[ \\boxed{x(t) = v_{0}\\cos(\\theta)t} \\] This equation will give us the position of the projectile at the time \\(t\\) .","title":"Horizontal motion (\\(x\\)-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion-y-direction","text":"The only force acting vertically is the force of gravity : \\[ F_{y}=-mg \\] The projectile doesn't experience any other acceleration and moves until it hits the ground due to gravity. Therefore, the \\(y\\) -component of the projectile motion can be described with the following equation: \\[ \\boxed{\\frac{dy}{dt} = v_{0}\\sin(\\theta)-gt} \\] Where \\(v_{0}\\sin(\\theta)\\) is the \\(y\\) -component of the initial velocity of the projectile, and \\(g\\) is the acceleration due to gravity (i.e., \\(\\frac{d^2y}{dt^2} = -g\\) ). This gives us \\[ \\boxed{y(t)=v_{0}\\sin(\\theta)t -\\frac{1}{2}gt^2} \\]","title":"Vertical motion (\\(y\\)-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#when-the-projectile-hits-the-ground","text":"To find when the projectile hits the ground, we set \\(y(t)=0\\) (altitude zero): \\[ 0=v_{0}\\sin(\\theta)t -\\frac{1}{2}gt^2 \\] Rearranging items gives us: \\[ -\\frac{1}{2}gt^2 + v_{0}\\sin(\\theta) = 0 \\] Solving the quadratic equation: \\(D=(v_{0}\\sin(\\theta))^2\\) \\(t_{1} = \\frac{-v_{0}\\sin(\\theta)+v_{0}\\sin(\\theta)}{-1g} = \\frac{0}{-g} =0\\) - when the projectile is launched; \\(t_{2}=\\frac{-v_{0}\\sin(\\theta)-v_{0}\\sin(\\theta)}{-g}=\\frac{2v_{0}\\sin(\\theta)}{g}\\) So that, the total flight time of a projectile launched with the velocity \\(v_{0}\\) at the angle \\(\\theta\\) : \\[ \\boxed{t_{f}=\\frac{2v_{0}\\sin(\\theta)}{g}} \\]","title":"When the projectile hits the ground"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#the-horizontal-range","text":"The range that the projectile passes, i.e., the horizontal distance traveled when \\(t=t_{f}\\) , can be found by the formula: \\[R=v_{0x}(t_{f})=v_{0}\\cos(\\theta)\\frac{2v_{0}\\sin(\\theta)}{g}=\\frac{2v_{0}^2 \\left( \\frac{1}{2} \\sin(2\\theta)\\right) }{g}=\\frac{v_{0}^2\\sin(2\\theta) }{g}\\] \\[\\boxed{R=\\frac{v_{0}^2\\sin(2\\theta) }{g}}\\]","title":"The horizontal range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-how-angle-and-the-initial-velocity-influence-the-range-of-the-projectile-motion","text":"","title":"Investigating how angle and the initial velocity influence the range of the projectile motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#varying-angles","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile.\"\"\" # Convert angle to radians angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Parameters initial_velocity = 30 # m/s angles = [15, 30, 45, 60, 75] # Selected launch angles (degrees) # Setting up the plot plt.figure(figsize=(10, 6)) # Loop through each angle to plot the trajectory for angle in angles: x, y = projectile_motion(initial_velocity, angle) plt.plot(x, y, label=f'\u03b8 = {angle}\u00b0') # Customize the plot plt.title('Projectile Trajectories for Different Launch Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show() The general form of the range as a function of \\(\\theta\\) . It demonstrates how varying the launch angle affects the distance traveled. Different values of \\(v_0\\) affect the range as well. As a result, we get a family of parabolic curves when graphed. The range \\(R\\) depends on the angle of projection \\(\\theta\\) through the sine function, which reaches its maximum at \\(90^\\circ\\) . However, due to the sinusoidal nature of the \\(\\sin\u2061(2\\theta)\\) , the optimal launch angle for maximum horizontal range is \\(45^\\circ\\) .","title":"Varying angles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#varying-initial-velocity","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile.\"\"\" # Convert angle to radians angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Parameters angle = 45 initial_velocities = [10, 20, 30, 40, 50] # m/s # Setting up the plot plt.figure(figsize=(10, 6)) # Loop velocities each angle to plot the trajectory for initial_velocity in initial_velocities: x, y = projectile_motion(initial_velocity, angle) plt.plot(x, y, label=f'v0 = {initial_velocity}') # Customize the plot plt.title('Projectile Trajectories for Different Launch Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show()","title":"Varying initial velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#taking-altitude-into-account","text":"Given everything discussed above, let's add another parameter into the equation: altitude. Suppose a projectile is launched from a height \\(h_{0}\\) above the ground. The equation of the vertical component of the motion then changes: \\[ y(t)=h_{0}+v_{0}\\sin (\\theta) t - \\frac{1}{2}gt^2 \\] To find the time of flight with this parameter added, we need to solve the above equation at \\(0\\) : \\[ 0=h_{0}+v_{0}\\sin (\\theta) t - \\frac{1}{2}gt^2 \\] Launch time: \\[ t_{1}=\\frac{v_{0}\\sin(\\theta)+\\sqrt{ v_{0}^2\\sin(\\theta)^2 +2gh_{0} }}{g} \\] When the projectile hits the ground: \\[ t_{2}=\\frac{v_{0}\\sin(\\theta)-\\sqrt{ v_{0}^2\\sin(\\theta)^2 +2gh_{0} }}{g} \\] The horizontal range is then: \\[ R=v_{0}t_{2} \\]","title":"Taking altitude into account"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#demonstration","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion_with_altitude(v0, angle, h0, g=9.81, dt=0.01): \"\"\"Calculate the trajectory of a projectile launched from an altitude.\"\"\" angle_rad = np.radians(angle) # Initial velocities v_x = v0 * np.cos(angle_rad) v_y = v0 * np.sin(angle_rad) # Initialize lists to store positions and time t_values = [0] x_values = [0] y_values = [h0] # Start from initial height x, y = 0, h0 # Initial position at the height h0 t = 0 # Initial time while y >= 0: # Continue until the projectile hits the ground (y < 0) # Update positions x += v_x * dt y += v_y * dt # Update velocities due to gravity v_y -= g * dt # Only vertical component affected by gravity # Record values t += dt t_values.append(t) x_values.append(x) y_values.append(y) return x_values, y_values # Parameters initial_velocity = 30 # m/s angle = 45 # Launch angle (degrees) altitudes = [-5, 0, 10, 20] # Different launch heights (above or below ground level) # Setting up the plot plt.figure(figsize=(10, 6)) # Loop through different altitudes for h0 in altitudes: x_with_altitude, y_with_altitude = projectile_motion_with_altitude(initial_velocity, angle, h0) plt.plot(x_with_altitude, y_with_altitude, label=f'Initial Height: {h0} m') # Customize the plot plt.title('Projectile Trajectories at Varying Initial Altitudes') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(-10, 150) # X-axis limit plt.ylim(0, 60) # Y-axis limit, accommodating negative heights plt.grid() plt.legend() plt.show()","title":"Demonstration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#exploring-how-launch-altitude-influences-the-horizontal-range","text":"","title":"Exploring how launch altitude influences the horizontal range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#taking-into-account-air-resistance","text":"Let's face it: the above model is not realistic unless you live on a planed with zero-density air (actually, you have no chances to survive there). This section aims to derive equations that do take air resistance into account. The simplest model considers a drag force proportional to the velocity ( the faster the projectile moves, the stronger the air resistance ), i.e., linear drag .","title":"Taking into account air resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion-with-air-resistance-x-direction","text":"The total force acting on the projectile on the \\(x\\) -axis, given air resistance, is as follows: \\[ F_{x} = ma_{x} = -bv_{x} \\] where \\(b\\) is the drag coefficient. Given \\(v_{x} = \\frac{dx}{dt}\\) , and \\(a_{x} = \\frac{d^2x}{dt^2}\\) , we derive: \\[ \\begin{cases} F_{x} = m \\frac{d^2x}{dt^2} \\\\ F_{x} = -b \\frac{dx}{dt} \\end{cases} \\implies m \\frac{d^2x}{dt^2} = -b \\frac{dx}{dt} \\] Eliminating mass \\(m\\) from the left gives: \\[ \\boxed{\\frac{d^2x}{dt^2} = -\\frac{b}{m} \\frac{dx}{dt}} \\] To solve this, first separate variables (given that acceleration is the first derivative of velocity): \\[ \\frac{dv_{x}}{dt} = -\\frac{b}{m} v_{x} \\implies \\frac{1}{v_{x}} \\frac{dv_{x}}{dt} = -\\frac{b}{m} \\] Integrating both parts over \\(dt\\) : \\[ \\int{\\frac{1}{v_{x}} \\frac{dv_{x}}{dt} dt} = \\int-\\frac{b}{m} dt \\] Implies: \\[ \\int{\\frac{1}{v_{x}} dv_{x}} = -\\frac{b}{m} \\int dt \\] Integration gives: \\[ \\ln | v_{x} | = -\\frac{b}{m} t + C_{3} \\] Therefore, \\[ v_{x}(t) = v_{0}\\cos(\\theta)e^{-b/m}t \\] Integrating again to get \\(x(t)\\) : \\[ x(t) = \\frac{mv_{0}\\cos(\\theta)}{b}(1-e^{-\\frac{b}{m}t}) + C_{4} \\] If \\(x(0) =0\\) , we find \\(C_{4}=0\\) .","title":"Horizontal motion with air resistance (\\(x\\)-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion-with-air-resistance-y-direction","text":"The total force acting on the projectile on the \\(x\\) -axis, given air resistance, is as follows: \\[ F_{y} = -mg - bv_{y} \\] where \\(b\\) is the drag coefficient. Given that \\(F_{y} = ma_{y}\\) , \\(a_{y} = \\frac{d^2y}{dy^2}\\) , and \\(v_{y} = \\frac{dy}{dt}\\) : \\[ m \\frac{d^2y}{dy^2} = -mg - b \\frac{dy}{dt} \\] Eliminating mass gives: \\[ \\boxed{\\frac{d^2y}{dy^2} = -g - \\frac{b}{m} \\frac{dy}{dt}} \\] Reorganizing items and substituting \\(v_y\\) , his can be rewritten as \\[ \\frac{dv_{y}}{dt} + \\frac{b}{m}v_{y} = -g \\] This is again a first-order linear differential equation, with solution:b \\[ v_{y}(t) = \\left( v_{0}\\sin(\\theta) + \\frac{mg}{b} \\right)e^{ - \\frac{b}{m}t} - \\frac{mg}{b} \\] Integrating gives: \\[ y(t) = -\\frac{m}{b}\\left( v_{0}\\sin(\\theta) + \\frac{mg}{b}\\right)e^{-\\frac{b}{m}t } + \\frac{mg}{b}t + C_{5} \\] With \\(y(0) =0\\) : set \\(C_{5} = 0\\) .","title":"Vertical motion with air resistance (\\(y\\)-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#demonstration_1","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion_no_drag(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile without air resistance.\"\"\" angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def projectile_motion_with_drag(v0, angle, b, g=9.81, dt=0.01): \"\"\"Calculate the trajectory of a projectile with air resistance.\"\"\" angle_rad = np.radians(angle) # Initial velocities v_x = v0 * np.cos(angle_rad) v_y = v0 * np.sin(angle_rad) # Initialize lists to store positions and time t_values = [0] x_values = [0] y_values = [0] x, y = 0, 0 # Initial position t = 0 # Initial time while y >= 0: # Continue until the projectile hits the ground # Update positions x += v_x * dt y += v_y * dt # Update velocities with drag force v_x -= (b * v_x / np.sqrt(v_x**2 + v_y**2)) * dt # Drag force v_y -= (g + (b * v_y / np.sqrt(v_x**2 + v_y**2))) * dt # Gravitational force + Drag # Record values t += dt t_values.append(t) x_values.append(x) y_values.append(y) return x_values, y_values # Parameters initial_velocity = 30 # m/s drag_coefficient = 0.1 # Drag coefficient angle = 45 # Launch angle (degrees) # Calculate projectile motion trajectories x_no_drag, y_no_drag = projectile_motion_no_drag(initial_velocity, angle) x_with_drag, y_with_drag = projectile_motion_with_drag(initial_velocity, angle, drag_coefficient) # Setting up the plot plt.figure(figsize=(10, 6)) plt.plot(x_no_drag, y_no_drag, label='No Air Resistance', color='blue') drags = [0.5, 1.0, 1.5, 2.0] colors = ['darkred', 'red', 'darkorange', 'orange'] # Loop through drag coefficients and colors simultaneously for drag, c in zip(drags, colors): x_with_drag, y_with_drag = projectile_motion_with_drag(initial_velocity, angle, drag) plt.plot(x_with_drag, y_with_drag, label=f'Air Resistance: {drag}', color=c, linestyle='--') # Customize the plot plt.title('Projectile Trajectories: With Varying Air Resistance vs Without Air Resistance') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show()","title":"Demonstration"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Pendulum motion: small angles The motion of a forced damped pendulum is described by the following second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L}\\sin \\theta = A \\cos(wt) \\] This is a second-order differential equation governing the angular displacement \\(\\theta\\) of a pendulum with damping and driven forces. Here: Notation Description \\(\\theta\\) Angular displacement from the vertical ( equilibrium ) position; measured in radians. \\(\\frac{d^2\\theta}{dt^2}\\) Angular acceleration of the pendulum. \\(b\\) Damping coefficient (which accounts for friction or air resistance). \\(\\frac{d\\theta}{dt}\\) Angular velocity of the pendulum (the rate of change of the angle \\(\\theta\\) ) \\(g\\) Acceleration due to gravity. \\(L\\) The length of the pendulum. \\(A\\cos(\\omega t)\\) Represents the external driving force; \\(A\\) is the amplitude, and \\(\\omega\\) is the angular frequency of the external forcing. For small angles ( \\(\\theta\\) approaching to \\(0\\) or \\(\\theta \\approx 0\\) ), we can use the approximation \\(\\sin(\\theta) \\approx \\theta\\) . With this, the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L}\\sin \\theta = A \\cos(wt) \\implies \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(wt) \\] Solving differential equation of a damped pendulum for small-angle approximations To solve the equation, we first consider the homogeneous part (setting the driving force to zero): \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] This is a standard form for a damped harmonic oscillator. To solve this linear differential equation, we assume a solution of the form: \\[ \\theta(t) = e^{rt} \\] Here, \\(r\\) is the constant we want to determine. The first derivative of our assumed solution is \\(\\frac{d\\theta}{dt} = re^{rt}\\) . The second is \\(\\frac{d^2\\theta}{dt^2} = r^2e^{rt}\\) . Substituting, gives \\[ r^2e^{rt} + b(re^{rt}) + \\frac{g}{L}(e^{rt}) = 0 \\] Factoring out \\(e^{rt}\\) : \\[ e^{rt}(r^2 + br + \\frac{g}{L}) = 0 \\] The term \\(e^{rt}\\) does not contribute any solutions since it is always positive for real values of \\(r\\) . Therefore, we obtain our characteristic equation from the remaining polynomial: \\[ r^2+br+\\frac{g}{L} =0 \\] To find \\(r\\) , we need to solve the above equation: \\[ r = \\frac{-b\\pm \\sqrt{ b^2 -4\\frac{g}{L} }}{2} \\] Where \\(D= b^2 -4\\frac{g}{L}\\) . Roots and behavior: Underdamped Condition: \\(D > 0 \\implies b^2 \\gt 4 \\frac{g}{L}\\) Result: Two distinct real roots, leading to oscillatory motion with gradually decreasing amplitude (oscillations). Physically, this means the pendulum swings back and forth across the vertical position, with the amplitude decreasing over time due to damping. The oscillations gradually lose energy (due to friction or air resistance), resulting in a motion that resembles a sine wave, but one that progressively decays. This is the pendulum we usually think about, i.e., a swinging pendulum that slowly stops swinging as it loses energy. Critically damped Condition: \\(D = 0 \\implies b^2 = 4 \\frac{g}{L}\\) Result: Two identical real roots, leading to the system returning to equilibrium as quickly as possible without oscillating. In this case, the pendulum will move towards its lowest point but won't overshoot or undergo any oscillation. It smoothly comes to rest at the vertical position. Take a door as an example: its damping mechanism shuts the door quickly without bouncing back. Overdamped Condition: \\(D < 0 \\implies b^2 < 4 \\frac{g}{L}\\) Result: Two complex conjugate roots, leading to a non-oscillatory return toward equilibrium. The system takes longer to return than in the critically damped case. Here, the pendulum slowly returns to its resting position without any oscillations, typically taking a longer time to settle compared to the critically damped case. For example, a pendulum that is heavily damped (like a long jump rope acting as a pendulum) that gently settles down without swinging back and forth. No damping Below there is a diagram comparing three cases: underdamped pendulum motion, motion with no damping, and critically damped motion: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # 1. Underdamped case parameters (b > 0, b^2 < 4g/L) b_underdamped = 1.0 # Damping Coefficient (low but positive) omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * np.cos(omega_d_underdamped * t) # 2. No Damping case parameters (b = 0) b_no_damping = 0.0 # No Damping omega_no_damping = np.sqrt(g / L) theta_no_damping = np.cos(omega_no_damping * t) # Simple harmonic motion # 3. Critically Damped case parameters (b^2 = 4g/L) b_critical = 2.0 * np.sqrt(g / L) # Adjusted for critical damping theta_critical = (1 + b_critical*t) * np.exp(-b_critical / 2 * t) # Critically damped response # Create plots plt.figure(figsize=(12, 10)) # Underdamped Motion Plot plt.subplot(3, 2, 1) plt.plot(t, theta_underdamped, label='Underdamped', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Underdamped Phase Diagram plt.subplot(3, 2, 2) plt.plot(theta_underdamped[:-1], np.diff(theta_underdamped) / np.diff(t), color='blue') plt.title('Underdamped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # No Damping Motion Plot plt.subplot(3, 2, 3) plt.plot(t, theta_no_damping, label='No Damping', color='green') plt.title('Pendulum Motion with No Damping') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # No Damping Phase Diagram plt.subplot(3, 2, 4) plt.plot(theta_no_damping[:-1], np.diff(theta_no_damping) / np.diff(t), color='green') plt.title('No Damping Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Critically Damped Motion Plot plt.subplot(3, 2, 5) plt.plot(t, theta_critical, label='Critically Damped', color='orange') plt.title('Critically Damped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Critically Damped Phase Diagram plt.subplot(3, 2, 6) plt.plot(theta_critical[:-1], np.diff(theta_critical) / np.diff(t), color='orange') plt.title('Critically Damped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Adjust layout plt.tight_layout() plt.show() Underdamped, Critically Damped, and Overdamped The next diagram compares three cases: underdamped, critically damped, and overdamped motion: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # Underdamped case parameters (b^2 > 4g/L) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * np.cos(omega_d_underdamped * t) # Critically damped case parameters (b^2 = 4g/L) b_critically_damped = 2 * np.sqrt(g / L) theta_critically_damped = np.exp(-b_critically_damped / 2 * t) * (1 + (b_critically_damped / 2) * t) # Overdamped case parameters (b^2 < 4g/L) b_overdamped = 3.0 # Choose a value greater than 2*sqrt(g/L) omega_0_overdamped = np.sqrt((b_overdamped / 2) ** 2 - g / L) theta_overdamped = np.exp(-b_overdamped / 2 * t) * (np.cosh(omega_0_overdamped * t) - (b_overdamped / (2 * omega_0_overdamped)) * np.sinh(omega_0_overdamped * t)) # Calculate angular velocities for the phase diagrams omega_underdamped = -b_underdamped / 2 * theta_underdamped - (g / L) * np.sin(theta_underdamped) omega_critically_damped = np.diff(theta_critically_damped) / np.diff(t) # Numerical derivative omega_critically_damped = np.append(omega_critically_damped, omega_critically_damped[-1]) # Append last value for length compatibility omega_overdamped = -b_overdamped / 2 * theta_overdamped + omega_0_overdamped * np.cosh(omega_0_overdamped * t) # Plotting plt.figure(figsize=(12, 12)) # Underdamped plt.subplot(3, 2, 1) plt.plot(t, theta_underdamped, label='Underdamped', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Underdamped Phase Diagram plt.subplot(3, 2, 2) plt.plot(theta_underdamped[:-1], omega_underdamped[:-1], color='blue') plt.title('Underdamped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Critically Damped plt.subplot(3, 2, 3) plt.plot(t, theta_critically_damped, label='Critically Damped', color='orange') plt.title('Critically Damped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Critically Damped Phase Diagram plt.subplot(3, 2, 4) plt.plot(theta_critically_damped[:-1], omega_critically_damped[:-1], color='orange') plt.title('Critically Damped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Overdamped plt.subplot(3, 2, 5) plt.plot(t, theta_overdamped, label='Overdamped', color='green') plt.title('Overdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Overdamped Phase Diagram plt.subplot(3, 2, 6) plt.plot(theta_overdamped[:-1], omega_overdamped[:-1], color='green') plt.title('Overdamped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Adjust layout plt.tight_layout() plt.show() Exploring initial conditions of an underdamped pendulum You can also use this website to see demonstrations. These are not mine, but I think the resource is useful. Changing damping coefficient import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # Plotting plt.figure(figsize=(12, 8)) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='Underdamped: b = 1', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() b_underdamped = 2.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) plt.subplot(3, 1, 2) plt.plot(t, theta_underdamped, label='Underdamped: b = 2', color='violet') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() b_underdamped = 3.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_underdamped, label='Underdamped: b = 3', color='red') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show() We see that, as we increase the damping coefficient, underdamped motion approaches to critically damped. Here is another thing. If we continue to increase the damping coefficient, at some point, the graph will disappear (overdamped). The red line below shows the maximum damping I could obtain by increasing the damping coefficient before the graph disappears: Changing pendulum length import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) # Time array t = np.linspace(0, 10, 500) # Plotting plt.figure(figsize=(12, 8)) L = 1.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='L = 1', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() L = 2.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) plt.subplot(3, 1, 2) plt.plot(t, theta_underdamped, label='L = 2', color='violet') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() L = 3.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_underdamped, label='L = 3', color='red') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show() Investigating forced pendulum import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) A_resonance = 1.0 # amplitude of the driving force for resonance A_chaotic = 0.5 # reduced amplitude for chaotic case b = 0.1 # damping coefficient # Natural frequency omega_0 = np.sqrt(g / L) # Time values t = np.linspace(0, 30, 1000) # Time from 0 to 30 seconds # Differential equations for the driven pendulum def model(y, t, A, b, omega): theta, omega = y dtheta_dt = omega domega_dt = -b * omega - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Case 1: Resonance omega_resonance = omega_0 # Driving frequency at resonance initial_conditions = [0.1, 0] # Starting angle and angular velocity solution_resonance = odeint(model, initial_conditions, t, args=(A_resonance, b, omega_resonance)) theta_resonance = solution_resonance[:, 0] omega_resonance_vals = solution_resonance[:, 1] # Case 2: Chaotic Motion omega_chaotic = 1.5 * omega_0 # Non-harmonic driving frequency initial_conditions = [0.1, 0] # Same starting angle and velocity for comparison solution_chaotic = odeint(model, initial_conditions, t, args=(A_chaotic, b, omega_chaotic)) theta_chaotic = solution_chaotic[:, 0] omega_chaotic_vals = solution_chaotic[:, 1] # Plotting fig, ax = plt.subplots(2, 2, figsize=(12, 8)) # Resonance plot ax[0, 0].plot(t, theta_resonance, color='blue') ax[0, 0].set_title('Resonance Case') ax[0, 0].set_xlabel('Time (s)') ax[0, 0].set_ylabel('Angular Displacement (radians)') ax[0, 0].grid() # Chaos plot ax[0, 1].plot(t, theta_chaotic, color='red') ax[0, 1].set_title('Chaotic Case') ax[0, 1].set_xlabel('Time (s)') ax[0, 1].set_ylabel('Angular Displacement (radians)') ax[0, 1].grid() # Phase Diagrams # Resonance Phase Diagram ax[1, 0].plot(theta_resonance[:-1], omega_resonance_vals[:-1], color='blue') ax[1, 0].set_title('Resonance Phase Diagram') ax[1, 0].set_xlabel('Angular Position (radians)') ax[1, 0].set_ylabel('Angular Velocity (rad/s)') ax[1, 0].grid() # Chaos Phase Diagram ax[1, 1].plot(theta_chaotic[:-1], omega_chaotic_vals[:-1], color='red') ax[1, 1].set_title('Chaotic Phase Diagram') ax[1, 1].set_xlabel('Angular Position (radians)') ax[1, 1].set_ylabel('Angular Velocity (rad/s)') ax[1, 1].grid() plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#pendulum-motion-small-angles","text":"The motion of a forced damped pendulum is described by the following second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L}\\sin \\theta = A \\cos(wt) \\] This is a second-order differential equation governing the angular displacement \\(\\theta\\) of a pendulum with damping and driven forces. Here: Notation Description \\(\\theta\\) Angular displacement from the vertical ( equilibrium ) position; measured in radians. \\(\\frac{d^2\\theta}{dt^2}\\) Angular acceleration of the pendulum. \\(b\\) Damping coefficient (which accounts for friction or air resistance). \\(\\frac{d\\theta}{dt}\\) Angular velocity of the pendulum (the rate of change of the angle \\(\\theta\\) ) \\(g\\) Acceleration due to gravity. \\(L\\) The length of the pendulum. \\(A\\cos(\\omega t)\\) Represents the external driving force; \\(A\\) is the amplitude, and \\(\\omega\\) is the angular frequency of the external forcing. For small angles ( \\(\\theta\\) approaching to \\(0\\) or \\(\\theta \\approx 0\\) ), we can use the approximation \\(\\sin(\\theta) \\approx \\theta\\) . With this, the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L}\\sin \\theta = A \\cos(wt) \\implies \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(wt) \\]","title":"Pendulum motion: small angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solving-differential-equation-of-a-damped-pendulum-for-small-angle-approximations","text":"To solve the equation, we first consider the homogeneous part (setting the driving force to zero): \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] This is a standard form for a damped harmonic oscillator. To solve this linear differential equation, we assume a solution of the form: \\[ \\theta(t) = e^{rt} \\] Here, \\(r\\) is the constant we want to determine. The first derivative of our assumed solution is \\(\\frac{d\\theta}{dt} = re^{rt}\\) . The second is \\(\\frac{d^2\\theta}{dt^2} = r^2e^{rt}\\) . Substituting, gives \\[ r^2e^{rt} + b(re^{rt}) + \\frac{g}{L}(e^{rt}) = 0 \\] Factoring out \\(e^{rt}\\) : \\[ e^{rt}(r^2 + br + \\frac{g}{L}) = 0 \\] The term \\(e^{rt}\\) does not contribute any solutions since it is always positive for real values of \\(r\\) . Therefore, we obtain our characteristic equation from the remaining polynomial: \\[ r^2+br+\\frac{g}{L} =0 \\] To find \\(r\\) , we need to solve the above equation: \\[ r = \\frac{-b\\pm \\sqrt{ b^2 -4\\frac{g}{L} }}{2} \\] Where \\(D= b^2 -4\\frac{g}{L}\\) . Roots and behavior: Underdamped Condition: \\(D > 0 \\implies b^2 \\gt 4 \\frac{g}{L}\\) Result: Two distinct real roots, leading to oscillatory motion with gradually decreasing amplitude (oscillations). Physically, this means the pendulum swings back and forth across the vertical position, with the amplitude decreasing over time due to damping. The oscillations gradually lose energy (due to friction or air resistance), resulting in a motion that resembles a sine wave, but one that progressively decays. This is the pendulum we usually think about, i.e., a swinging pendulum that slowly stops swinging as it loses energy. Critically damped Condition: \\(D = 0 \\implies b^2 = 4 \\frac{g}{L}\\) Result: Two identical real roots, leading to the system returning to equilibrium as quickly as possible without oscillating. In this case, the pendulum will move towards its lowest point but won't overshoot or undergo any oscillation. It smoothly comes to rest at the vertical position. Take a door as an example: its damping mechanism shuts the door quickly without bouncing back. Overdamped Condition: \\(D < 0 \\implies b^2 < 4 \\frac{g}{L}\\) Result: Two complex conjugate roots, leading to a non-oscillatory return toward equilibrium. The system takes longer to return than in the critically damped case. Here, the pendulum slowly returns to its resting position without any oscillations, typically taking a longer time to settle compared to the critically damped case. For example, a pendulum that is heavily damped (like a long jump rope acting as a pendulum) that gently settles down without swinging back and forth.","title":"Solving differential equation of a damped pendulum for small-angle approximations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#no-damping","text":"Below there is a diagram comparing three cases: underdamped pendulum motion, motion with no damping, and critically damped motion: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # 1. Underdamped case parameters (b > 0, b^2 < 4g/L) b_underdamped = 1.0 # Damping Coefficient (low but positive) omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * np.cos(omega_d_underdamped * t) # 2. No Damping case parameters (b = 0) b_no_damping = 0.0 # No Damping omega_no_damping = np.sqrt(g / L) theta_no_damping = np.cos(omega_no_damping * t) # Simple harmonic motion # 3. Critically Damped case parameters (b^2 = 4g/L) b_critical = 2.0 * np.sqrt(g / L) # Adjusted for critical damping theta_critical = (1 + b_critical*t) * np.exp(-b_critical / 2 * t) # Critically damped response # Create plots plt.figure(figsize=(12, 10)) # Underdamped Motion Plot plt.subplot(3, 2, 1) plt.plot(t, theta_underdamped, label='Underdamped', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Underdamped Phase Diagram plt.subplot(3, 2, 2) plt.plot(theta_underdamped[:-1], np.diff(theta_underdamped) / np.diff(t), color='blue') plt.title('Underdamped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # No Damping Motion Plot plt.subplot(3, 2, 3) plt.plot(t, theta_no_damping, label='No Damping', color='green') plt.title('Pendulum Motion with No Damping') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # No Damping Phase Diagram plt.subplot(3, 2, 4) plt.plot(theta_no_damping[:-1], np.diff(theta_no_damping) / np.diff(t), color='green') plt.title('No Damping Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Critically Damped Motion Plot plt.subplot(3, 2, 5) plt.plot(t, theta_critical, label='Critically Damped', color='orange') plt.title('Critically Damped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Critically Damped Phase Diagram plt.subplot(3, 2, 6) plt.plot(theta_critical[:-1], np.diff(theta_critical) / np.diff(t), color='orange') plt.title('Critically Damped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Adjust layout plt.tight_layout() plt.show()","title":"No damping"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#underdamped-critically-damped-and-overdamped","text":"The next diagram compares three cases: underdamped, critically damped, and overdamped motion: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # Underdamped case parameters (b^2 > 4g/L) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * np.cos(omega_d_underdamped * t) # Critically damped case parameters (b^2 = 4g/L) b_critically_damped = 2 * np.sqrt(g / L) theta_critically_damped = np.exp(-b_critically_damped / 2 * t) * (1 + (b_critically_damped / 2) * t) # Overdamped case parameters (b^2 < 4g/L) b_overdamped = 3.0 # Choose a value greater than 2*sqrt(g/L) omega_0_overdamped = np.sqrt((b_overdamped / 2) ** 2 - g / L) theta_overdamped = np.exp(-b_overdamped / 2 * t) * (np.cosh(omega_0_overdamped * t) - (b_overdamped / (2 * omega_0_overdamped)) * np.sinh(omega_0_overdamped * t)) # Calculate angular velocities for the phase diagrams omega_underdamped = -b_underdamped / 2 * theta_underdamped - (g / L) * np.sin(theta_underdamped) omega_critically_damped = np.diff(theta_critically_damped) / np.diff(t) # Numerical derivative omega_critically_damped = np.append(omega_critically_damped, omega_critically_damped[-1]) # Append last value for length compatibility omega_overdamped = -b_overdamped / 2 * theta_overdamped + omega_0_overdamped * np.cosh(omega_0_overdamped * t) # Plotting plt.figure(figsize=(12, 12)) # Underdamped plt.subplot(3, 2, 1) plt.plot(t, theta_underdamped, label='Underdamped', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Underdamped Phase Diagram plt.subplot(3, 2, 2) plt.plot(theta_underdamped[:-1], omega_underdamped[:-1], color='blue') plt.title('Underdamped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Critically Damped plt.subplot(3, 2, 3) plt.plot(t, theta_critically_damped, label='Critically Damped', color='orange') plt.title('Critically Damped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Critically Damped Phase Diagram plt.subplot(3, 2, 4) plt.plot(theta_critically_damped[:-1], omega_critically_damped[:-1], color='orange') plt.title('Critically Damped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Overdamped plt.subplot(3, 2, 5) plt.plot(t, theta_overdamped, label='Overdamped', color='green') plt.title('Overdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Overdamped Phase Diagram plt.subplot(3, 2, 6) plt.plot(theta_overdamped[:-1], omega_overdamped[:-1], color='green') plt.title('Overdamped Phase Diagram') plt.xlabel('Angular Position (radians)') plt.ylabel('Angular Velocity (rad/s)') plt.grid() # Adjust layout plt.tight_layout() plt.show()","title":"Underdamped, Critically Damped, and Overdamped"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#exploring-initial-conditions-of-an-underdamped-pendulum","text":"You can also use this website to see demonstrations. These are not mine, but I think the resource is useful.","title":"Exploring initial conditions of an underdamped pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#changing-damping-coefficient","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # Plotting plt.figure(figsize=(12, 8)) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='Underdamped: b = 1', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() b_underdamped = 2.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) plt.subplot(3, 1, 2) plt.plot(t, theta_underdamped, label='Underdamped: b = 2', color='violet') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() b_underdamped = 3.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_underdamped, label='Underdamped: b = 3', color='red') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show() We see that, as we increase the damping coefficient, underdamped motion approaches to critically damped. Here is another thing. If we continue to increase the damping coefficient, at some point, the graph will disappear (overdamped). The red line below shows the maximum damping I could obtain by increasing the damping coefficient before the graph disappears:","title":"Changing damping coefficient"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#changing-pendulum-length","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) # Time array t = np.linspace(0, 10, 500) # Plotting plt.figure(figsize=(12, 8)) L = 1.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='L = 1', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() L = 2.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) plt.subplot(3, 1, 2) plt.plot(t, theta_underdamped, label='L = 2', color='violet') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() L = 3.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_underdamped, label='L = 3', color='red') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show()","title":"Changing pendulum length"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-forced-pendulum","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) A_resonance = 1.0 # amplitude of the driving force for resonance A_chaotic = 0.5 # reduced amplitude for chaotic case b = 0.1 # damping coefficient # Natural frequency omega_0 = np.sqrt(g / L) # Time values t = np.linspace(0, 30, 1000) # Time from 0 to 30 seconds # Differential equations for the driven pendulum def model(y, t, A, b, omega): theta, omega = y dtheta_dt = omega domega_dt = -b * omega - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Case 1: Resonance omega_resonance = omega_0 # Driving frequency at resonance initial_conditions = [0.1, 0] # Starting angle and angular velocity solution_resonance = odeint(model, initial_conditions, t, args=(A_resonance, b, omega_resonance)) theta_resonance = solution_resonance[:, 0] omega_resonance_vals = solution_resonance[:, 1] # Case 2: Chaotic Motion omega_chaotic = 1.5 * omega_0 # Non-harmonic driving frequency initial_conditions = [0.1, 0] # Same starting angle and velocity for comparison solution_chaotic = odeint(model, initial_conditions, t, args=(A_chaotic, b, omega_chaotic)) theta_chaotic = solution_chaotic[:, 0] omega_chaotic_vals = solution_chaotic[:, 1] # Plotting fig, ax = plt.subplots(2, 2, figsize=(12, 8)) # Resonance plot ax[0, 0].plot(t, theta_resonance, color='blue') ax[0, 0].set_title('Resonance Case') ax[0, 0].set_xlabel('Time (s)') ax[0, 0].set_ylabel('Angular Displacement (radians)') ax[0, 0].grid() # Chaos plot ax[0, 1].plot(t, theta_chaotic, color='red') ax[0, 1].set_title('Chaotic Case') ax[0, 1].set_xlabel('Time (s)') ax[0, 1].set_ylabel('Angular Displacement (radians)') ax[0, 1].grid() # Phase Diagrams # Resonance Phase Diagram ax[1, 0].plot(theta_resonance[:-1], omega_resonance_vals[:-1], color='blue') ax[1, 0].set_title('Resonance Phase Diagram') ax[1, 0].set_xlabel('Angular Position (radians)') ax[1, 0].set_ylabel('Angular Velocity (rad/s)') ax[1, 0].grid() # Chaos Phase Diagram ax[1, 1].plot(theta_chaotic[:-1], omega_chaotic_vals[:-1], color='red') ax[1, 1].set_title('Chaotic Phase Diagram') ax[1, 1].set_xlabel('Angular Position (radians)') ax[1, 1].set_ylabel('Angular Velocity (rad/s)') ax[1, 1].grid() plt.tight_layout() plt.show()","title":"Investigating forced pendulum"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius Kepler's Third Law The Kepler's Third Law states that the square of a planet's orbital period is proportional to the cube of the length of the semi-major axis of its orbit . Sounds convoluted. Let's recall some basic concepts from astrodynamics: The orbital period is the amount of time it takes an astronomical object (say, a planet) to complete an orbit (curved trajectory) around another object. Recall that the Kepler's First Law states that the orbit of a planet is an ellipse. So, the semi-major axis of an orbit is then the semi-major axis of the ellipse that this orbit represents. In numerical form, the Kepler's Third Law can be written as follows: \\[ \\boxed{T^2 = \\frac{4\\pi^2}{GM}r^3} \\] Let's derive this formula. Derivation Alright, let's start with the Newton's law of universal gravitation first. It takes the following form: \\[ F = G \\frac{mM}{r^2} \\] where: Notion Description \\(F\\) The force between two masses, \\(m\\) and \\(M\\) \\(G\\) The Newtonian constant of gravitation \\(m\\) The first mass \\(M\\) The second mass \\(r\\) The distance between the centers of the masses Derivation of the Newton's Law of gravitation can be found here . Thanks to the Kepler's first law, we know that the motion of one planet (this is how we will abbreviate \"astronomical object\") relative to its Sun is an ellipse. For now, we will start with circular motion; first, we will write the centripetal force - the force that makes a mass follow a curved mass - with the following formula: \\[ F_{c} = \\frac{mv^2}{r} \\] For circular motion, the gravitational force provides the centripetal force, so we can set these two expressions equal: \\[ \\frac{GMm}{r^2}=\\frac{mv^2}{r} \\implies \\frac{GM}{r}={v^2} \\] The orbital speed \\(v\\) can be related to the orbital period \\(T\\) (the time it takes to complete one full orbit) through the circumference of the orbit. The circumference \\(C\\) of a circular orbit is given by: \\[ C = 2\\pi r \\] The speed can be expressed in terms of period \\(T\\) : \\[ v = \\frac{C}{T} = \\frac{2\\pi r}{T} \\] So, returning back to \\(\\frac{GM}{r}={v^2}\\) and substituting, we get \\[ \\frac{GM}{r}={\\left( \\frac{2\\pi r}{T} \\right)^2} \\implies \\frac{GM}{r}={ \\frac{4\\pi^2 r^2}{T^2}} \\] Multiplying both sides by \\(r\\) : \\[ GM = \\frac{{4\\pi^2 r^3}}{T^2} \\] Finally, rearranging gives us the Kepler's Third Law: \\[ \\boxed{T^2 = \\frac{4\\pi^2}{GM}r^3} \\] This shows that the square of the orbital period \\(T^2\\) is proportional to the cube of the orbital radius \\(r^3\\) : \\[ T^2 \u221d r^3 \\] This formula applies not only for circular motion, but also for elliptic. In this case, \\(r\\) is the semi-major axis of the ellipse . Implications of Kepler's Third Law for Astronomy Calculating planetary masses Kepler's Third Law can be used to determine the mass of a celestial body if the orbital period and distance of its orbiting bodies are known. \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\implies M= \\frac{4\\pi^2r^3}{GT^2} \\] This is particularly valuable in binary star systems, where two stars orbit a common center of mass. By analyzing their orbital periods and distances, astronomers can calculate their masses, enhancing our understanding of stellar evolution and the fundamental properties of stars. Determining distances Kepler's Third Law can also be used to determine the relative distances of celestial bodies. For example, by knowing the orbital period of a planet and applying the law, astronomers can infer its distance from the Sun in units of the semi-major axis (in astronomical units, where 1 AU is the average distance from the Earth to the Sun). Understanding orbital dynamics The relationship encapsulated in Kepler's Third Law provides insights into the stability and behavior of orbits. It predicts how changing a planet's distance from the star affects its orbital period; for example, if a planet were to migrate inward, its orbital period would decrease, affecting climatic and environmental conditions on that planet. Real-World Examples The Moon's orbit around Earth The Moon orbits Earth with an average distance of about \\(384,400\\) km and a period of approximately \\(27.3\\) days. Using Kepler's Third Law, we can check the consistency of these values: Given data: Data Value Period \\(T\\) \\(\\approx 27.3\\) days \\(\\approx 2,359,200\\) seconds Radius \\(r\\) \\(\\approx 384,400\\) km Calculations: Data Value \\(T^2\\) \\(\\approx 5.57\\times10^{12}s^2\\) \\(r^3\\) \\(\\approx 5.67\\times10^{25}m^3\\) Using \\(G\\approx6.674 \\times 10^{-11}m^3kg^{-1}s^{-2}\\) , calculating the expected mass of Earth: \\[ M= \\frac{4\\pi^2r^3}{GT^2} \\approx \\frac{4\\pi^2\\cdot5.67\\times10^{25}}{6.674\\times 10^{-11}\\cdot 5.57 \\times 10^{12}} \\approx 5.97 \\times 10^{24}kg \\] This mass aligns closely with the known mass of Earth, demonstrating the reliability of Kepler's Third Law. Computational mode import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 mass_sun = 1.989e+30 # Mass of the Sun in kilograms mass_earth = 5.972e+24 # Mass of the Earth in kilograms mass_moon = 7.348e+22 # Mass of the Moon in kilograms # Orbital parameters distance_earth = 1.496e+11 # Distance from Sun to Earth in meters (1 AU) distance_moon = 3.844e+8 # Distance from Earth to Moon in meters T_earth = np.sqrt((4 * np.pi**2 * distance_earth**3) / (G * mass_sun)) # Orbital period of Earth T_moon = np.sqrt((4 * np.pi**2 * distance_moon**3) / (G * mass_earth)) # Orbital period of Moon # Simulation parameters num_frames = 180 # Number of frames for animation time = np.linspace(0, T_earth, num_frames) # Position calculations earth_x = distance_earth * np.cos(2 * np.pi * time / T_earth) earth_y = distance_earth * np.sin(2 * np.pi * time / T_earth) moon_x = earth_x + distance_moon * np.cos(2 * np.pi * time / T_moon) moon_y = earth_y + distance_moon * np.sin(2 * np.pi * time / T_moon) # Create figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-1.6e11, 1.6e11) ax.set_ylim(-1.6e11, 1.6e11) ax.set_aspect('equal') ax.set_title(\"Simulation of Circular Orbits\") ax.set_xlabel(\"Distance (m)\") ax.set_ylabel(\"Distance (m)\") # Initialize the Sun, Earth, and Moon sun, = ax.plot(0, 0, 'yo', markersize=12) # Sun in yellow earth, = ax.plot([], [], 'bo', markersize=6) # Earth in blue moon, = ax.plot([], [], 'gray', markersize=4) # Moon in gray # Animation update function def update(frame): # Update Earth position earth.set_data(earth_x[frame], earth_y[frame]) # Update Moon position moon.set_data(moon_x[frame], moon_y[frame]) return earth, moon # Create animation ani = animation.FuncAnimation(fig, update, frames=num_frames, interval=50, blit=True) # To save the animation as a .gif, Uncomment the next line # ani.save('circular_orbits.gif', writer='imagemagick', fps=20) plt.show() Circular orbits import numpy as np import matplotlib.pyplot as plt # Define celestial body parameters (radii in meters for visualization, scaled) celestial_bodies = { 'Sun': {'radius': 0.5, 'color': 'yellow'}, 'Earth': {'radius': 1.0, 'color': 'blue'}, 'Mars': {'radius': 1.5, 'color': 'red'}, 'Jupiter': {'radius': 2.0, 'color': 'orange'}, } # Create an array of angles for the circular orbits angles = np.linspace(0, 2 * np.pi, 360) # Create a plot plt.figure(figsize=(8, 8)) plt.axis('equal') plt.xlim(-2.5, 2.5) plt.ylim(-2.5, 2.5) # Plot the Sun plt.scatter(0, 0, color=celestial_bodies['Sun']['color'], s=300, label='Sun') # Plot orbits and celestial bodies for body, params in celestial_bodies.items(): # Calculate x and y coordinates for the circular orbit x_orbit = params['radius'] * np.cos(angles) y_orbit = params['radius'] * np.sin(angles) # Plot the orbit plt.plot(x_orbit, y_orbit, linestyle='--', color='gray', alpha=0.5) # Plot the celestial body at the perimeter of its orbit plt.scatter(params['radius'], 0, color=params['color'], s=100, label=body) # Add labels and title plt.title('Circular Orbits of Celestial Bodies') plt.xlabel('Distance (arbitrary units)') plt.ylabel('Distance (arbitrary units)') plt.axhline(0, color='black',linewidth=0.5, ls='--') plt.axvline(0, color='black',linewidth=0.5, ls='--') plt.grid(color = 'gray', linestyle = '--', linewidth = 0.5) plt.legend() plt.show() Nasa","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law","text":"The Kepler's Third Law states that the square of a planet's orbital period is proportional to the cube of the length of the semi-major axis of its orbit . Sounds convoluted. Let's recall some basic concepts from astrodynamics: The orbital period is the amount of time it takes an astronomical object (say, a planet) to complete an orbit (curved trajectory) around another object. Recall that the Kepler's First Law states that the orbit of a planet is an ellipse. So, the semi-major axis of an orbit is then the semi-major axis of the ellipse that this orbit represents. In numerical form, the Kepler's Third Law can be written as follows: \\[ \\boxed{T^2 = \\frac{4\\pi^2}{GM}r^3} \\] Let's derive this formula.","title":"Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"Alright, let's start with the Newton's law of universal gravitation first. It takes the following form: \\[ F = G \\frac{mM}{r^2} \\] where: Notion Description \\(F\\) The force between two masses, \\(m\\) and \\(M\\) \\(G\\) The Newtonian constant of gravitation \\(m\\) The first mass \\(M\\) The second mass \\(r\\) The distance between the centers of the masses Derivation of the Newton's Law of gravitation can be found here . Thanks to the Kepler's first law, we know that the motion of one planet (this is how we will abbreviate \"astronomical object\") relative to its Sun is an ellipse. For now, we will start with circular motion; first, we will write the centripetal force - the force that makes a mass follow a curved mass - with the following formula: \\[ F_{c} = \\frac{mv^2}{r} \\] For circular motion, the gravitational force provides the centripetal force, so we can set these two expressions equal: \\[ \\frac{GMm}{r^2}=\\frac{mv^2}{r} \\implies \\frac{GM}{r}={v^2} \\] The orbital speed \\(v\\) can be related to the orbital period \\(T\\) (the time it takes to complete one full orbit) through the circumference of the orbit. The circumference \\(C\\) of a circular orbit is given by: \\[ C = 2\\pi r \\] The speed can be expressed in terms of period \\(T\\) : \\[ v = \\frac{C}{T} = \\frac{2\\pi r}{T} \\] So, returning back to \\(\\frac{GM}{r}={v^2}\\) and substituting, we get \\[ \\frac{GM}{r}={\\left( \\frac{2\\pi r}{T} \\right)^2} \\implies \\frac{GM}{r}={ \\frac{4\\pi^2 r^2}{T^2}} \\] Multiplying both sides by \\(r\\) : \\[ GM = \\frac{{4\\pi^2 r^3}}{T^2} \\] Finally, rearranging gives us the Kepler's Third Law: \\[ \\boxed{T^2 = \\frac{4\\pi^2}{GM}r^3} \\] This shows that the square of the orbital period \\(T^2\\) is proportional to the cube of the orbital radius \\(r^3\\) : \\[ T^2 \u221d r^3 \\] This formula applies not only for circular motion, but also for elliptic. In this case, \\(r\\) is the semi-major axis of the ellipse .","title":"Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-of-keplers-third-law-for-astronomy","text":"","title":"Implications of Kepler's Third Law for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-planetary-masses","text":"Kepler's Third Law can be used to determine the mass of a celestial body if the orbital period and distance of its orbiting bodies are known. \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\implies M= \\frac{4\\pi^2r^3}{GT^2} \\] This is particularly valuable in binary star systems, where two stars orbit a common center of mass. By analyzing their orbital periods and distances, astronomers can calculate their masses, enhancing our understanding of stellar evolution and the fundamental properties of stars.","title":"Calculating planetary masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#determining-distances","text":"Kepler's Third Law can also be used to determine the relative distances of celestial bodies. For example, by knowing the orbital period of a planet and applying the law, astronomers can infer its distance from the Sun in units of the semi-major axis (in astronomical units, where 1 AU is the average distance from the Earth to the Sun).","title":"Determining distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#understanding-orbital-dynamics","text":"The relationship encapsulated in Kepler's Third Law provides insights into the stability and behavior of orbits. It predicts how changing a planet's distance from the star affects its orbital period; for example, if a planet were to migrate inward, its orbital period would decrease, affecting climatic and environmental conditions on that planet.","title":"Understanding orbital dynamics"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-moons-orbit-around-earth","text":"The Moon orbits Earth with an average distance of about \\(384,400\\) km and a period of approximately \\(27.3\\) days. Using Kepler's Third Law, we can check the consistency of these values: Given data: Data Value Period \\(T\\) \\(\\approx 27.3\\) days \\(\\approx 2,359,200\\) seconds Radius \\(r\\) \\(\\approx 384,400\\) km Calculations: Data Value \\(T^2\\) \\(\\approx 5.57\\times10^{12}s^2\\) \\(r^3\\) \\(\\approx 5.67\\times10^{25}m^3\\) Using \\(G\\approx6.674 \\times 10^{-11}m^3kg^{-1}s^{-2}\\) , calculating the expected mass of Earth: \\[ M= \\frac{4\\pi^2r^3}{GT^2} \\approx \\frac{4\\pi^2\\cdot5.67\\times10^{25}}{6.674\\times 10^{-11}\\cdot 5.57 \\times 10^{12}} \\approx 5.97 \\times 10^{24}kg \\] This mass aligns closely with the known mass of Earth, demonstrating the reliability of Kepler's Third Law.","title":"The Moon's orbit around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-mode","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 mass_sun = 1.989e+30 # Mass of the Sun in kilograms mass_earth = 5.972e+24 # Mass of the Earth in kilograms mass_moon = 7.348e+22 # Mass of the Moon in kilograms # Orbital parameters distance_earth = 1.496e+11 # Distance from Sun to Earth in meters (1 AU) distance_moon = 3.844e+8 # Distance from Earth to Moon in meters T_earth = np.sqrt((4 * np.pi**2 * distance_earth**3) / (G * mass_sun)) # Orbital period of Earth T_moon = np.sqrt((4 * np.pi**2 * distance_moon**3) / (G * mass_earth)) # Orbital period of Moon # Simulation parameters num_frames = 180 # Number of frames for animation time = np.linspace(0, T_earth, num_frames) # Position calculations earth_x = distance_earth * np.cos(2 * np.pi * time / T_earth) earth_y = distance_earth * np.sin(2 * np.pi * time / T_earth) moon_x = earth_x + distance_moon * np.cos(2 * np.pi * time / T_moon) moon_y = earth_y + distance_moon * np.sin(2 * np.pi * time / T_moon) # Create figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-1.6e11, 1.6e11) ax.set_ylim(-1.6e11, 1.6e11) ax.set_aspect('equal') ax.set_title(\"Simulation of Circular Orbits\") ax.set_xlabel(\"Distance (m)\") ax.set_ylabel(\"Distance (m)\") # Initialize the Sun, Earth, and Moon sun, = ax.plot(0, 0, 'yo', markersize=12) # Sun in yellow earth, = ax.plot([], [], 'bo', markersize=6) # Earth in blue moon, = ax.plot([], [], 'gray', markersize=4) # Moon in gray # Animation update function def update(frame): # Update Earth position earth.set_data(earth_x[frame], earth_y[frame]) # Update Moon position moon.set_data(moon_x[frame], moon_y[frame]) return earth, moon # Create animation ani = animation.FuncAnimation(fig, update, frames=num_frames, interval=50, blit=True) # To save the animation as a .gif, Uncomment the next line # ani.save('circular_orbits.gif', writer='imagemagick', fps=20) plt.show()","title":"Computational mode"},{"location":"1%20Physics/2%20Gravity/Problem_1/#circular-orbits","text":"import numpy as np import matplotlib.pyplot as plt # Define celestial body parameters (radii in meters for visualization, scaled) celestial_bodies = { 'Sun': {'radius': 0.5, 'color': 'yellow'}, 'Earth': {'radius': 1.0, 'color': 'blue'}, 'Mars': {'radius': 1.5, 'color': 'red'}, 'Jupiter': {'radius': 2.0, 'color': 'orange'}, } # Create an array of angles for the circular orbits angles = np.linspace(0, 2 * np.pi, 360) # Create a plot plt.figure(figsize=(8, 8)) plt.axis('equal') plt.xlim(-2.5, 2.5) plt.ylim(-2.5, 2.5) # Plot the Sun plt.scatter(0, 0, color=celestial_bodies['Sun']['color'], s=300, label='Sun') # Plot orbits and celestial bodies for body, params in celestial_bodies.items(): # Calculate x and y coordinates for the circular orbit x_orbit = params['radius'] * np.cos(angles) y_orbit = params['radius'] * np.sin(angles) # Plot the orbit plt.plot(x_orbit, y_orbit, linestyle='--', color='gray', alpha=0.5) # Plot the celestial body at the perimeter of its orbit plt.scatter(params['radius'], 0, color=params['color'], s=100, label=body) # Add labels and title plt.title('Circular Orbits of Celestial Bodies') plt.xlabel('Distance (arbitrary units)') plt.ylabel('Distance (arbitrary units)') plt.axhline(0, color='black',linewidth=0.5, ls='--') plt.axvline(0, color='black',linewidth=0.5, ls='--') plt.grid(color = 'gray', linestyle = '--', linewidth = 0.5) plt.legend() plt.show() Nasa","title":"Circular orbits"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Definition of Cosmic velocities First Cosmic Velocity (Orbital Velocity) The First Cosmic Velocity , also known as the Orbital Velocity , is the minimum velocity required for an object to maintain a stable orbit around a celestial body without falling back to the surface. An object with orbital velocity moves in a circular path under the influence of gravity. The formula for the Orbital Velocity \\(v_{1}\\) at a height \\(h\\) above the center of a body with mass \\(M\\) and radius \\(R\\) is given by: \\[ v_{1} = \\sqrt{ \\frac{GM}{R+h} } \\] And, for an object on the surface \\(h = 0\\) : \\[ v_{1} = \\sqrt{ \\frac{GM}{R} } \\] In this case, the mass of the moving body is negligible compared to the mass of the celestial body. Second Cosmic Velocity (Escape Velocity) The Second Cosmic Velocity , also known as the Escape Velocity , is the minimum velocity required for an object to break free from a celestial body's gravitational influence and enter space. The formula for the Escape Velocity \\(v_{2}\\) is given by: \\[ v_{2} = \\sqrt{ \\frac{2GM}{R} } \\] Third Cosmic Velocity The Third Cosmic Velocity is the speed required to leave the gravitational influence of a star, such as the Sun. This may also require additional energy to overcome the gravitational pull of other celestial bodies, such as planets. For the third cosmic velocity \\(v_{3}\\) , it's calculated to escape the gravitational pull of the galaxy as well, and can be quite complex as it often depends on the system's dynamics. Generally, it can be expressed in relation to the escape velocity from the solar body's gravitational influence plus the additional velocity needed to overcome the stars in the galaxy. This velocity can be derived by combining the escape velocity from a planet with the necessary velocity to escape the Sun's gravity assuming you are already in orbit around that planet. The formula is: \\[ v_3 = v_2 + v_{\\text{orbital, Sun}} \\] The orbital velocity of the Sum is given by: \\[ v_{\\text{orbital, Sun}} = \\sqrt{\\frac{GM_{Sun}}{D^2}} \\] Where \\(M_{Sun}\\) is the mass of the Sun, and \\(D\\) is the distance from the Sun. Mathematical Derivation and Parameters Deriving the First Cosmic Velocity The gravitational force acting on an object is given by: $$ F = \\frac{GMm}{R^2} $$ The centripetal force required to keep an object moving in a circular path is: $$ F = \\frac{mv^2}{R} $$ Setting these two forces equal provides us the basis for our derivation of the first cosmic velocity: \\[ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\] Canceling \\(m\\) and rearranging gives: \\[ v_1^2 = \\frac{GM}{R} \\implies v_1 = \\sqrt{\\frac{GM}{R}} \\] Deriving the Second Cosmic Velocity For the second cosmic velocity, we can derive it from the conservation of energy. The total mechanical energy must be zero for an escape: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\implies v_2 = \\sqrt{\\frac{2GM}{R}} \\] Parameters Gravitational Constant \\(G\\) \\(G\\approx6.674 \\times 10^{-11}m^3kg^{-1}s^{-2}\\) ; Mass \\(M\\) The mass of the celestial body. The higher the mass of a celestial body, the more energy it requires for an object to resist its gravitational field. Radius \\(R\\) : The radius of the celestial body. The smaller the radius of a celestial body, the less energy it requires for an object to resist its gravitational field. The key parameters that affect cosmic velocities are the mass and radius of the celestial body. Calculating Cosmic Velocities for Different Celestial Bodies Let\u2019s calculate these velocities for Earth, Mars, and Jupiter. Parameter Earth Mars Jupiter Mass \\(M\\) \\(5.972 \\times 10^{24}kg\\) \\(6.4171\u00d710^{23}kg\\) \\(1.898\u00d710^{27}kg\\) Radius \\(R\\) \\(6.371\u00d710^6m\\) \\(3.3895\u00d710^6m\\) \\(6.9911\u00d710^7m\\) Orbital Velocity \\(v_{1}\\) \\(7909.6808\\) m/s \\(3554.7122\\) m/s \\(42567.5063\\) m/s Escape Velocity \\(v_{2}\\) \\(11185.9779\\) m/s \\(5027.1222\\) m/s \\(60199.5447\\) m/s import math def cosmic_velocities(mass, radius): G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 orbital = math.sqrt(G * mass / radius) escape = math.sqrt(2 * G * mass / radius) return [orbital, escape] # Define planet data: name, mass (in kg), radius (in meters) planets = [ {\"name\": \"Earth\", \"mass\": 5.972e24, \"radius\": 6.371e6}, {\"name\": \"Mars\", \"mass\": 6.4171e23, \"radius\": 3.3895e6}, {\"name\": \"Jupiter\", \"mass\": 1.898e27, \"radius\": 6.9911e7}, {\"name\": \"Venus\", \"mass\": 4.8675e24, \"radius\": 6.0518e6}, {\"name\": \"Mercury\", \"mass\": 3.3011e23, \"radius\": 2.4397e6} ] for planet in planets: velocities = cosmic_velocities(planet['mass'], planet['radius']) v_orbital = velocities[0] v_escape = velocities[1] print(f'{planet['name']}:') print(f'Orbital velocity: {v_orbital:.4f} m/s') print(f'Escape velocity: {v_escape:.4f} m/s') print() Earth: Orbital velocity: 7909.6808 m/s Escape velocity: 11185.9779 m/s Mars: Orbital velocity: 3554.7122 m/s Escape velocity: 5027.1222 m/s Jupiter: Orbital velocity: 42567.5063 m/s Escape velocity: 60199.5447 m/s Venus: Orbital velocity: 7326.7869 m/s Escape velocity: 10361.6414 m/s Mercury: Orbital velocity: 3005.1350 m/s Escape velocity: 4249.9027 m/s Earth Orbital Velocity: \\[ v_1 = \\sqrt{\\frac{(6.674 \\times 10^{-11})(5.972 \\times 10^{24})}{6.371 \\times 10^6}} \\approx 7909.6808 \\text{ m/s} \\] Escape Velocity: $$ v_2 = \\sqrt{\\frac{2 \\times (6.674 \\times 10^{-11})(5.972 \\times 10^{24})}{6.371 \\times 10^6}} \\approx 11185.9779 \\text{ m/s} $$ Mars Orbital Velocity: \\[ v_1 = \\sqrt{\\frac{(6.674 \\times 10^{-11})(6.4171 \\times 10^{23})}{3.3895 \\times 10^6}} \\approx 3554.7122 \\text{ m/s} \\] Escape Velocity: \\[ v_2 = \\sqrt{\\frac{2 \\times (6.674 \\times 10^{-11})(6.4171 \\times 10^{23})}{3.3895 \\times 10^6}} \\approx 5027.1222 \\text{ m/s} \\] Jupiter Orbital Velocity: \\[ v_1 = \\sqrt{\\frac{(6.674 \\times 10^{-11})(1.898 \\times 10^{27})}{6.9911 \\times 10^7}} \\approx 42567.5063 \\text{ m/s} \\] Escape Velocity: \\[ v_2 = \\sqrt{\\frac{2 \\times (6.674 \\times 10^{-11})(1.898 \\times 10^{27})}{6.9911 \\times 10^7}} \\approx 60199.5447 \\text{ m/s} \\] Importance in Space Exploration Launching Satellites : The first cosmic velocity (orbital velocity) is fundamental in placing satellites into stable orbits. Understanding it allows engineers to calculate the necessary thrust and trajectory to achieve the desired orbit. Missions to Other Planets : The second cosmic velocity is critical for missions that need to escape Earth's gravity and travel to other celestial bodies. A spacecraft must achieve this velocity to leave Earth and enter interplanetary space. Interstellar Travel : The third cosmic velocity gives insight into escaping a solar system's gravitational pull, which is essential for potential interstellar travel. Exploring technologies like nuclear propulsion or solar sails may eventually allow us to reach these speeds. Dependency graph Dependency graph: import numpy as np import matplotlib.pyplot as plt import pandas as pd # Constants G = 6.67430e-11 # Gravitational constant M_sun = 1.989e30 # Mass of the Sun (needed for orbital calculations) # Planet data planets = pd.DataFrame({ 'name': ['Earth', 'Mars', 'Jupiter'], 'radius': [6.371e6, 3.389e6, 6.9911e7], 'mass': [5.972e24, 6.417e23, 1.898e27] }) # Create orbital velocity vs. radius graph orbital_velocities = [] for radius in planets['radius']: orbital_velocities.append(np.sqrt(G * M_sun / radius)) planets['orbital_velocity'] = orbital_velocities # Create escape velocity vs. radius graph escape_velocities_radius = [] for radius in planets['radius']: escape_velocities_radius.append(np.sqrt(2 * G * M_sun / radius)) planets['escape_velocity_radius'] = escape_velocities_radius # Create orbital velocity vs. mass graph orbital_velocities_mass=[] for mass in planets['mass']: orbital_velocities_mass.append(np.sqrt(G*M_sun/planets['radius'].iloc[planets['mass'].values == mass].values)) planets['orbital_velocity_mass'] = orbital_velocities_mass # Create escape velocity vs. mass graph escape_velocities_mass = [] for mass in planets['mass']: escape_velocities_mass.append(np.sqrt(2 * G * mass / planets['radius'].iloc[planets['mass'].values == mass].values)) planets['escape_velocity_mass'] = escape_velocities_mass # Plotting fig, axes = plt.subplots(2, 2, figsize=(12, 8)) fig.suptitle('Orbital and Escape Velocities vs. Planet Properties') axes[0, 0].plot(planets['radius'], planets['orbital_velocity'], marker='o') axes[0, 0].set_xlabel('Planet Radius (m)') axes[0, 0].set_ylabel('Orbital Velocity (m/s)') axes[0, 0].set_title('Orbital Velocity vs. Planet Radius') axes[0, 0].set_xscale('log') axes[0, 0].set_yscale('log') axes[0, 0].grid(True) for i, row in planets.iterrows(): axes[0, 0].annotate(row['name'], (row['radius'], row['orbital_velocity'])) axes[0,0].set_xticks(planets['radius'].values) axes[0, 1].plot(planets['mass'], planets['orbital_velocity_mass'], marker='o') axes[0, 1].set_xlabel('Planet Mass (kg)') axes[0, 1].set_ylabel('Orbital Velocity (m/s)') axes[0, 1].set_title('Orbital Velocity vs. Planet Mass') axes[0, 1].set_xscale('log') axes[0, 1].set_yscale('log') axes[0, 1].grid(True) for i, row in planets.iterrows(): axes[0, 1].annotate(row['name'], (row['mass'], row['orbital_velocity_mass'])) axes[1, 0].plot(planets['radius'], planets['escape_velocity_radius'], marker='o') axes[1, 0].set_xlabel('Planet Radius (m)') axes[1, 0].set_ylabel('Escape Velocity (m/s)') axes[1, 0].set_title('Escape Velocity vs. Planet Radius') axes[1, 0].set_xscale('log') axes[1, 0].set_yscale('log') axes[1, 0].grid(True) for i, row in planets.iterrows(): axes[1, 0].annotate(row['name'], (row['radius'], row['escape_velocity_radius'])) axes[1, 1].plot(planets['mass'], planets['escape_velocity_mass'], marker='o') axes[1, 1].set_xlabel('Planet Mass (kg)') axes[1, 1].set_ylabel('Escape Velocity (m/s)') axes[1, 1].set_title('Escape Velocity vs. Planet Mass') axes[1, 1].set_xscale('log') axes[1, 1].set_yscale('log') axes[1, 1].grid(True) for i, row in planets.iterrows(): axes[1, 1].annotate(row['name'], (row['mass'], row['escape_velocity_mass'])) plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definition-of-cosmic-velocities","text":"","title":"Definition of Cosmic velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"The First Cosmic Velocity , also known as the Orbital Velocity , is the minimum velocity required for an object to maintain a stable orbit around a celestial body without falling back to the surface. An object with orbital velocity moves in a circular path under the influence of gravity. The formula for the Orbital Velocity \\(v_{1}\\) at a height \\(h\\) above the center of a body with mass \\(M\\) and radius \\(R\\) is given by: \\[ v_{1} = \\sqrt{ \\frac{GM}{R+h} } \\] And, for an object on the surface \\(h = 0\\) : \\[ v_{1} = \\sqrt{ \\frac{GM}{R} } \\] In this case, the mass of the moving body is negligible compared to the mass of the celestial body.","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The Second Cosmic Velocity , also known as the Escape Velocity , is the minimum velocity required for an object to break free from a celestial body's gravitational influence and enter space. The formula for the Escape Velocity \\(v_{2}\\) is given by: \\[ v_{2} = \\sqrt{ \\frac{2GM}{R} } \\]","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"The Third Cosmic Velocity is the speed required to leave the gravitational influence of a star, such as the Sun. This may also require additional energy to overcome the gravitational pull of other celestial bodies, such as planets. For the third cosmic velocity \\(v_{3}\\) , it's calculated to escape the gravitational pull of the galaxy as well, and can be quite complex as it often depends on the system's dynamics. Generally, it can be expressed in relation to the escape velocity from the solar body's gravitational influence plus the additional velocity needed to overcome the stars in the galaxy. This velocity can be derived by combining the escape velocity from a planet with the necessary velocity to escape the Sun's gravity assuming you are already in orbit around that planet. The formula is: \\[ v_3 = v_2 + v_{\\text{orbital, Sun}} \\] The orbital velocity of the Sum is given by: \\[ v_{\\text{orbital, Sun}} = \\sqrt{\\frac{GM_{Sun}}{D^2}} \\] Where \\(M_{Sun}\\) is the mass of the Sun, and \\(D\\) is the distance from the Sun.","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivation-and-parameters","text":"","title":"Mathematical Derivation and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deriving-the-first-cosmic-velocity","text":"The gravitational force acting on an object is given by: $$ F = \\frac{GMm}{R^2} $$ The centripetal force required to keep an object moving in a circular path is: $$ F = \\frac{mv^2}{R} $$ Setting these two forces equal provides us the basis for our derivation of the first cosmic velocity: \\[ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\] Canceling \\(m\\) and rearranging gives: \\[ v_1^2 = \\frac{GM}{R} \\implies v_1 = \\sqrt{\\frac{GM}{R}} \\]","title":"Deriving the First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deriving-the-second-cosmic-velocity","text":"For the second cosmic velocity, we can derive it from the conservation of energy. The total mechanical energy must be zero for an escape: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\implies v_2 = \\sqrt{\\frac{2GM}{R}} \\]","title":"Deriving the Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters","text":"Gravitational Constant \\(G\\) \\(G\\approx6.674 \\times 10^{-11}m^3kg^{-1}s^{-2}\\) ; Mass \\(M\\) The mass of the celestial body. The higher the mass of a celestial body, the more energy it requires for an object to resist its gravitational field. Radius \\(R\\) : The radius of the celestial body. The smaller the radius of a celestial body, the less energy it requires for an object to resist its gravitational field. The key parameters that affect cosmic velocities are the mass and radius of the celestial body.","title":"Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculating-cosmic-velocities-for-different-celestial-bodies","text":"Let\u2019s calculate these velocities for Earth, Mars, and Jupiter. Parameter Earth Mars Jupiter Mass \\(M\\) \\(5.972 \\times 10^{24}kg\\) \\(6.4171\u00d710^{23}kg\\) \\(1.898\u00d710^{27}kg\\) Radius \\(R\\) \\(6.371\u00d710^6m\\) \\(3.3895\u00d710^6m\\) \\(6.9911\u00d710^7m\\) Orbital Velocity \\(v_{1}\\) \\(7909.6808\\) m/s \\(3554.7122\\) m/s \\(42567.5063\\) m/s Escape Velocity \\(v_{2}\\) \\(11185.9779\\) m/s \\(5027.1222\\) m/s \\(60199.5447\\) m/s import math def cosmic_velocities(mass, radius): G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 orbital = math.sqrt(G * mass / radius) escape = math.sqrt(2 * G * mass / radius) return [orbital, escape] # Define planet data: name, mass (in kg), radius (in meters) planets = [ {\"name\": \"Earth\", \"mass\": 5.972e24, \"radius\": 6.371e6}, {\"name\": \"Mars\", \"mass\": 6.4171e23, \"radius\": 3.3895e6}, {\"name\": \"Jupiter\", \"mass\": 1.898e27, \"radius\": 6.9911e7}, {\"name\": \"Venus\", \"mass\": 4.8675e24, \"radius\": 6.0518e6}, {\"name\": \"Mercury\", \"mass\": 3.3011e23, \"radius\": 2.4397e6} ] for planet in planets: velocities = cosmic_velocities(planet['mass'], planet['radius']) v_orbital = velocities[0] v_escape = velocities[1] print(f'{planet['name']}:') print(f'Orbital velocity: {v_orbital:.4f} m/s') print(f'Escape velocity: {v_escape:.4f} m/s') print() Earth: Orbital velocity: 7909.6808 m/s Escape velocity: 11185.9779 m/s Mars: Orbital velocity: 3554.7122 m/s Escape velocity: 5027.1222 m/s Jupiter: Orbital velocity: 42567.5063 m/s Escape velocity: 60199.5447 m/s Venus: Orbital velocity: 7326.7869 m/s Escape velocity: 10361.6414 m/s Mercury: Orbital velocity: 3005.1350 m/s Escape velocity: 4249.9027 m/s","title":"Calculating Cosmic Velocities for Different Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth","text":"Orbital Velocity: \\[ v_1 = \\sqrt{\\frac{(6.674 \\times 10^{-11})(5.972 \\times 10^{24})}{6.371 \\times 10^6}} \\approx 7909.6808 \\text{ m/s} \\] Escape Velocity: $$ v_2 = \\sqrt{\\frac{2 \\times (6.674 \\times 10^{-11})(5.972 \\times 10^{24})}{6.371 \\times 10^6}} \\approx 11185.9779 \\text{ m/s} $$","title":"Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars","text":"Orbital Velocity: \\[ v_1 = \\sqrt{\\frac{(6.674 \\times 10^{-11})(6.4171 \\times 10^{23})}{3.3895 \\times 10^6}} \\approx 3554.7122 \\text{ m/s} \\] Escape Velocity: \\[ v_2 = \\sqrt{\\frac{2 \\times (6.674 \\times 10^{-11})(6.4171 \\times 10^{23})}{3.3895 \\times 10^6}} \\approx 5027.1222 \\text{ m/s} \\]","title":"Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiter","text":"Orbital Velocity: \\[ v_1 = \\sqrt{\\frac{(6.674 \\times 10^{-11})(1.898 \\times 10^{27})}{6.9911 \\times 10^7}} \\approx 42567.5063 \\text{ m/s} \\] Escape Velocity: \\[ v_2 = \\sqrt{\\frac{2 \\times (6.674 \\times 10^{-11})(1.898 \\times 10^{27})}{6.9911 \\times 10^7}} \\approx 60199.5447 \\text{ m/s} \\]","title":"Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"Launching Satellites : The first cosmic velocity (orbital velocity) is fundamental in placing satellites into stable orbits. Understanding it allows engineers to calculate the necessary thrust and trajectory to achieve the desired orbit. Missions to Other Planets : The second cosmic velocity is critical for missions that need to escape Earth's gravity and travel to other celestial bodies. A spacecraft must achieve this velocity to leave Earth and enter interplanetary space. Interstellar Travel : The third cosmic velocity gives insight into escaping a solar system's gravitational pull, which is essential for potential interstellar travel. Exploring technologies like nuclear propulsion or solar sails may eventually allow us to reach these speeds.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#dependency-graph","text":"Dependency graph: import numpy as np import matplotlib.pyplot as plt import pandas as pd # Constants G = 6.67430e-11 # Gravitational constant M_sun = 1.989e30 # Mass of the Sun (needed for orbital calculations) # Planet data planets = pd.DataFrame({ 'name': ['Earth', 'Mars', 'Jupiter'], 'radius': [6.371e6, 3.389e6, 6.9911e7], 'mass': [5.972e24, 6.417e23, 1.898e27] }) # Create orbital velocity vs. radius graph orbital_velocities = [] for radius in planets['radius']: orbital_velocities.append(np.sqrt(G * M_sun / radius)) planets['orbital_velocity'] = orbital_velocities # Create escape velocity vs. radius graph escape_velocities_radius = [] for radius in planets['radius']: escape_velocities_radius.append(np.sqrt(2 * G * M_sun / radius)) planets['escape_velocity_radius'] = escape_velocities_radius # Create orbital velocity vs. mass graph orbital_velocities_mass=[] for mass in planets['mass']: orbital_velocities_mass.append(np.sqrt(G*M_sun/planets['radius'].iloc[planets['mass'].values == mass].values)) planets['orbital_velocity_mass'] = orbital_velocities_mass # Create escape velocity vs. mass graph escape_velocities_mass = [] for mass in planets['mass']: escape_velocities_mass.append(np.sqrt(2 * G * mass / planets['radius'].iloc[planets['mass'].values == mass].values)) planets['escape_velocity_mass'] = escape_velocities_mass # Plotting fig, axes = plt.subplots(2, 2, figsize=(12, 8)) fig.suptitle('Orbital and Escape Velocities vs. Planet Properties') axes[0, 0].plot(planets['radius'], planets['orbital_velocity'], marker='o') axes[0, 0].set_xlabel('Planet Radius (m)') axes[0, 0].set_ylabel('Orbital Velocity (m/s)') axes[0, 0].set_title('Orbital Velocity vs. Planet Radius') axes[0, 0].set_xscale('log') axes[0, 0].set_yscale('log') axes[0, 0].grid(True) for i, row in planets.iterrows(): axes[0, 0].annotate(row['name'], (row['radius'], row['orbital_velocity'])) axes[0,0].set_xticks(planets['radius'].values) axes[0, 1].plot(planets['mass'], planets['orbital_velocity_mass'], marker='o') axes[0, 1].set_xlabel('Planet Mass (kg)') axes[0, 1].set_ylabel('Orbital Velocity (m/s)') axes[0, 1].set_title('Orbital Velocity vs. Planet Mass') axes[0, 1].set_xscale('log') axes[0, 1].set_yscale('log') axes[0, 1].grid(True) for i, row in planets.iterrows(): axes[0, 1].annotate(row['name'], (row['mass'], row['orbital_velocity_mass'])) axes[1, 0].plot(planets['radius'], planets['escape_velocity_radius'], marker='o') axes[1, 0].set_xlabel('Planet Radius (m)') axes[1, 0].set_ylabel('Escape Velocity (m/s)') axes[1, 0].set_title('Escape Velocity vs. Planet Radius') axes[1, 0].set_xscale('log') axes[1, 0].set_yscale('log') axes[1, 0].grid(True) for i, row in planets.iterrows(): axes[1, 0].annotate(row['name'], (row['radius'], row['escape_velocity_radius'])) axes[1, 1].plot(planets['mass'], planets['escape_velocity_mass'], marker='o') axes[1, 1].set_xlabel('Planet Mass (kg)') axes[1, 1].set_ylabel('Escape Velocity (m/s)') axes[1, 1].set_title('Escape Velocity vs. Planet Mass') axes[1, 1].set_xscale('log') axes[1, 1].set_yscale('log') axes[1, 1].grid(True) for i, row in planets.iterrows(): axes[1, 1].annotate(row['name'], (row['mass'], row['escape_velocity_mass'])) plt.tight_layout() plt.show()","title":"Dependency graph"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Analyzing the possible trajectories of a payload released near Earth requires a careful consideration of the initial conditions and the forces acting on it. A simple \"parabolic\" trajectory, often taught in introductory physics, is a simplified approximation. The real trajectory can be elliptical, hyperbolic, or even a complex combination depending on the payload's initial velocity vector relative to the Earth. Step 1: Defining the Physical Context The motion of a payload released from a moving rocket near Earth is governed by gravity and the initial velocity imparted by the rocket. The possible trajectories follow conic sections: Elliptical (bound orbit) Parabolic (escape trajectory) Hyperbolic (unbound trajectory) The trajectory classification depends on the specific energy of the payload: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: \\(v\\) is the velocity magnitude, \\(\u03bc=GM\\) is Earth's standard gravitational parameter ( \\(G\\) is the gravitational constant, \\(M\\) is Earth's mass), \\(r\\) is the initial radial distance from Earth's center. The conditions for trajectory classification: Bound Elliptical Orbit : \\(\\varepsilon < 0\\) Parabolic Escape : \\(\\varepsilon = 0\\) Hyperbolic Escape : \\(\u03b5>0\\) Energy Condition Eccentricity Trajectory \\(\u03b5<0\\) \\(0\u2264e<1\\) Elliptical \\(\u03b5=0\\) \\(e=1\\) Parabolic \\(\u03b5>0\\) \\(e>1\\) Hyperbolic Step 2: Equations of Motion Newton's Law of Gravitation governs the payload\u2019s acceleration: \\[ \\mathbf{a} = -\\frac{\\mu}{r^2} \\hat{r} \\] where \\(\\hat{r}\\) is the unit vector pointing radially outward. The velocity components in a general two-dimensional orbital plane are: \\[ \\frac{dv_r}{dt} = \\frac{h^2}{r^3} - \\frac{\\mu}{r^2} \\] \\[ \\frac{dv_\\theta}{dt} = -\\frac{v_r v_\\theta}{r} \\] where: \\(h=rv_{\\theta}\\) is the specific angular momentum, \\(v_r\\) and \\(v_\\theta\\) are the radial and tangential velocity components. Step 3: Computing the Trajectory Numerically For numerical simulations, we use orbital integration based on the discretized equations: Define initial conditions: \\[ r_0,\\quad v_r0,\\quad v_\\theta0 \\] Time-step integration using numerical methods (e.g., Runge-Kutta): \\[ r_{n+1} = r_n + v_{rn} \\Delta t \\] \\[ v_{rn+1} = v_{rn} + \\left(\\frac{h_n^2}{r_n^3} - \\frac{\\mu}{r_n^2} \\right) \\Delta t \\] \\[ v_{\\theta n+1} = v_{\\theta n} - \\frac{v_{rn} v_{\\theta n}}{r_n} \\Delta t \\] Step 4: Applications and Implications Orbital Insertion : If the payload is released with the right speed and direction, it can be placed in a stable orbit. Reentry Scenarios : If the speed is low and the altitude is not high enough, it will fall back to Earth due to drag. Escape Trajectory : If \\(v \\geq v_{\\text{escape}}\\) , the payload will enter an unbound trajectory, escaping Earth\u2019s gravitational influence. Escape velocity is given by: \\[ v_{\\text{escape}} = \\sqrt{\\frac{2\\mu}{r}} \\] For a release near Low Earth Orbit (~400 km altitude, r \u2248 6778 km) : \\[ v_{\\text{escape}} \\approx 11.2 \\text{ km/s} \\] Computational model import numpy as np import matplotlib.pyplot as plt from matplotlib.patches import Circle # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_earth = 6.371e6 # m mu = G * M # Initial conditions (release point) r0 = R_earth + 400e3 # 400 km altitude theta0 = 0 def compute_trajectory(v0, theta0, max_time=3e4, dt=60): \"\"\"Compute trajectory using polar coordinate equations\"\"\" # Initial state vector [r, theta, vr, vtheta] state = np.array([r0, theta0, v0 * np.sin(theta0), v0 * np.cos(theta0) / r0]) # Storage positions = [] # Time stepping for t in np.arange(0, max_time, dt): r, theta, vr, vtheta = state # Store position (convert to Cartesian) x = r * np.cos(theta) y = r * np.sin(theta) positions.append((x, y)) # Break if collision occurs if r <= R_earth: break # Derivatives drdt = vr dthetadt = vtheta dvrdt = r * vtheta**2 - mu/r**2 dvthetadt = -2 * vr * vtheta / r # Euler integration (for simplicity - use RK4 for real missions) state = state + np.array([drdt, dthetadt, dvrdt, dvthetadt]) * dt return np.array(positions) # Velocity thresholds v_circular = np.sqrt(mu/r0) v_escape = np.sqrt(2*mu/r0) # Compute trajectories elliptical_traj = compute_trajectory(0.9 * v_escape, np.pi/4) parabolic_traj = compute_trajectory(v_escape, np.pi/4) hyperbolic_traj = compute_trajectory(1.1 * v_escape, np.pi/4) # Plotting plt.figure(figsize=(10, 8)) ax = plt.gca() # Earth earth = Circle((0, 0), R_earth, color='#1f77b4', alpha=0.9) ax.add_patch(earth) # Trajectories plt.plot(elliptical_traj[:,0], elliptical_traj[:,1], 'g-', label=f'Elliptical ($v_0 = 0.9v_{{esc}}$ = {0.9*v_escape/1000:.1f} km/s)') plt.plot(parabolic_traj[:,0], parabolic_traj[:,1], 'b--', label=f'Parabolic ($v_0 = v_{{esc}}$ = {v_escape/1000:.1f} km/s)') plt.plot(hyperbolic_traj[:,0], hyperbolic_traj[:,1], 'r:', label=f'Hyperbolic ($v_0 = 1.1v_{{esc}}$ = {1.1*v_escape/1000:.1f} km/s)') # Release point plt.plot(r0 * np.cos(np.pi/4), r0 * np.sin(np.pi/4), 'k*', markersize=15) # Formatting plt.title('Payload Trajectories from 400 km Altitude', pad=20) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.legend(loc='upper right') plt.grid(True) plt.axis('equal') plt.xlim(-10*r0, 10*r0) plt.ylim(-10*r0, 10*r0) plt.tight_layout() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-1-defining-the-physical-context","text":"The motion of a payload released from a moving rocket near Earth is governed by gravity and the initial velocity imparted by the rocket. The possible trajectories follow conic sections: Elliptical (bound orbit) Parabolic (escape trajectory) Hyperbolic (unbound trajectory) The trajectory classification depends on the specific energy of the payload: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: \\(v\\) is the velocity magnitude, \\(\u03bc=GM\\) is Earth's standard gravitational parameter ( \\(G\\) is the gravitational constant, \\(M\\) is Earth's mass), \\(r\\) is the initial radial distance from Earth's center. The conditions for trajectory classification: Bound Elliptical Orbit : \\(\\varepsilon < 0\\) Parabolic Escape : \\(\\varepsilon = 0\\) Hyperbolic Escape : \\(\u03b5>0\\) Energy Condition Eccentricity Trajectory \\(\u03b5<0\\) \\(0\u2264e<1\\) Elliptical \\(\u03b5=0\\) \\(e=1\\) Parabolic \\(\u03b5>0\\) \\(e>1\\) Hyperbolic","title":"Step 1: Defining the Physical Context"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-2-equations-of-motion","text":"Newton's Law of Gravitation governs the payload\u2019s acceleration: \\[ \\mathbf{a} = -\\frac{\\mu}{r^2} \\hat{r} \\] where \\(\\hat{r}\\) is the unit vector pointing radially outward. The velocity components in a general two-dimensional orbital plane are: \\[ \\frac{dv_r}{dt} = \\frac{h^2}{r^3} - \\frac{\\mu}{r^2} \\] \\[ \\frac{dv_\\theta}{dt} = -\\frac{v_r v_\\theta}{r} \\] where: \\(h=rv_{\\theta}\\) is the specific angular momentum, \\(v_r\\) and \\(v_\\theta\\) are the radial and tangential velocity components.","title":"Step 2: Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-3-computing-the-trajectory-numerically","text":"For numerical simulations, we use orbital integration based on the discretized equations: Define initial conditions: \\[ r_0,\\quad v_r0,\\quad v_\\theta0 \\] Time-step integration using numerical methods (e.g., Runge-Kutta): \\[ r_{n+1} = r_n + v_{rn} \\Delta t \\] \\[ v_{rn+1} = v_{rn} + \\left(\\frac{h_n^2}{r_n^3} - \\frac{\\mu}{r_n^2} \\right) \\Delta t \\] \\[ v_{\\theta n+1} = v_{\\theta n} - \\frac{v_{rn} v_{\\theta n}}{r_n} \\Delta t \\]","title":"Step 3: Computing the Trajectory Numerically"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-4-applications-and-implications","text":"Orbital Insertion : If the payload is released with the right speed and direction, it can be placed in a stable orbit. Reentry Scenarios : If the speed is low and the altitude is not high enough, it will fall back to Earth due to drag. Escape Trajectory : If \\(v \\geq v_{\\text{escape}}\\) , the payload will enter an unbound trajectory, escaping Earth\u2019s gravitational influence. Escape velocity is given by: \\[ v_{\\text{escape}} = \\sqrt{\\frac{2\\mu}{r}} \\] For a release near Low Earth Orbit (~400 km altitude, r \u2248 6778 km) : \\[ v_{\\text{escape}} \\approx 11.2 \\text{ km/s} \\]","title":"Step 4: Applications and Implications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#computational-model","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.patches import Circle # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_earth = 6.371e6 # m mu = G * M # Initial conditions (release point) r0 = R_earth + 400e3 # 400 km altitude theta0 = 0 def compute_trajectory(v0, theta0, max_time=3e4, dt=60): \"\"\"Compute trajectory using polar coordinate equations\"\"\" # Initial state vector [r, theta, vr, vtheta] state = np.array([r0, theta0, v0 * np.sin(theta0), v0 * np.cos(theta0) / r0]) # Storage positions = [] # Time stepping for t in np.arange(0, max_time, dt): r, theta, vr, vtheta = state # Store position (convert to Cartesian) x = r * np.cos(theta) y = r * np.sin(theta) positions.append((x, y)) # Break if collision occurs if r <= R_earth: break # Derivatives drdt = vr dthetadt = vtheta dvrdt = r * vtheta**2 - mu/r**2 dvthetadt = -2 * vr * vtheta / r # Euler integration (for simplicity - use RK4 for real missions) state = state + np.array([drdt, dthetadt, dvrdt, dvthetadt]) * dt return np.array(positions) # Velocity thresholds v_circular = np.sqrt(mu/r0) v_escape = np.sqrt(2*mu/r0) # Compute trajectories elliptical_traj = compute_trajectory(0.9 * v_escape, np.pi/4) parabolic_traj = compute_trajectory(v_escape, np.pi/4) hyperbolic_traj = compute_trajectory(1.1 * v_escape, np.pi/4) # Plotting plt.figure(figsize=(10, 8)) ax = plt.gca() # Earth earth = Circle((0, 0), R_earth, color='#1f77b4', alpha=0.9) ax.add_patch(earth) # Trajectories plt.plot(elliptical_traj[:,0], elliptical_traj[:,1], 'g-', label=f'Elliptical ($v_0 = 0.9v_{{esc}}$ = {0.9*v_escape/1000:.1f} km/s)') plt.plot(parabolic_traj[:,0], parabolic_traj[:,1], 'b--', label=f'Parabolic ($v_0 = v_{{esc}}$ = {v_escape/1000:.1f} km/s)') plt.plot(hyperbolic_traj[:,0], hyperbolic_traj[:,1], 'r:', label=f'Hyperbolic ($v_0 = 1.1v_{{esc}}$ = {1.1*v_escape/1000:.1f} km/s)') # Release point plt.plot(r0 * np.cos(np.pi/4), r0 * np.sin(np.pi/4), 'k*', markersize=15) # Formatting plt.title('Payload Trajectories from 400 km Altitude', pad=20) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.legend(loc='upper right') plt.grid(True) plt.axis('equal') plt.xlim(-10*r0, 10*r0) plt.ylim(-10*r0, 10*r0) plt.tight_layout() plt.show()","title":"Computational model"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}