{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Deriving basic formulas of the projectile motion Suppose a projectile is launched at an angle \\(\\theta\\) above the horizontal with an initial velocity \\(v_{0}\\) . For this section, assume no air resistance . Horizontal motion ( \\(x\\) -direction) In the absence of air resistance, there is no horizontal force acting on the projectile: \\[ F_{x} = 0 \\] Based on the Second Newton's Law of Motion: \\[ \\vec{F} = m\\vec{a} \\] Therefore, \\[ m a_{x} = 0 \\implies \\frac{d^2x}{dt^2}m=0 \\] Since the projectile does not accelerate on the \\(x\\) -axis, its immediate velocity (the first derivative of path) equals to the initial velocity with which the projectile has been launched in the first place: \\[ \\frac{dx}{dt} = v_{0x} \\] The \\(x\\) -component of the initial velocity is \\[ v_{0x} = v_{0}\\cos(\\theta) \\] Therefore, the equation of motion of the projectile on the \\(x\\) -axis can be described with the following equation: $$ \\boxed{\\frac{dt}{dx} = v_{0}\\cos(\\theta)} $$ Where \\(\\theta\\) is the launch angle of the projectile. To find the \\(x\\) -component of the position of the projectile at time \\(t\\) , we need to solve this equation for \\(x\\) . Solving the above differential equation will give us the following: \\[ x(t) = v_{0}\\cos(\\theta)t + C_{1} \\] To find \\(C_{1}\\) , set the initial condition \\(x(0) = 0\\) (the path at time \\(0\\) is, of course, \\(0\\) ), and therefore \\[ C_{1} = 0 \\] Thus, \\[ \\boxed{x(t) = v_{0}\\cos(\\theta)t} \\] This equation will give us the position of the projectile at the time \\(t\\) . Vertical motion ( \\(y\\) -direction) The only force acting vertically is the force of gravity : \\[ F_{y}=-mg \\] The projectile doesn't experience any other acceleration and moves until it hits the ground due to gravity. Therefore, the \\(y\\) -component of the projectile motion can be described with the following equation: \\[ \\boxed{\\frac{dy}{dt} = v_{0}\\sin(\\theta)-gt} \\] Where \\(v_{0}\\sin(\\theta)\\) is the \\(y\\) -component of the initial velocity of the projectile, and \\(g\\) is the acceleration due to gravity (i.e., \\(\\frac{d^2y}{dt^2} = -g\\) ). This gives us \\[ \\boxed{y(t)=v_{0}\\sin(\\theta)t -\\frac{1}{2}gt^2} \\] When the projectile hits the ground To find when the projectile hits the ground, we set \\(y(t)=0\\) (altitude zero): \\[ 0=v_{0}\\sin(\\theta)t -\\frac{1}{2}gt^2 \\] Rearranging items gives us: \\[ -\\frac{1}{2}gt^2 + v_{0}\\sin(\\theta) = 0 \\] Solving the quadratic equation: \\(D=(v_{0}\\sin(\\theta))^2\\) \\(t_{1} = \\frac{-v_{0}\\sin(\\theta)+v_{0}\\sin(\\theta)}{-1g} = \\frac{0}{-g} =0\\) - when the projectile is launched; \\(t_{2}=\\frac{-v_{0}\\sin(\\theta)-v_{0}\\sin(\\theta)}{-g}=\\frac{2v_{0}\\sin(\\theta)}{g}\\) So that, the total flight time of a projectile launched with the velocity \\(v_{0}\\) at the angle \\(\\theta\\) : \\[ \\boxed{t_{f}=\\frac{2v_{0}\\sin(\\theta)}{g}} \\] The horizontal range The range that the projectile passes, i.e., the horizontal distance traveled when \\(t=t_{f}\\) , can be found by the formula: \\[R=v_{0x}(t_{f})=v_{0}\\cos(\\theta)\\frac{2v_{0}\\sin(\\theta)}{g}=\\frac{2v_{0}^2 \\left( \\frac{1}{2} \\sin(2\\theta)\\right) }{g}=\\frac{v_{0}^2\\sin(2\\theta) }{g}\\] \\[\\boxed{R=\\frac{v_{0}^2\\sin(2\\theta) }{g}}\\] Investigating how angle and the initial velocity influence the range of the projectile motion Varying angles import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile.\"\"\" # Convert angle to radians angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Parameters initial_velocity = 30 # m/s angles = [15, 30, 45, 60, 75] # Selected launch angles (degrees) # Setting up the plot plt.figure(figsize=(10, 6)) # Loop through each angle to plot the trajectory for angle in angles: x, y = projectile_motion(initial_velocity, angle) plt.plot(x, y, label=f'\u03b8 = {angle}\u00b0') # Customize the plot plt.title('Projectile Trajectories for Different Launch Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show() The general form of the range as a function of \\(\\theta\\) . It demonstrates how varying the launch angle affects the distance traveled. Different values of \\(v_0\\) affect the range as well. As a result, we get a family of parabolic curves when graphed. The range \\(R\\) depends on the angle of projection \\(\\theta\\) through the sine function, which reaches its maximum at \\(90^\\circ\\) . However, due to the sinusoidal nature of the \\(\\sin\u2061(2\\theta)\\) , the optimal launch angle for maximum horizontal range is \\(45^\\circ\\) . Varying initial velocity import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile.\"\"\" # Convert angle to radians angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Parameters angle = 45 initial_velocities = [10, 20, 30, 40, 50] # m/s # Setting up the plot plt.figure(figsize=(10, 6)) # Loop velocities each angle to plot the trajectory for initial_velocity in initial_velocities: x, y = projectile_motion(initial_velocity, angle) plt.plot(x, y, label=f'v0 = {initial_velocity}') # Customize the plot plt.title('Projectile Trajectories for Different Launch Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show() Taking altitude into account Given everything discussed above, let's add another parameter into the equation: altitude. Suppose a projectile is launched from a height \\(h_{0}\\) above the ground. The equation of the vertical component of the motion then changes: \\[ y(t)=h_{0}+v_{0}\\sin (\\theta) t - \\frac{1}{2}gt^2 \\] To find the time of flight with this parameter added, we need to solve the above equation at \\(0\\) : \\[ 0=h_{0}+v_{0}\\sin (\\theta) t - \\frac{1}{2}gt^2 \\] Launch time: \\[ t_{1}=\\frac{v_{0}\\sin(\\theta)+\\sqrt{ v_{0}^2\\sin(\\theta)^2 +2gh_{0} }}{g} \\] When the projectile hits the ground: \\[ t_{2}=\\frac{v_{0}\\sin(\\theta)-\\sqrt{ v_{0}^2\\sin(\\theta)^2 +2gh_{0} }}{g} \\] The horizontal range is then: \\[ R=v_{0}t_{2} \\] Demonstration import numpy as np import matplotlib.pyplot as plt def projectile_motion_with_altitude(v0, angle, h0, g=9.81, dt=0.01): \"\"\"Calculate the trajectory of a projectile launched from an altitude.\"\"\" angle_rad = np.radians(angle) # Initial velocities v_x = v0 * np.cos(angle_rad) v_y = v0 * np.sin(angle_rad) # Initialize lists to store positions and time t_values = [0] x_values = [0] y_values = [h0] # Start from initial height x, y = 0, h0 # Initial position at the height h0 t = 0 # Initial time while y >= 0: # Continue until the projectile hits the ground (y < 0) # Update positions x += v_x * dt y += v_y * dt # Update velocities due to gravity v_y -= g * dt # Only vertical component affected by gravity # Record values t += dt t_values.append(t) x_values.append(x) y_values.append(y) return x_values, y_values # Parameters initial_velocity = 30 # m/s angle = 45 # Launch angle (degrees) altitudes = [-5, 0, 10, 20] # Different launch heights (above or below ground level) # Setting up the plot plt.figure(figsize=(10, 6)) # Loop through different altitudes for h0 in altitudes: x_with_altitude, y_with_altitude = projectile_motion_with_altitude(initial_velocity, angle, h0) plt.plot(x_with_altitude, y_with_altitude, label=f'Initial Height: {h0} m') # Customize the plot plt.title('Projectile Trajectories at Varying Initial Altitudes') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(-10, 150) # X-axis limit plt.ylim(0, 60) # Y-axis limit, accommodating negative heights plt.grid() plt.legend() plt.show() Exploring how launch altitude influences the horizontal range Taking into account air resistance Let's face it: the above model is not realistic unless you live on a planed with zero-density air (actually, you have no chances to survive there). This section aims to derive equations that do take air resistance into account. The simplest model considers a drag force proportional to the velocity ( the faster the projectile moves, the stronger the air resistance ), i.e., linear drag . Horizontal motion with air resistance ( \\(x\\) -direction) The total force acting on the projectile on the \\(x\\) -axis, given air resistance, is as follows: \\[ F_{x} = ma_{x} = -bv_{x} \\] where \\(b\\) is the drag coefficient. Given \\(v_{x} = \\frac{dx}{dt}\\) , and \\(a_{x} = \\frac{d^2x}{dt^2}\\) , we derive: \\[ \\begin{cases} F_{x} = m \\frac{d^2x}{dt^2} \\\\ F_{x} = -b \\frac{dx}{dt} \\end{cases} \\implies m \\frac{d^2x}{dt^2} = -b \\frac{dx}{dt} \\] Eliminating mass \\(m\\) from the left gives: \\[ \\boxed{\\frac{d^2x}{dt^2} = -\\frac{b}{m} \\frac{dx}{dt}} \\] To solve this, first separate variables (given that acceleration is the first derivative of velocity): \\[ \\frac{dv_{x}}{dt} = -\\frac{b}{m} v_{x} \\implies \\frac{1}{v_{x}} \\frac{dv_{x}}{dt} = -\\frac{b}{m} \\] Integrating both parts over \\(dt\\) : \\[ \\int{\\frac{1}{v_{x}} \\frac{dv_{x}}{dt} dt} = \\int-\\frac{b}{m} dt \\] Implies: \\[ \\int{\\frac{1}{v_{x}} dv_{x}} = -\\frac{b}{m} \\int dt \\] Integration gives: \\[ \\ln | v_{x} | = -\\frac{b}{m} t + C_{3} \\] Therefore, \\[ v_{x}(t) = v_{0}\\cos(\\theta)e^{-b/m}t \\] Integrating again to get \\(x(t)\\) : \\[ x(t) = \\frac{mv_{0}\\cos(\\theta)}{b}(1-e^{-\\frac{b}{m}t}) + C_{4} \\] If \\(x(0) =0\\) , we find \\(C_{4}=0\\) . Vertical motion with air resistance ( \\(y\\) -direction) The total force acting on the projectile on the \\(x\\) -axis, given air resistance, is as follows: \\[ F_{y} = -mg - bv_{y} \\] where \\(b\\) is the drag coefficient. Given that \\(F_{y} = ma_{y}\\) , \\(a_{y} = \\frac{d^2y}{dy^2}\\) , and \\(v_{y} = \\frac{dy}{dt}\\) : \\[ m \\frac{d^2y}{dy^2} = -mg - b \\frac{dy}{dt} \\] Eliminating mass gives: \\[ \\boxed{\\frac{d^2y}{dy^2} = -g - \\frac{b}{m} \\frac{dy}{dt}} \\] Reorganizing items and substituting \\(v_y\\) , his can be rewritten as \\[ \\frac{dv_{y}}{dt} + \\frac{b}{m}v_{y} = -g \\] This is again a first-order linear differential equation, with solution:b \\[ v_{y}(t) = \\left( v_{0}\\sin(\\theta) + \\frac{mg}{b} \\right)e^{ - \\frac{b}{m}t} - \\frac{mg}{b} \\] Integrating gives: \\[ y(t) = -\\frac{m}{b}\\left( v_{0}\\sin(\\theta) + \\frac{mg}{b}\\right)e^{-\\frac{b}{m}t } + \\frac{mg}{b}t + C_{5} \\] With \\(y(0) =0\\) : set \\(C_{5} = 0\\) . Demonstration import numpy as np import matplotlib.pyplot as plt def projectile_motion_no_drag(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile without air resistance.\"\"\" angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def projectile_motion_with_drag(v0, angle, b, g=9.81, dt=0.01): \"\"\"Calculate the trajectory of a projectile with air resistance.\"\"\" angle_rad = np.radians(angle) # Initial velocities v_x = v0 * np.cos(angle_rad) v_y = v0 * np.sin(angle_rad) # Initialize lists to store positions and time t_values = [0] x_values = [0] y_values = [0] x, y = 0, 0 # Initial position t = 0 # Initial time while y >= 0: # Continue until the projectile hits the ground # Update positions x += v_x * dt y += v_y * dt # Update velocities with drag force v_x -= (b * v_x / np.sqrt(v_x**2 + v_y**2)) * dt # Drag force v_y -= (g + (b * v_y / np.sqrt(v_x**2 + v_y**2))) * dt # Gravitational force + Drag # Record values t += dt t_values.append(t) x_values.append(x) y_values.append(y) return x_values, y_values # Parameters initial_velocity = 30 # m/s drag_coefficient = 0.1 # Drag coefficient angle = 45 # Launch angle (degrees) # Calculate projectile motion trajectories x_no_drag, y_no_drag = projectile_motion_no_drag(initial_velocity, angle) x_with_drag, y_with_drag = projectile_motion_with_drag(initial_velocity, angle, drag_coefficient) # Setting up the plot plt.figure(figsize=(10, 6)) plt.plot(x_no_drag, y_no_drag, label='No Air Resistance', color='blue') drags = [0.5, 1.0, 1.5, 2.0] colors = ['darkred', 'red', 'darkorange', 'orange'] # Loop through drag coefficients and colors simultaneously for drag, c in zip(drags, colors): x_with_drag, y_with_drag = projectile_motion_with_drag(initial_velocity, angle, drag) plt.plot(x_with_drag, y_with_drag, label=f'Air Resistance: {drag}', color=c, linestyle='--') # Customize the plot plt.title('Projectile Trajectories: With Varying Air Resistance vs Without Air Resistance') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-basic-formulas-of-the-projectile-motion","text":"Suppose a projectile is launched at an angle \\(\\theta\\) above the horizontal with an initial velocity \\(v_{0}\\) . For this section, assume no air resistance .","title":"Deriving basic formulas of the projectile motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion-x-direction","text":"In the absence of air resistance, there is no horizontal force acting on the projectile: \\[ F_{x} = 0 \\] Based on the Second Newton's Law of Motion: \\[ \\vec{F} = m\\vec{a} \\] Therefore, \\[ m a_{x} = 0 \\implies \\frac{d^2x}{dt^2}m=0 \\] Since the projectile does not accelerate on the \\(x\\) -axis, its immediate velocity (the first derivative of path) equals to the initial velocity with which the projectile has been launched in the first place: \\[ \\frac{dx}{dt} = v_{0x} \\] The \\(x\\) -component of the initial velocity is \\[ v_{0x} = v_{0}\\cos(\\theta) \\] Therefore, the equation of motion of the projectile on the \\(x\\) -axis can be described with the following equation: $$ \\boxed{\\frac{dt}{dx} = v_{0}\\cos(\\theta)} $$ Where \\(\\theta\\) is the launch angle of the projectile. To find the \\(x\\) -component of the position of the projectile at time \\(t\\) , we need to solve this equation for \\(x\\) . Solving the above differential equation will give us the following: \\[ x(t) = v_{0}\\cos(\\theta)t + C_{1} \\] To find \\(C_{1}\\) , set the initial condition \\(x(0) = 0\\) (the path at time \\(0\\) is, of course, \\(0\\) ), and therefore \\[ C_{1} = 0 \\] Thus, \\[ \\boxed{x(t) = v_{0}\\cos(\\theta)t} \\] This equation will give us the position of the projectile at the time \\(t\\) .","title":"Horizontal motion (\\(x\\)-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion-y-direction","text":"The only force acting vertically is the force of gravity : \\[ F_{y}=-mg \\] The projectile doesn't experience any other acceleration and moves until it hits the ground due to gravity. Therefore, the \\(y\\) -component of the projectile motion can be described with the following equation: \\[ \\boxed{\\frac{dy}{dt} = v_{0}\\sin(\\theta)-gt} \\] Where \\(v_{0}\\sin(\\theta)\\) is the \\(y\\) -component of the initial velocity of the projectile, and \\(g\\) is the acceleration due to gravity (i.e., \\(\\frac{d^2y}{dt^2} = -g\\) ). This gives us \\[ \\boxed{y(t)=v_{0}\\sin(\\theta)t -\\frac{1}{2}gt^2} \\]","title":"Vertical motion (\\(y\\)-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#when-the-projectile-hits-the-ground","text":"To find when the projectile hits the ground, we set \\(y(t)=0\\) (altitude zero): \\[ 0=v_{0}\\sin(\\theta)t -\\frac{1}{2}gt^2 \\] Rearranging items gives us: \\[ -\\frac{1}{2}gt^2 + v_{0}\\sin(\\theta) = 0 \\] Solving the quadratic equation: \\(D=(v_{0}\\sin(\\theta))^2\\) \\(t_{1} = \\frac{-v_{0}\\sin(\\theta)+v_{0}\\sin(\\theta)}{-1g} = \\frac{0}{-g} =0\\) - when the projectile is launched; \\(t_{2}=\\frac{-v_{0}\\sin(\\theta)-v_{0}\\sin(\\theta)}{-g}=\\frac{2v_{0}\\sin(\\theta)}{g}\\) So that, the total flight time of a projectile launched with the velocity \\(v_{0}\\) at the angle \\(\\theta\\) : \\[ \\boxed{t_{f}=\\frac{2v_{0}\\sin(\\theta)}{g}} \\]","title":"When the projectile hits the ground"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#the-horizontal-range","text":"The range that the projectile passes, i.e., the horizontal distance traveled when \\(t=t_{f}\\) , can be found by the formula: \\[R=v_{0x}(t_{f})=v_{0}\\cos(\\theta)\\frac{2v_{0}\\sin(\\theta)}{g}=\\frac{2v_{0}^2 \\left( \\frac{1}{2} \\sin(2\\theta)\\right) }{g}=\\frac{v_{0}^2\\sin(2\\theta) }{g}\\] \\[\\boxed{R=\\frac{v_{0}^2\\sin(2\\theta) }{g}}\\]","title":"The horizontal range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-how-angle-and-the-initial-velocity-influence-the-range-of-the-projectile-motion","text":"","title":"Investigating how angle and the initial velocity influence the range of the projectile motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#varying-angles","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile.\"\"\" # Convert angle to radians angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Parameters initial_velocity = 30 # m/s angles = [15, 30, 45, 60, 75] # Selected launch angles (degrees) # Setting up the plot plt.figure(figsize=(10, 6)) # Loop through each angle to plot the trajectory for angle in angles: x, y = projectile_motion(initial_velocity, angle) plt.plot(x, y, label=f'\u03b8 = {angle}\u00b0') # Customize the plot plt.title('Projectile Trajectories for Different Launch Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show() The general form of the range as a function of \\(\\theta\\) . It demonstrates how varying the launch angle affects the distance traveled. Different values of \\(v_0\\) affect the range as well. As a result, we get a family of parabolic curves when graphed. The range \\(R\\) depends on the angle of projection \\(\\theta\\) through the sine function, which reaches its maximum at \\(90^\\circ\\) . However, due to the sinusoidal nature of the \\(\\sin\u2061(2\\theta)\\) , the optimal launch angle for maximum horizontal range is \\(45^\\circ\\) .","title":"Varying angles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#varying-initial-velocity","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile.\"\"\" # Convert angle to radians angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Parameters angle = 45 initial_velocities = [10, 20, 30, 40, 50] # m/s # Setting up the plot plt.figure(figsize=(10, 6)) # Loop velocities each angle to plot the trajectory for initial_velocity in initial_velocities: x, y = projectile_motion(initial_velocity, angle) plt.plot(x, y, label=f'v0 = {initial_velocity}') # Customize the plot plt.title('Projectile Trajectories for Different Launch Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show()","title":"Varying initial velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#taking-altitude-into-account","text":"Given everything discussed above, let's add another parameter into the equation: altitude. Suppose a projectile is launched from a height \\(h_{0}\\) above the ground. The equation of the vertical component of the motion then changes: \\[ y(t)=h_{0}+v_{0}\\sin (\\theta) t - \\frac{1}{2}gt^2 \\] To find the time of flight with this parameter added, we need to solve the above equation at \\(0\\) : \\[ 0=h_{0}+v_{0}\\sin (\\theta) t - \\frac{1}{2}gt^2 \\] Launch time: \\[ t_{1}=\\frac{v_{0}\\sin(\\theta)+\\sqrt{ v_{0}^2\\sin(\\theta)^2 +2gh_{0} }}{g} \\] When the projectile hits the ground: \\[ t_{2}=\\frac{v_{0}\\sin(\\theta)-\\sqrt{ v_{0}^2\\sin(\\theta)^2 +2gh_{0} }}{g} \\] The horizontal range is then: \\[ R=v_{0}t_{2} \\]","title":"Taking altitude into account"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#demonstration","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion_with_altitude(v0, angle, h0, g=9.81, dt=0.01): \"\"\"Calculate the trajectory of a projectile launched from an altitude.\"\"\" angle_rad = np.radians(angle) # Initial velocities v_x = v0 * np.cos(angle_rad) v_y = v0 * np.sin(angle_rad) # Initialize lists to store positions and time t_values = [0] x_values = [0] y_values = [h0] # Start from initial height x, y = 0, h0 # Initial position at the height h0 t = 0 # Initial time while y >= 0: # Continue until the projectile hits the ground (y < 0) # Update positions x += v_x * dt y += v_y * dt # Update velocities due to gravity v_y -= g * dt # Only vertical component affected by gravity # Record values t += dt t_values.append(t) x_values.append(x) y_values.append(y) return x_values, y_values # Parameters initial_velocity = 30 # m/s angle = 45 # Launch angle (degrees) altitudes = [-5, 0, 10, 20] # Different launch heights (above or below ground level) # Setting up the plot plt.figure(figsize=(10, 6)) # Loop through different altitudes for h0 in altitudes: x_with_altitude, y_with_altitude = projectile_motion_with_altitude(initial_velocity, angle, h0) plt.plot(x_with_altitude, y_with_altitude, label=f'Initial Height: {h0} m') # Customize the plot plt.title('Projectile Trajectories at Varying Initial Altitudes') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(-10, 150) # X-axis limit plt.ylim(0, 60) # Y-axis limit, accommodating negative heights plt.grid() plt.legend() plt.show()","title":"Demonstration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#exploring-how-launch-altitude-influences-the-horizontal-range","text":"","title":"Exploring how launch altitude influences the horizontal range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#taking-into-account-air-resistance","text":"Let's face it: the above model is not realistic unless you live on a planed with zero-density air (actually, you have no chances to survive there). This section aims to derive equations that do take air resistance into account. The simplest model considers a drag force proportional to the velocity ( the faster the projectile moves, the stronger the air resistance ), i.e., linear drag .","title":"Taking into account air resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion-with-air-resistance-x-direction","text":"The total force acting on the projectile on the \\(x\\) -axis, given air resistance, is as follows: \\[ F_{x} = ma_{x} = -bv_{x} \\] where \\(b\\) is the drag coefficient. Given \\(v_{x} = \\frac{dx}{dt}\\) , and \\(a_{x} = \\frac{d^2x}{dt^2}\\) , we derive: \\[ \\begin{cases} F_{x} = m \\frac{d^2x}{dt^2} \\\\ F_{x} = -b \\frac{dx}{dt} \\end{cases} \\implies m \\frac{d^2x}{dt^2} = -b \\frac{dx}{dt} \\] Eliminating mass \\(m\\) from the left gives: \\[ \\boxed{\\frac{d^2x}{dt^2} = -\\frac{b}{m} \\frac{dx}{dt}} \\] To solve this, first separate variables (given that acceleration is the first derivative of velocity): \\[ \\frac{dv_{x}}{dt} = -\\frac{b}{m} v_{x} \\implies \\frac{1}{v_{x}} \\frac{dv_{x}}{dt} = -\\frac{b}{m} \\] Integrating both parts over \\(dt\\) : \\[ \\int{\\frac{1}{v_{x}} \\frac{dv_{x}}{dt} dt} = \\int-\\frac{b}{m} dt \\] Implies: \\[ \\int{\\frac{1}{v_{x}} dv_{x}} = -\\frac{b}{m} \\int dt \\] Integration gives: \\[ \\ln | v_{x} | = -\\frac{b}{m} t + C_{3} \\] Therefore, \\[ v_{x}(t) = v_{0}\\cos(\\theta)e^{-b/m}t \\] Integrating again to get \\(x(t)\\) : \\[ x(t) = \\frac{mv_{0}\\cos(\\theta)}{b}(1-e^{-\\frac{b}{m}t}) + C_{4} \\] If \\(x(0) =0\\) , we find \\(C_{4}=0\\) .","title":"Horizontal motion with air resistance (\\(x\\)-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion-with-air-resistance-y-direction","text":"The total force acting on the projectile on the \\(x\\) -axis, given air resistance, is as follows: \\[ F_{y} = -mg - bv_{y} \\] where \\(b\\) is the drag coefficient. Given that \\(F_{y} = ma_{y}\\) , \\(a_{y} = \\frac{d^2y}{dy^2}\\) , and \\(v_{y} = \\frac{dy}{dt}\\) : \\[ m \\frac{d^2y}{dy^2} = -mg - b \\frac{dy}{dt} \\] Eliminating mass gives: \\[ \\boxed{\\frac{d^2y}{dy^2} = -g - \\frac{b}{m} \\frac{dy}{dt}} \\] Reorganizing items and substituting \\(v_y\\) , his can be rewritten as \\[ \\frac{dv_{y}}{dt} + \\frac{b}{m}v_{y} = -g \\] This is again a first-order linear differential equation, with solution:b \\[ v_{y}(t) = \\left( v_{0}\\sin(\\theta) + \\frac{mg}{b} \\right)e^{ - \\frac{b}{m}t} - \\frac{mg}{b} \\] Integrating gives: \\[ y(t) = -\\frac{m}{b}\\left( v_{0}\\sin(\\theta) + \\frac{mg}{b}\\right)e^{-\\frac{b}{m}t } + \\frac{mg}{b}t + C_{5} \\] With \\(y(0) =0\\) : set \\(C_{5} = 0\\) .","title":"Vertical motion with air resistance (\\(y\\)-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#demonstration_1","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion_no_drag(v0, angle, g=9.81): \"\"\"Calculate the trajectory of a projectile without air resistance.\"\"\" angle_rad = np.radians(angle) # Time of flight t_f = (2 * v0 * np.sin(angle_rad)) / g # Time points for plotting t = np.linspace(0, t_f, num=500) # Calculate x and y positions x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def projectile_motion_with_drag(v0, angle, b, g=9.81, dt=0.01): \"\"\"Calculate the trajectory of a projectile with air resistance.\"\"\" angle_rad = np.radians(angle) # Initial velocities v_x = v0 * np.cos(angle_rad) v_y = v0 * np.sin(angle_rad) # Initialize lists to store positions and time t_values = [0] x_values = [0] y_values = [0] x, y = 0, 0 # Initial position t = 0 # Initial time while y >= 0: # Continue until the projectile hits the ground # Update positions x += v_x * dt y += v_y * dt # Update velocities with drag force v_x -= (b * v_x / np.sqrt(v_x**2 + v_y**2)) * dt # Drag force v_y -= (g + (b * v_y / np.sqrt(v_x**2 + v_y**2))) * dt # Gravitational force + Drag # Record values t += dt t_values.append(t) x_values.append(x) y_values.append(y) return x_values, y_values # Parameters initial_velocity = 30 # m/s drag_coefficient = 0.1 # Drag coefficient angle = 45 # Launch angle (degrees) # Calculate projectile motion trajectories x_no_drag, y_no_drag = projectile_motion_no_drag(initial_velocity, angle) x_with_drag, y_with_drag = projectile_motion_with_drag(initial_velocity, angle, drag_coefficient) # Setting up the plot plt.figure(figsize=(10, 6)) plt.plot(x_no_drag, y_no_drag, label='No Air Resistance', color='blue') drags = [0.5, 1.0, 1.5, 2.0] colors = ['darkred', 'red', 'darkorange', 'orange'] # Loop through drag coefficients and colors simultaneously for drag, c in zip(drags, colors): x_with_drag, y_with_drag = projectile_motion_with_drag(initial_velocity, angle, drag) plt.plot(x_with_drag, y_with_drag, label=f'Air Resistance: {drag}', color=c, linestyle='--') # Customize the plot plt.title('Projectile Trajectories: With Varying Air Resistance vs Without Air Resistance') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.axhline(0, color='gray', lw=0.8) # Ground line plt.axvline(0, color='gray', lw=0.8) # Vertical line plt.xlim(0, 100) # X-axis limit plt.ylim(0, 40) # Y-axis limit plt.grid() plt.legend() plt.show()","title":"Demonstration"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Pendulum motion: small angles The motion of a forced damped pendulum is described by the following second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L}\\sin \\theta = A \\cos(wt) \\] This is a second-order differential equation governing the angular displacement \\(\\theta\\) of a pendulum with damping and driven forces. Here: Notation Description \\(\\theta\\) Angular displacement from the vertical ( equilibrium ) position; measured in radians. \\(\\frac{d^2\\theta}{dt^2}\\) Angular acceleration of the pendulum. \\(b\\) Damping coefficient (which accounts for friction or air resistance). \\(\\frac{d\\theta}{dt}\\) Angular velocity of the pendulum (the rate of change of the angle \\(\\theta\\) ) \\(g\\) Acceleration due to gravity. \\(L\\) The length of the pendulum. \\(A\\cos(\\omega t)\\) Represents the external driving force; \\(A\\) is the amplitude, and \\(\\omega\\) is the angular frequency of the external forcing. For small angles ( \\(\\theta\\) approaching to \\(0\\) or \\(\\theta \\approx 0\\) ), we can use the approximation \\(\\sin(\\theta) \\approx \\theta\\) . With this, the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L}\\sin \\theta = A \\cos(wt) \\implies \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(wt) \\] Solving differential equation of a damped pendulum for small-angle approximations To solve the equation, we first consider the homogeneous part (setting the driving force to zero): \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] This is a standard form for a damped harmonic oscillator. To solve this linear differential equation, we assume a solution of the form: \\[ \\theta(t) = e^{rt} \\] Here, \\(r\\) is the constant we want to determine. The first derivative of our assumed solution is \\(\\frac{d\\theta}{dt} = re^{rt}\\) . The second is \\(\\frac{d^2\\theta}{dt^2} = r^2e^{rt}\\) . Substituting, gives \\[ r^2e^{rt} + b(re^{rt}) + \\frac{g}{L}(e^{rt}) = 0 \\] Factoring out \\(e^{rt}\\) : \\[ e^{rt}(r^2 + br + \\frac{g}{L}) = 0 \\] The term \\(e^{rt}\\) does not contribute any solutions since it is always positive for real values of \\(r\\) . Therefore, we obtain our characteristic equation from the remaining polynomial: \\[ r^2+br+\\frac{g}{L} =0 \\] To find \\(r\\) , we need to solve the above equation: \\[ r = \\frac{-b\\pm \\sqrt{ b^2 -4\\frac{g}{L} }}{2} \\] Where \\(D= b^2 -4\\frac{g}{L}\\) . Roots and behavior: Underdamped Condition: \\(D > 0 \\implies b^2 \\gt 4 \\frac{g}{L}\\) Result: Two distinct real roots, leading to oscillatory motion with gradually decreasing amplitude (oscillations). Physically, this means the pendulum swings back and forth across the vertical position, with the amplitude decreasing over time due to damping. The oscillations gradually lose energy (due to friction or air resistance), resulting in a motion that resembles a sine wave, but one that progressively decays. This is the pendulum we usually think about, i.e., a swinging pendulum that slowly stops swinging as it loses energy. Critically damped Condition: \\(D = 0 \\implies b^2 = 4 \\frac{g}{L}\\) Result: Two identical real roots, leading to the system returning to equilibrium as quickly as possible without oscillating. In this case, the pendulum will move towards its lowest point but won't overshoot or undergo any oscillation. It smoothly comes to rest at the vertical position. Take a door as an example: its damping mechanism shuts the door quickly without bouncing back. Overdamped Condition: \\(D < 0 \\implies b^2 < 4 \\frac{g}{L}\\) Result: Two complex conjugate roots, leading to a non-oscillatory return toward equilibrium. The system takes longer to return than in the critically damped case. Here, the pendulum slowly returns to its resting position without any oscillations, typically taking a longer time to settle compared to the critically damped case. For example, a pendulum that is heavily damped (like a long jump rope acting as a pendulum) that gently settles down without swinging back and forth. Take a look at my Python demonstration: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # Underdamped case parameters (b^2 > 4g/L) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Critically damped case parameters (b^2 = 4g/L) b_critically_damped = 2 * np.sqrt(g / L) theta_critically_damped = np.exp(-b_critically_damped / 2 * t) * (1 + (b_critically_damped / 2) * t) # Overdamped case parameters (b^2 < 4g/L) b_overdamped = 3.0 # Choose a value greater than 2*sqrt(g/L) omega_0_overdamped = np.sqrt((b_overdamped / 2) ** 2 - g / L) theta_overdamped = np.exp(-b_overdamped / 2 * t) * (np.cosh(omega_0_overdamped * t) - (b_overdamped / (2*omega_0_overdamped)) * np.sinh(omega_0_overdamped * t)) # Plotting plt.figure(figsize=(12, 8)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='Underdamped', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Critically Damped plt.subplot(3, 1, 2) plt.plot(t, theta_critically_damped, label='Critically Damped', color='orange') plt.title('Critically Damped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_overdamped, label='Overdamped', color='green') plt.title('Overdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show() Exploring initial conditions of an underdamped pendulum You can also use this website to see demonstrations. These are not mine, but I think the resource is useful. Changing damping coefficient import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # Plotting plt.figure(figsize=(12, 8)) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='Underdamped: b = 1', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() b_underdamped = 2.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) plt.subplot(3, 1, 2) plt.plot(t, theta_underdamped, label='Underdamped: b = 2', color='violet') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() b_underdamped = 3.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_underdamped, label='Underdamped: b = 3', color='red') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show() We see that, as we increase the damping coefficient, underdamped motion approaches to critically damped. Here is another thing. If we continue to increase the damping coefficient, at some point, the graph will disappear (overdamped). The red line below shows the maximum damping I could obtain by increasing the damping coefficient before the graph disappears: Changing pendulum length import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) # Time array t = np.linspace(0, 10, 500) # Plotting plt.figure(figsize=(12, 8)) L = 1.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='L = 1', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() L = 2.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) plt.subplot(3, 1, 2) plt.plot(t, theta_underdamped, label='L = 2', color='violet') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() L = 3.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_underdamped, label='L = 3', color='red') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#pendulum-motion-small-angles","text":"The motion of a forced damped pendulum is described by the following second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L}\\sin \\theta = A \\cos(wt) \\] This is a second-order differential equation governing the angular displacement \\(\\theta\\) of a pendulum with damping and driven forces. Here: Notation Description \\(\\theta\\) Angular displacement from the vertical ( equilibrium ) position; measured in radians. \\(\\frac{d^2\\theta}{dt^2}\\) Angular acceleration of the pendulum. \\(b\\) Damping coefficient (which accounts for friction or air resistance). \\(\\frac{d\\theta}{dt}\\) Angular velocity of the pendulum (the rate of change of the angle \\(\\theta\\) ) \\(g\\) Acceleration due to gravity. \\(L\\) The length of the pendulum. \\(A\\cos(\\omega t)\\) Represents the external driving force; \\(A\\) is the amplitude, and \\(\\omega\\) is the angular frequency of the external forcing. For small angles ( \\(\\theta\\) approaching to \\(0\\) or \\(\\theta \\approx 0\\) ), we can use the approximation \\(\\sin(\\theta) \\approx \\theta\\) . With this, the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L}\\sin \\theta = A \\cos(wt) \\implies \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(wt) \\]","title":"Pendulum motion: small angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solving-differential-equation-of-a-damped-pendulum-for-small-angle-approximations","text":"To solve the equation, we first consider the homogeneous part (setting the driving force to zero): \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] This is a standard form for a damped harmonic oscillator. To solve this linear differential equation, we assume a solution of the form: \\[ \\theta(t) = e^{rt} \\] Here, \\(r\\) is the constant we want to determine. The first derivative of our assumed solution is \\(\\frac{d\\theta}{dt} = re^{rt}\\) . The second is \\(\\frac{d^2\\theta}{dt^2} = r^2e^{rt}\\) . Substituting, gives \\[ r^2e^{rt} + b(re^{rt}) + \\frac{g}{L}(e^{rt}) = 0 \\] Factoring out \\(e^{rt}\\) : \\[ e^{rt}(r^2 + br + \\frac{g}{L}) = 0 \\] The term \\(e^{rt}\\) does not contribute any solutions since it is always positive for real values of \\(r\\) . Therefore, we obtain our characteristic equation from the remaining polynomial: \\[ r^2+br+\\frac{g}{L} =0 \\] To find \\(r\\) , we need to solve the above equation: \\[ r = \\frac{-b\\pm \\sqrt{ b^2 -4\\frac{g}{L} }}{2} \\] Where \\(D= b^2 -4\\frac{g}{L}\\) . Roots and behavior: Underdamped Condition: \\(D > 0 \\implies b^2 \\gt 4 \\frac{g}{L}\\) Result: Two distinct real roots, leading to oscillatory motion with gradually decreasing amplitude (oscillations). Physically, this means the pendulum swings back and forth across the vertical position, with the amplitude decreasing over time due to damping. The oscillations gradually lose energy (due to friction or air resistance), resulting in a motion that resembles a sine wave, but one that progressively decays. This is the pendulum we usually think about, i.e., a swinging pendulum that slowly stops swinging as it loses energy. Critically damped Condition: \\(D = 0 \\implies b^2 = 4 \\frac{g}{L}\\) Result: Two identical real roots, leading to the system returning to equilibrium as quickly as possible without oscillating. In this case, the pendulum will move towards its lowest point but won't overshoot or undergo any oscillation. It smoothly comes to rest at the vertical position. Take a door as an example: its damping mechanism shuts the door quickly without bouncing back. Overdamped Condition: \\(D < 0 \\implies b^2 < 4 \\frac{g}{L}\\) Result: Two complex conjugate roots, leading to a non-oscillatory return toward equilibrium. The system takes longer to return than in the critically damped case. Here, the pendulum slowly returns to its resting position without any oscillations, typically taking a longer time to settle compared to the critically damped case. For example, a pendulum that is heavily damped (like a long jump rope acting as a pendulum) that gently settles down without swinging back and forth. Take a look at my Python demonstration: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # Underdamped case parameters (b^2 > 4g/L) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Critically damped case parameters (b^2 = 4g/L) b_critically_damped = 2 * np.sqrt(g / L) theta_critically_damped = np.exp(-b_critically_damped / 2 * t) * (1 + (b_critically_damped / 2) * t) # Overdamped case parameters (b^2 < 4g/L) b_overdamped = 3.0 # Choose a value greater than 2*sqrt(g/L) omega_0_overdamped = np.sqrt((b_overdamped / 2) ** 2 - g / L) theta_overdamped = np.exp(-b_overdamped / 2 * t) * (np.cosh(omega_0_overdamped * t) - (b_overdamped / (2*omega_0_overdamped)) * np.sinh(omega_0_overdamped * t)) # Plotting plt.figure(figsize=(12, 8)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='Underdamped', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Critically Damped plt.subplot(3, 1, 2) plt.plot(t, theta_critically_damped, label='Critically Damped', color='orange') plt.title('Critically Damped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_overdamped, label='Overdamped', color='green') plt.title('Overdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show()","title":"Solving differential equation of a damped pendulum for small-angle approximations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#exploring-initial-conditions-of-an-underdamped-pendulum","text":"You can also use this website to see demonstrations. These are not mine, but I think the resource is useful.","title":"Exploring initial conditions of an underdamped pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#changing-damping-coefficient","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) # Time array t = np.linspace(0, 10, 500) # Plotting plt.figure(figsize=(12, 8)) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='Underdamped: b = 1', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() b_underdamped = 2.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) plt.subplot(3, 1, 2) plt.plot(t, theta_underdamped, label='Underdamped: b = 2', color='violet') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() b_underdamped = 3.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_underdamped, label='Underdamped: b = 3', color='red') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show() We see that, as we increase the damping coefficient, underdamped motion approaches to critically damped. Here is another thing. If we continue to increase the damping coefficient, at some point, the graph will disappear (overdamped). The red line below shows the maximum damping I could obtain by increasing the damping coefficient before the graph disappears:","title":"Changing damping coefficient"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#changing-pendulum-length","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # acceleration due to gravity (m/s^2) # Time array t = np.linspace(0, 10, 500) # Plotting plt.figure(figsize=(12, 8)) L = 1.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Underdamped plt.subplot(3, 1, 1) plt.plot(t, theta_underdamped, label='L = 1', color='blue') plt.title('Underdamped Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() L = 2.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) plt.subplot(3, 1, 2) plt.plot(t, theta_underdamped, label='L = 2', color='violet') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() L = 3.0 # length of the pendulum (m) b_underdamped = 1.0 omega_d_underdamped = np.sqrt(g / L - (b_underdamped / 2) ** 2) theta_underdamped = np.exp(-b_underdamped / 2 * t) * (np.cos(omega_d_underdamped * t) + np.sin(omega_d_underdamped * t)) # Overdamped plt.subplot(3, 1, 3) plt.plot(t, theta_underdamped, label='L = 3', color='red') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid() plt.legend() # Adjust layout plt.tight_layout() plt.show()","title":"Changing pendulum length"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}